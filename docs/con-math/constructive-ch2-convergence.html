<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Modulus Machine — Constructive Analysis Chapter 2</title>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Source+Sans+Pro:wght@300;400;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --constructive-primary: #2D5A4A;
      --constructive-glow: #4A9D7C;
      --regular-sequence: #2563EB;
      --limit-point: #EC4899;
      --modulus-function: #F59E0B;
      --convergence-band: #10B981;
      --divergence: #EF4444;
      --cauchy-color: #8B5CF6;
      --fog-light: #9CA3AF;
      --background: #FAF8F5;
      --background-dark: #0F0F12;
      --ink: #1A1A1A;
      --ink-light: #FAF8F5;
      
      --display: 'Crimson Text', serif;
      --body: 'Source Sans Pro', sans-serif;
      --mono: 'JetBrains Mono', monospace;
      
      --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: var(--body);
      background: var(--background);
      color: var(--ink);
      line-height: 1.7;
      overflow-x: hidden;
    }

    /* ============================================
       OPENING
       ============================================ */
    
    .opening {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      background: linear-gradient(180deg, var(--modulus-function) 0%, #B45309 100%);
      color: var(--ink-light);
      position: relative;
      overflow: hidden;
    }

    .opening::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 30% 40%, rgba(16, 185, 129, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 70% 60%, rgba(236, 72, 153, 0.1) 0%, transparent 40%);
      pointer-events: none;
    }

    .opening-content {
      text-align: center;
      max-width: 800px;
      position: relative;
      z-index: 1;
    }

    .chapter-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.7);
      margin-bottom: 0.5rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.2s forwards;
    }

    .section-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.9);
      margin-bottom: 1rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.3s forwards;
    }

    .main-title {
      font-family: var(--display);
      font-size: clamp(2rem, 6vw, 3.5rem);
      font-weight: 400;
      line-height: 1.2;
      margin-bottom: 1.5rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.4s forwards;
    }

    .subtitle {
      font-size: 1.15rem;
      color: rgba(255, 255, 255, 0.9);
      max-width: 600px;
      margin: 0 auto;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.6s forwards;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* ============================================
       NARRATIVE SECTIONS
       ============================================ */

    .narrative-section {
      min-height: 60vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4rem 2rem;
    }

    .narrative-section.dark {
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .narrative-content {
      max-width: 650px;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.8s var(--ease-out-expo), transform 0.8s var(--ease-out-expo);
    }

    .narrative-content.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .narrative-content p {
      font-size: 1.2rem;
      margin-bottom: 1.5rem;
    }

    .math-display {
      font-family: var(--mono);
      font-size: 1rem;
      background: rgba(245, 158, 11, 0.1);
      padding: 1.5rem;
      border-radius: 8px;
      text-align: center;
      margin: 1.5rem 0;
      border-left: 3px solid var(--modulus-function);
    }

    .dark .math-display {
      background: rgba(245, 158, 11, 0.15);
    }

    /* ============================================
       THE MODULUS MACHINE
       ============================================ */

    .modulus-section {
      min-height: 100vh;
      padding: 4rem 2rem;
      background: linear-gradient(180deg, #F5F3F0 0%, var(--background) 100%);
    }

    .section-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .section-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .section-subtitle {
      color: #666;
      font-size: 1rem;
      max-width: 600px;
      margin: 0 auto;
    }

    .machine-container {
      max-width: 1100px;
      margin: 0 auto;
    }

    .machine-panel {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.08);
      overflow: hidden;
    }

    .machine-header {
      background: var(--modulus-function);
      color: white;
      padding: 1rem 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .machine-title {
      font-family: var(--display);
      font-size: 1.3rem;
    }

    .machine-formula {
      font-family: var(--mono);
      font-size: 0.85rem;
      opacity: 0.9;
    }

    .machine-body {
      padding: 2rem;
    }

    .machine-grid {
      display: grid;
      grid-template-columns: 300px 1fr;
      gap: 2rem;
      align-items: start;
    }

    @media (max-width: 900px) {
      .machine-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Input Panel */
    .input-panel {
      background: #FAFAFA;
      padding: 1.5rem;
      border-radius: 12px;
    }

    .input-section {
      margin-bottom: 1.5rem;
    }

    .input-section:last-child {
      margin-bottom: 0;
    }

    .input-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--fog-light);
      margin-bottom: 0.8rem;
      display: block;
    }

    .sequence-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .seq-btn {
      padding: 0.5rem 0.8rem;
      border: 2px solid #E0E0E0;
      border-radius: 6px;
      background: white;
      font-family: var(--mono);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .seq-btn:hover {
      border-color: var(--modulus-function);
    }

    .seq-btn.active {
      border-color: var(--modulus-function);
      background: var(--modulus-function);
      color: white;
    }

    .epsilon-input {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .epsilon-slider {
      width: 100%;
      height: 8px;
      -webkit-appearance: none;
      background: #E0E0E0;
      border-radius: 4px;
      outline: none;
    }

    .epsilon-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 24px;
      height: 24px;
      background: var(--modulus-function);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }

    .epsilon-display {
      display: flex;
      justify-content: space-between;
      font-family: var(--mono);
      font-size: 0.85rem;
    }

    .epsilon-value {
      color: var(--modulus-function);
      font-weight: 600;
    }

    .output-display {
      background: white;
      padding: 1.5rem;
      border-radius: 12px;
      border: 3px solid var(--convergence-band);
      text-align: center;
    }

    .output-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--fog-light);
      margin-bottom: 0.5rem;
    }

    .output-value {
      font-family: var(--mono);
      font-size: 2rem;
      color: var(--convergence-band);
    }

    .output-meaning {
      font-size: 0.85rem;
      color: #666;
      margin-top: 0.5rem;
    }

    /* Visualization Panel */
    .viz-panel {
      display: flex;
      flex-direction: column;
    }

    .canvas-container {
      height: 300px;
      background: #FAFAFA;
      border-radius: 12px;
      margin-bottom: 1rem;
    }

    #convergenceCanvas {
      width: 100%;
      height: 100%;
    }

    .viz-legend {
      display: flex;
      justify-content: center;
      gap: 2rem;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.85rem;
    }

    .legend-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .legend-dot.sequence { background: var(--regular-sequence); }
    .legend-dot.limit { background: var(--limit-point); }
    .legend-dot.band { background: var(--convergence-band); }
    .legend-dot.modulus { background: var(--modulus-function); }

    /* ============================================
       CAUCHY ⟺ CONVERGENT
       ============================================ */

    .cauchy-section {
      min-height: 100vh;
      padding: 4rem 2rem;
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .cauchy-container {
      max-width: 1000px;
      margin: 0 auto;
    }

    .cauchy-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .cauchy-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .cauchy-subtitle {
      color: var(--fog-light);
      font-size: 1rem;
    }

    .proof-panel {
      background: rgba(30, 30, 40, 0.5);
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 16px;
      overflow: hidden;
    }

    .proof-tabs {
      display: flex;
      border-bottom: 1px solid rgba(107, 114, 128, 0.3);
    }

    .proof-tab {
      flex: 1;
      padding: 1rem;
      border: none;
      background: transparent;
      color: var(--fog-light);
      font-family: var(--mono);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .proof-tab:hover {
      background: rgba(139, 92, 246, 0.1);
    }

    .proof-tab.active {
      background: rgba(139, 92, 246, 0.2);
      color: var(--cauchy-color);
      border-bottom: 3px solid var(--cauchy-color);
    }

    .proof-body {
      padding: 2rem;
    }

    .proof-step {
      display: none;
    }

    .proof-step.active {
      display: block;
    }

    .step-canvas-container {
      height: 250px;
      margin-bottom: 1.5rem;
    }

    #cauchyCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #0A0A0F;
    }

    .step-explanation {
      background: rgba(139, 92, 246, 0.1);
      padding: 1.5rem;
      border-radius: 12px;
      border-left: 3px solid var(--cauchy-color);
    }

    .step-title {
      font-family: var(--mono);
      font-size: 0.9rem;
      color: var(--cauchy-color);
      margin-bottom: 0.8rem;
    }

    .step-text {
      font-size: 0.95rem;
      line-height: 1.7;
      color: rgba(255, 255, 255, 0.9);
    }

    .step-formula {
      font-family: var(--mono);
      font-size: 0.85rem;
      background: rgba(0, 0, 0, 0.3);
      padding: 0.8rem;
      border-radius: 6px;
      margin: 1rem 0;
      text-align: center;
    }

    /* ============================================
       SERIES CONVERGENCE
       ============================================ */

    .series-section {
      padding: 4rem 2rem;
      background: var(--background);
    }

    .series-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .series-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .series-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .series-panel {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.08);
      padding: 2rem;
    }

    .series-selector {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    .series-btn {
      padding: 0.6rem 1rem;
      border: 2px solid #E0E0E0;
      border-radius: 8px;
      background: white;
      font-family: var(--mono);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .series-btn:hover {
      border-color: var(--convergence-band);
    }

    .series-btn.active {
      border-color: var(--convergence-band);
      background: var(--convergence-band);
      color: white;
    }

    .series-canvas-container {
      height: 250px;
      background: #FAFAFA;
      border-radius: 12px;
      margin-bottom: 1.5rem;
    }

    #seriesCanvas {
      width: 100%;
      height: 100%;
    }

    .series-info {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1rem;
    }

    .info-card {
      background: #FAFAFA;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
    }

    .info-label {
      font-family: var(--mono);
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--fog-light);
      margin-bottom: 0.3rem;
    }

    .info-value {
      font-family: var(--mono);
      font-size: 1.1rem;
    }

    .info-value.converges { color: var(--convergence-band); }
    .info-value.diverges { color: var(--divergence); }

    /* ============================================
       NAVIGATION
       ============================================ */

    .next-section {
      padding: 4rem 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, var(--modulus-function) 0%, #B45309 100%);
      color: var(--ink-light);
      text-align: center;
    }

    .next-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.7);
      margin-bottom: 1rem;
    }

    .next-title {
      font-family: var(--display);
      font-size: 1.6rem;
      margin-bottom: 0.5rem;
    }

    .next-description {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.9);
      max-width: 500px;
    }
  </style>
</head>
<body>

  <!-- Opening -->
  <section class="opening">
    <div class="opening-content">
      <p class="chapter-label">Chapter 2: Calculus and the Real Numbers</p>
      <p class="section-label">Section 3: Sequences and Series</p>
      <h1 class="main-title">The Modulus Machine</h1>
      <p class="subtitle">Every limit comes with an algorithm. Given any ε, the modulus computes exactly how many terms you need.</p>
    </div>
  </section>

  <!-- Narrative: Introduction -->
  <section class="narrative-section">
    <div class="narrative-content" data-animate>
      <p>In classical analysis, we say a sequence (xₙ) converges to L if "for every ε > 0, there exists N such that |xₙ - L| < ε for all n ≥ N."</p>
      <p>But this hides something crucial: <em>how do we find N?</em> The classical definition only asserts existence. Constructively, we demand more.</p>
    </div>
  </section>

  <!-- Narrative: The Definition -->
  <section class="narrative-section">
    <div class="narrative-content" data-animate>
      <div class="math-display">
        A sequence (xₙ) converges to x₀ if there exists a function<br>
        <strong>N : ℤ⁺ → ℤ⁺</strong> such that<br><br>
        |xₙ - x₀| < k⁻¹ &nbsp;&nbsp;for all n ≥ N(k)
      </div>
      <p>The function N is the <strong>modulus of convergence</strong>. It's not optional—it's part of what it means for a sequence to converge. Given any precision k, you can compute N(k) and know exactly when you're within 1/k of the limit.</p>
    </div>
  </section>

  <!-- The Modulus Machine -->
  <section class="modulus-section">
    <div class="section-header">
      <h2 class="section-title">The Modulus Machine</h2>
      <p class="section-subtitle">Feed in ε, get out N — the index where convergence is guaranteed</p>
    </div>

    <div class="machine-container">
      <div class="machine-panel">
        <div class="machine-header">
          <span class="machine-title">Convergence Computer</span>
          <span class="machine-formula">|xₙ - L| < ε for n ≥ N(ε)</span>
        </div>

        <div class="machine-body">
          <div class="machine-grid">
            <div class="input-panel">
              <div class="input-section">
                <label class="input-label">Select Sequence</label>
                <div class="sequence-selector">
                  <button class="seq-btn active" data-seq="sqrt2">√2</button>
                  <button class="seq-btn" data-seq="harmonic">1/n</button>
                  <button class="seq-btn" data-seq="geometric">2⁻ⁿ</button>
                  <button class="seq-btn" data-seq="alternating">(-1)ⁿ/n</button>
                </div>
              </div>

              <div class="input-section">
                <label class="input-label">Precision ε</label>
                <div class="epsilon-input">
                  <input type="range" class="epsilon-slider" id="epsilonSlider" 
                         min="-4" max="-0.5" step="0.1" value="-1">
                  <div class="epsilon-display">
                    <span>ε =</span>
                    <span class="epsilon-value" id="epsilonValue">0.1</span>
                  </div>
                </div>
              </div>

              <div class="input-section">
                <div class="output-display">
                  <p class="output-label">Modulus Output</p>
                  <p class="output-value" id="modulusOutput">N = 5</p>
                  <p class="output-meaning" id="modulusMeaning">
                    For n ≥ 5, |xₙ - L| < 0.1
                  </p>
                </div>
              </div>
            </div>

            <div class="viz-panel">
              <div class="canvas-container">
                <canvas id="convergenceCanvas"></canvas>
              </div>

              <div class="viz-legend">
                <div class="legend-item">
                  <span class="legend-dot sequence"></span>
                  <span>Sequence terms</span>
                </div>
                <div class="legend-item">
                  <span class="legend-dot limit"></span>
                  <span>Limit L</span>
                </div>
                <div class="legend-item">
                  <span class="legend-dot band"></span>
                  <span>ε-band</span>
                </div>
                <div class="legend-item">
                  <span class="legend-dot modulus"></span>
                  <span>N(ε) threshold</span>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Cauchy ⟺ Convergent -->
  <section class="cauchy-section">
    <div class="cauchy-container">
      <div class="cauchy-header">
        <h2 class="cauchy-title">Cauchy ⟺ Convergent</h2>
        <p class="cauchy-subtitle">A sequence is Cauchy if and only if it converges—and the proof is constructive</p>
      </div>

      <div class="proof-panel">
        <div class="proof-tabs">
          <button class="proof-tab active" data-step="cauchy">What is Cauchy?</button>
          <button class="proof-tab" data-step="forward">Convergent → Cauchy</button>
          <button class="proof-tab" data-step="backward">Cauchy → Convergent</button>
        </div>

        <div class="proof-body">
          <!-- What is Cauchy -->
          <div class="proof-step active" data-content="cauchy">
            <div class="step-canvas-container">
              <canvas id="cauchyCanvas"></canvas>
            </div>
            <div class="step-explanation">
              <h3 class="step-title">The Cauchy Condition</h3>
              <p class="step-text">A sequence (xₙ) is <strong>Cauchy</strong> if terms get arbitrarily close to each other—not to some external limit, but to each other.</p>
              <div class="step-formula">
                |xₘ - xₙ| < k⁻¹ &nbsp;&nbsp;for all m, n ≥ M(k)
              </div>
              <p class="step-text">The modulus M(k) tells us when all terms are within 1/k of each other. This is a property of the sequence itself.</p>
            </div>
          </div>

          <!-- Forward direction -->
          <div class="proof-step" data-content="forward">
            <div class="step-canvas-container">
              <canvas id="cauchyCanvas2"></canvas>
            </div>
            <div class="step-explanation">
              <h3 class="step-title">Convergent → Cauchy (Easy Direction)</h3>
              <p class="step-text">If (xₙ) → L with modulus N, then for n, m ≥ N(2k):</p>
              <div class="step-formula">
                |xₘ - xₙ| ≤ |xₘ - L| + |xₙ - L| < (2k)⁻¹ + (2k)⁻¹ = k⁻¹
              </div>
              <p class="step-text">So M(k) = N(2k) works. The triangle inequality does the work.</p>
            </div>
          </div>

          <!-- Backward direction -->
          <div class="proof-step" data-content="backward">
            <div class="step-canvas-container">
              <canvas id="cauchyCanvas3"></canvas>
            </div>
            <div class="step-explanation">
              <h3 class="step-title">Cauchy → Convergent (The Key Construction)</h3>
              <p class="step-text">This is where constructive mathematics shines. The limit is <em>built</em> from the sequence itself:</p>
              <div class="step-formula">
                Define y = (yₖ) where yₖ = the (2k)th rational approximation to x<sub>N(k)</sub>
              </div>
              <p class="step-text">Then y is a real number (it's a regular sequence), and (xₙ) converges to y. The proof explicitly constructs both the limit and the modulus of convergence!</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Series Convergence -->
  <section class="series-section">
    <div class="series-container">
      <div class="series-header">
        <h2 class="series-title">Series & Partial Sums</h2>
      </div>

      <div class="series-panel">
        <div class="series-selector">
          <button class="series-btn active" data-series="geometric">Σ 2⁻ⁿ</button>
          <button class="series-btn" data-series="harmonic">Σ 1/n</button>
          <button class="series-btn" data-series="alternating">Σ (-1)ⁿ/n</button>
          <button class="series-btn" data-series="pseries">Σ 1/n²</button>
        </div>

        <div class="series-canvas-container">
          <canvas id="seriesCanvas"></canvas>
        </div>

        <div class="series-info">
          <div class="info-card">
            <p class="info-label">Series</p>
            <p class="info-value" id="seriesFormula">Σ 2⁻ⁿ</p>
          </div>
          <div class="info-card">
            <p class="info-label">Status</p>
            <p class="info-value converges" id="seriesStatus">Converges</p>
          </div>
          <div class="info-card">
            <p class="info-label">Sum / Behavior</p>
            <p class="info-value" id="seriesSum">= 1</p>
          </div>
          <div class="info-card">
            <p class="info-label">Test Used</p>
            <p class="info-value" id="seriesTest">Ratio test (r = ½)</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Navigation -->
  <section class="next-section">
    <p class="next-label">Coming Next</p>
    <h3 class="next-title">Continuity with Computational Content</h3>
    <p class="next-description">A continuous function comes equipped with a modulus ω(ε) that computes the required δ.</p>
  </section>

  <script>
    // ============================================
    // SCROLL ANIMATIONS
    // ============================================
    
    const observerOptions = { threshold: 0.3, rootMargin: '0px 0px -10% 0px' };
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) entry.target.classList.add('visible');
      });
    }, observerOptions);

    document.querySelectorAll('[data-animate], .narrative-content').forEach(el => observer.observe(el));

    // ============================================
    // CANVAS UTILITIES
    // ============================================
    
    function setupCanvas(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      return { ctx, width: rect.width, height: rect.height };
    }

    // ============================================
    // SEQUENCE DEFINITIONS
    // ============================================
    
    const sequences = {
      sqrt2: {
        name: '√2 (Newton)',
        limit: Math.sqrt(2),
        generate: (n) => {
          let x = 1;
          for (let i = 0; i < n; i++) x = (x + 2/x) / 2;
          return x;
        },
        modulus: (eps) => Math.ceil(Math.log2(Math.log2(1/eps))) + 2
      },
      harmonic: {
        name: '1/n → 0',
        limit: 0,
        generate: (n) => 1 / n,
        modulus: (eps) => Math.ceil(1 / eps)
      },
      geometric: {
        name: '2⁻ⁿ → 0',
        limit: 0,
        generate: (n) => Math.pow(2, -n),
        modulus: (eps) => Math.ceil(Math.log2(1/eps))
      },
      alternating: {
        name: '(-1)ⁿ/n → 0',
        limit: 0,
        generate: (n) => Math.pow(-1, n) / n,
        modulus: (eps) => Math.ceil(1 / eps)
      }
    };

    let currentSeq = 'sqrt2';
    let currentEps = 0.1;

    // ============================================
    // CONVERGENCE VISUALIZATION
    // ============================================
    
    const convergenceCanvas = document.getElementById('convergenceCanvas');
    const epsilonSlider = document.getElementById('epsilonSlider');
    const epsilonValue = document.getElementById('epsilonValue');
    const modulusOutput = document.getElementById('modulusOutput');
    const modulusMeaning = document.getElementById('modulusMeaning');

    function drawConvergence() {
      const { ctx, width, height } = setupCanvas(convergenceCanvas);
      const seq = sequences[currentSeq];
      
      const padding = { left: 50, right: 30, top: 30, bottom: 40 };
      const plotWidth = width - padding.left - padding.right;
      const plotHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#FAFAFA';
      ctx.fillRect(0, 0, width, height);

      const maxN = 20;
      const terms = [];
      for (let n = 1; n <= maxN; n++) {
        terms.push(seq.generate(n));
      }

      // Calculate y-range
      const allVals = [...terms, seq.limit];
      let minY = Math.min(...allVals);
      let maxY = Math.max(...allVals);
      const margin = Math.max((maxY - minY) * 0.2, currentEps * 2);
      minY -= margin;
      maxY += margin;

      const toScreenX = (n) => padding.left + ((n - 1) / (maxN - 1)) * plotWidth;
      const toScreenY = (v) => padding.top + ((maxY - v) / (maxY - minY)) * plotHeight;

      const N = seq.modulus(currentEps);
      const limitY = toScreenY(seq.limit);

      // ε-band
      ctx.fillStyle = 'rgba(16, 185, 129, 0.15)';
      const bandTop = toScreenY(seq.limit + currentEps);
      const bandBottom = toScreenY(seq.limit - currentEps);
      ctx.fillRect(padding.left, bandTop, plotWidth, bandBottom - bandTop);

      // Band edges
      ctx.strokeStyle = 'rgba(16, 185, 129, 0.5)';
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(padding.left, bandTop);
      ctx.lineTo(width - padding.right, bandTop);
      ctx.moveTo(padding.left, bandBottom);
      ctx.lineTo(width - padding.right, bandBottom);
      ctx.stroke();
      ctx.setLineDash([]);

      // Modulus threshold line
      if (N <= maxN) {
        const thresholdX = toScreenX(N);
        ctx.strokeStyle = var(--modulus-function);
        ctx.lineWidth = 2;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(thresholdX, padding.top);
        ctx.lineTo(thresholdX, height - padding.bottom);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = '#F59E0B';
        ctx.font = 'bold 12px "JetBrains Mono"';
        ctx.textAlign = 'center';
        ctx.fillText(`N=${N}`, thresholdX, padding.top - 8);
      }

      // Limit line
      ctx.strokeStyle = '#EC4899';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(padding.left, limitY);
      ctx.lineTo(width - padding.right, limitY);
      ctx.stroke();

      // Draw terms
      terms.forEach((val, i) => {
        const n = i + 1;
        const x = toScreenX(n);
        const y = toScreenY(val);
        
        const inBand = Math.abs(val - seq.limit) < currentEps;
        const pastThreshold = n >= N;

        ctx.fillStyle = pastThreshold ? '#10B981' : '#2563EB';
        ctx.beginPath();
        ctx.arc(x, y, pastThreshold ? 6 : 5, 0, Math.PI * 2);
        ctx.fill();
      });

      // Labels
      ctx.fillStyle = '#666';
      ctx.font = '11px "JetBrains Mono"';
      ctx.textAlign = 'center';
      for (let n = 1; n <= maxN; n += 3) {
        ctx.fillText(n.toString(), toScreenX(n), height - padding.bottom + 18);
      }

      ctx.fillStyle = '#EC4899';
      ctx.textAlign = 'right';
      ctx.fillText(`L = ${seq.limit.toFixed(4)}`, padding.left - 8, limitY + 4);

      // Update displays
      modulusOutput.textContent = `N = ${N}`;
      modulusMeaning.textContent = `For n ≥ ${N}, |xₙ - L| < ${currentEps.toFixed(4)}`;
    }

    epsilonSlider.addEventListener('input', () => {
      currentEps = Math.pow(10, parseFloat(epsilonSlider.value));
      epsilonValue.textContent = currentEps.toFixed(4);
      drawConvergence();
    });

    document.querySelectorAll('.seq-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.seq-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentSeq = btn.dataset.seq;
        drawConvergence();
      });
    });

    // ============================================
    // CAUCHY PROOF STEPS
    // ============================================
    
    document.querySelectorAll('.proof-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.proof-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.proof-step').forEach(s => s.classList.remove('active'));
        
        tab.classList.add('active');
        const step = tab.dataset.step;
        document.querySelector(`.proof-step[data-content="${step}"]`).classList.add('active');
        
        drawCauchyStep(step);
      });
    });

    function drawCauchyStep(step) {
      let canvas;
      if (step === 'cauchy') canvas = document.getElementById('cauchyCanvas');
      else if (step === 'forward') canvas = document.getElementById('cauchyCanvas2');
      else canvas = document.getElementById('cauchyCanvas3');

      const { ctx, width, height } = setupCanvas(canvas);

      ctx.fillStyle = '#0A0A0F';
      ctx.fillRect(0, 0, width, height);

      const padding = { left: 40, right: 20, top: 30, bottom: 40 };
      const plotWidth = width - padding.left - padding.right;
      const plotHeight = height - padding.top - padding.bottom;

      // Generate a Cauchy sequence
      const terms = [];
      for (let n = 1; n <= 15; n++) {
        let x = 1;
        for (let i = 0; i < n; i++) x = (x + 2/x) / 2;
        terms.push(x);
      }
      const limit = Math.sqrt(2);

      const toScreenX = (n) => padding.left + ((n - 1) / 14) * plotWidth;
      const toScreenY = (v) => padding.top + ((1.6 - v) / 0.4) * plotHeight;

      if (step === 'cauchy') {
        // Show terms clustering together
        const M = 5; // Cauchy threshold
        
        // Highlight the Cauchy region
        ctx.fillStyle = 'rgba(139, 92, 246, 0.1)';
        ctx.fillRect(toScreenX(M), padding.top, plotWidth - toScreenX(M) + padding.left, plotHeight);

        ctx.strokeStyle = 'rgba(139, 92, 246, 0.5)';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(toScreenX(M), padding.top);
        ctx.lineTo(toScreenX(M), height - padding.bottom);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw terms
      terms.forEach((val, i) => {
        const x = toScreenX(i + 1);
        const y = toScreenY(val);
        
        ctx.fillStyle = step === 'backward' ? '#10B981' : '#8B5CF6';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();
      });

      if (step === 'forward' || step === 'backward') {
        // Show limit
        ctx.strokeStyle = '#EC4899';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(padding.left, toScreenY(limit));
        ctx.lineTo(width - padding.right, toScreenY(limit));
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = '#EC4899';
        ctx.font = '11px "JetBrains Mono"';
        ctx.textAlign = 'right';
        ctx.fillText('L', padding.left - 5, toScreenY(limit) + 4);
      }

      // Axis labels
      ctx.fillStyle = '#666';
      ctx.font = '10px "JetBrains Mono"';
      ctx.textAlign = 'center';
      for (let n = 1; n <= 15; n += 2) {
        ctx.fillText(n.toString(), toScreenX(n), height - padding.bottom + 15);
      }
    }

    // ============================================
    // SERIES VISUALIZATION
    // ============================================
    
    const seriesCanvas = document.getElementById('seriesCanvas');
    const seriesFormula = document.getElementById('seriesFormula');
    const seriesStatus = document.getElementById('seriesStatus');
    const seriesSum = document.getElementById('seriesSum');
    const seriesTest = document.getElementById('seriesTest');

    const seriesData = {
      geometric: {
        formula: 'Σ 2⁻ⁿ',
        converges: true,
        sum: '= 1',
        test: 'Ratio test (r = ½)',
        generate: (n) => Math.pow(2, -n),
        partial: (n) => 1 - Math.pow(2, -n)
      },
      harmonic: {
        formula: 'Σ 1/n',
        converges: false,
        sum: '→ ∞',
        test: 'Comparison (diverges)',
        generate: (n) => 1/n,
        partial: (n) => {
          let sum = 0;
          for (let k = 1; k <= n; k++) sum += 1/k;
          return sum;
        }
      },
      alternating: {
        formula: 'Σ (-1)ⁿ/n',
        converges: true,
        sum: '= -ln 2',
        test: 'Alternating series test',
        generate: (n) => Math.pow(-1, n) / n,
        partial: (n) => {
          let sum = 0;
          for (let k = 1; k <= n; k++) sum += Math.pow(-1, k) / k;
          return sum;
        }
      },
      pseries: {
        formula: 'Σ 1/n²',
        converges: true,
        sum: '= π²/6',
        test: 'p-series (p = 2 > 1)',
        generate: (n) => 1/(n*n),
        partial: (n) => {
          let sum = 0;
          for (let k = 1; k <= n; k++) sum += 1/(k*k);
          return sum;
        }
      }
    };

    let currentSeries = 'geometric';

    function drawSeries() {
      const { ctx, width, height } = setupCanvas(seriesCanvas);
      const data = seriesData[currentSeries];

      ctx.fillStyle = '#FAFAFA';
      ctx.fillRect(0, 0, width, height);

      const padding = { left: 50, right: 20, top: 20, bottom: 40 };
      const plotWidth = width - padding.left - padding.right;
      const plotHeight = height - padding.top - padding.bottom;

      const maxN = 20;
      const partials = [];
      for (let n = 1; n <= maxN; n++) {
        partials.push(data.partial(n));
      }

      const minY = Math.min(...partials, 0);
      const maxY = Math.max(...partials);
      const yMargin = (maxY - minY) * 0.1 || 0.5;

      const toScreenX = (n) => padding.left + ((n - 1) / (maxN - 1)) * plotWidth;
      const toScreenY = (v) => padding.top + ((maxY + yMargin - v) / (maxY - minY + 2 * yMargin)) * plotHeight;

      // Draw zero line if visible
      if (minY < 0 && maxY > 0) {
        ctx.strokeStyle = '#CCC';
        ctx.beginPath();
        ctx.moveTo(padding.left, toScreenY(0));
        ctx.lineTo(width - padding.right, toScreenY(0));
        ctx.stroke();
      }

      // Draw limit if converges
      if (data.converges) {
        const limitVal = partials[partials.length - 1];
        ctx.strokeStyle = '#EC4899';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(padding.left, toScreenY(limitVal));
        ctx.lineTo(width - padding.right, toScreenY(limitVal));
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw partial sums
      ctx.strokeStyle = data.converges ? '#10B981' : '#EF4444';
      ctx.lineWidth = 2;
      ctx.beginPath();
      partials.forEach((val, i) => {
        const x = toScreenX(i + 1);
        const y = toScreenY(val);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // Draw points
      ctx.fillStyle = data.converges ? '#10B981' : '#EF4444';
      partials.forEach((val, i) => {
        ctx.beginPath();
        ctx.arc(toScreenX(i + 1), toScreenY(val), 4, 0, Math.PI * 2);
        ctx.fill();
      });

      // Labels
      ctx.fillStyle = '#666';
      ctx.font = '10px "JetBrains Mono"';
      ctx.textAlign = 'center';
      for (let n = 1; n <= maxN; n += 3) {
        ctx.fillText(n.toString(), toScreenX(n), height - padding.bottom + 15);
      }

      // Update info
      seriesFormula.textContent = data.formula;
      seriesStatus.textContent = data.converges ? 'Converges' : 'Diverges';
      seriesStatus.className = 'info-value ' + (data.converges ? 'converges' : 'diverges');
      seriesSum.textContent = data.sum;
      seriesTest.textContent = data.test;
    }

    document.querySelectorAll('.series-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.series-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentSeries = btn.dataset.series;
        drawSeries();
      });
    });

    // ============================================
    // INITIALIZE
    // ============================================
    
    drawConvergence();
    drawCauchyStep('cauchy');
    drawSeries();

    window.addEventListener('resize', () => {
      drawConvergence();
      const activeStep = document.querySelector('.proof-tab.active').dataset.step;
      drawCauchyStep(activeStep);
      drawSeries();
    });
  </script>
</body>
</html>
