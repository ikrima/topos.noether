<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Regular Sequence Machine — Constructive Analysis Chapter 2</title>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Source+Sans+Pro:wght@300;400;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --constructive-primary: #2D5A4A;
      --constructive-glow: #4A9D7C;
      --regular-sequence: #2563EB;
      --limit-point: #EC4899;
      --modulus-function: #F59E0B;
      --convergence-band: #10B981;
      --divergence: #EF4444;
      --fog-light: #9CA3AF;
      --background: #FAF8F5;
      --background-dark: #0F0F12;
      --ink: #1A1A1A;
      --ink-light: #FAF8F5;
      
      --display: 'Crimson Text', serif;
      --body: 'Source Sans Pro', sans-serif;
      --mono: 'JetBrains Mono', monospace;
      
      --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: var(--body);
      background: var(--background);
      color: var(--ink);
      line-height: 1.7;
      overflow-x: hidden;
    }

    /* ============================================
       OPENING
       ============================================ */
    
    .opening {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      background: linear-gradient(180deg, var(--regular-sequence) 0%, #1E3A5F 100%);
      color: var(--ink-light);
      position: relative;
      overflow: hidden;
    }

    .opening::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 30% 40%, rgba(236, 72, 153, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 70% 60%, rgba(16, 185, 129, 0.1) 0%, transparent 40%);
      pointer-events: none;
    }

    .opening-content {
      text-align: center;
      max-width: 800px;
      position: relative;
      z-index: 1;
    }

    .chapter-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.7);
      margin-bottom: 0.5rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.2s forwards;
    }

    .section-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--convergence-band);
      margin-bottom: 1rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.3s forwards;
    }

    .main-title {
      font-family: var(--display);
      font-size: clamp(2rem, 6vw, 3.5rem);
      font-weight: 400;
      line-height: 1.2;
      margin-bottom: 1.5rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.4s forwards;
    }

    .subtitle {
      font-size: 1.15rem;
      color: rgba(255, 255, 255, 0.85);
      max-width: 600px;
      margin: 0 auto;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.6s forwards;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* ============================================
       NARRATIVE SECTIONS
       ============================================ */

    .narrative-section {
      min-height: 60vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4rem 2rem;
    }

    .narrative-section.dark {
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .narrative-content {
      max-width: 650px;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.8s var(--ease-out-expo), transform 0.8s var(--ease-out-expo);
    }

    .narrative-content.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .narrative-content p {
      font-size: 1.2rem;
      margin-bottom: 1.5rem;
    }

    .math-display {
      font-family: var(--mono);
      font-size: 1.1rem;
      background: rgba(37, 99, 235, 0.1);
      padding: 1.5rem;
      border-radius: 8px;
      text-align: center;
      margin: 1.5rem 0;
      border-left: 3px solid var(--regular-sequence);
    }

    .dark .math-display {
      background: rgba(37, 99, 235, 0.15);
    }

    .quote-block {
      border-left: 3px solid var(--limit-point);
      padding-left: 1.5rem;
      margin: 2rem 0;
      font-family: var(--display);
      font-style: italic;
      font-size: 1.25rem;
    }

    /* ============================================
       REGULARITY VISUALIZER
       ============================================ */

    .regularity-section {
      min-height: 100vh;
      padding: 4rem 2rem;
      background: linear-gradient(180deg, #F5F3F0 0%, var(--background) 100%);
    }

    .section-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .section-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .section-subtitle {
      color: #666;
      font-size: 1rem;
      max-width: 600px;
      margin: 0 auto;
    }

    .visualizer-container {
      max-width: 1100px;
      margin: 0 auto;
    }

    .sequence-selector {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    .seq-btn {
      padding: 0.7rem 1.2rem;
      border: 2px solid #E0E0E0;
      border-radius: 8px;
      background: white;
      font-family: var(--mono);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .seq-btn:hover {
      border-color: var(--regular-sequence);
    }

    .seq-btn.active {
      border-color: var(--regular-sequence);
      background: var(--regular-sequence);
      color: white;
    }

    .visualizer-panel {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.08);
      overflow: hidden;
    }

    .visualizer-header {
      background: var(--regular-sequence);
      color: white;
      padding: 1rem 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .sequence-name {
      font-family: var(--display);
      font-size: 1.2rem;
    }

    .sequence-formula {
      font-family: var(--mono);
      font-size: 0.85rem;
      opacity: 0.9;
    }

    .visualizer-body {
      padding: 2rem;
    }

    .canvas-container {
      position: relative;
      height: 350px;
      margin-bottom: 2rem;
      background: #FAFAFA;
      border-radius: 8px;
    }

    #regularityCanvas {
      width: 100%;
      height: 100%;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1.5rem;
    }

    .control-card {
      background: #FAFAFA;
      padding: 1.5rem;
      border-radius: 12px;
    }

    .control-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--fog-light);
      margin-bottom: 0.8rem;
      display: block;
    }

    .slider-row {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .control-slider {
      flex: 1;
      height: 8px;
      -webkit-appearance: none;
      background: #E0E0E0;
      border-radius: 4px;
      outline: none;
    }

    .control-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: var(--regular-sequence);
      border-radius: 50%;
      cursor: pointer;
    }

    .control-value {
      font-family: var(--mono);
      font-size: 1rem;
      color: var(--regular-sequence);
      min-width: 60px;
      text-align: right;
    }

    .bound-display {
      background: white;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      border: 2px solid #E8E8E8;
    }

    .bound-formula {
      font-family: var(--mono);
      font-size: 0.9rem;
      color: #666;
      margin-bottom: 0.5rem;
    }

    .bound-value {
      font-family: var(--mono);
      font-size: 1.5rem;
      color: var(--convergence-band);
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.8rem 1rem;
      border-radius: 8px;
      font-family: var(--mono);
      font-size: 0.85rem;
    }

    .status-indicator.valid {
      background: rgba(16, 185, 129, 0.1);
      color: var(--convergence-band);
    }

    .status-indicator.invalid {
      background: rgba(239, 68, 68, 0.1);
      color: var(--divergence);
    }

    .status-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .status-indicator.valid .status-dot {
      background: var(--convergence-band);
    }

    .status-indicator.invalid .status-dot {
      background: var(--divergence);
    }

    /* ============================================
       EQUALITY VISUALIZATION
       ============================================ */

    .equality-section {
      min-height: 100vh;
      padding: 4rem 2rem;
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .equality-container {
      max-width: 1000px;
      margin: 0 auto;
    }

    .equality-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .equality-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .equality-subtitle {
      color: var(--fog-light);
      font-size: 1rem;
    }

    .equality-panel {
      background: rgba(30, 30, 40, 0.5);
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 16px;
      padding: 2rem;
    }

    .equality-canvas-container {
      height: 300px;
      margin-bottom: 1.5rem;
    }

    #equalityCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #0A0A0F;
    }

    .equality-controls {
      display: flex;
      justify-content: center;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .equality-btn {
      padding: 0.7rem 1.2rem;
      border: 2px solid var(--fog-light);
      border-radius: 8px;
      background: transparent;
      color: var(--fog-light);
      font-family: var(--mono);
      font-size: 0.8rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .equality-btn:hover {
      border-color: var(--limit-point);
      color: var(--limit-point);
    }

    .equality-btn.active {
      border-color: var(--limit-point);
      background: var(--limit-point);
      color: white;
    }

    .equality-result {
      text-align: center;
      margin-top: 1.5rem;
      padding: 1rem;
      border-radius: 8px;
      font-family: var(--mono);
      font-size: 0.9rem;
    }

    .equality-result.equal {
      background: rgba(16, 185, 129, 0.15);
      color: var(--convergence-band);
    }

    .equality-result.different {
      background: rgba(239, 68, 68, 0.15);
      color: var(--divergence);
    }

    /* ============================================
       THE FUNNEL VISUALIZATION
       ============================================ */

    .funnel-section {
      padding: 4rem 2rem;
      background: linear-gradient(180deg, var(--background) 0%, #F0EDE8 100%);
    }

    .funnel-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .funnel-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .funnel-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .funnel-subtitle {
      color: #666;
      font-size: 1rem;
    }

    .funnel-panel {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.08);
      padding: 2rem;
    }

    .funnel-canvas-container {
      height: 400px;
      margin-bottom: 1.5rem;
    }

    #funnelCanvas {
      width: 100%;
      height: 100%;
    }

    .funnel-explanation {
      text-align: center;
      color: #666;
      font-size: 0.95rem;
      max-width: 600px;
      margin: 0 auto;
    }

    /* ============================================
       TERMS TABLE
       ============================================ */

    .terms-section {
      padding: 4rem 2rem;
      background: var(--background);
    }

    .terms-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .terms-header {
      text-align: center;
      margin-bottom: 2rem;
    }

    .terms-title {
      font-family: var(--display);
      font-size: 1.8rem;
      margin-bottom: 0.5rem;
    }

    .terms-table-wrapper {
      overflow-x: auto;
    }

    .terms-table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    }

    .terms-table th,
    .terms-table td {
      padding: 1rem;
      text-align: center;
      border-bottom: 1px solid #E8E4DC;
    }

    .terms-table th {
      background: #F5F3F0;
      font-family: var(--mono);
      font-size: 0.75rem;
      letter-spacing: 0.05em;
      color: var(--fog-light);
    }

    .terms-table td {
      font-family: var(--mono);
      font-size: 0.85rem;
    }

    .terms-table tr:last-child td {
      border-bottom: none;
    }

    .terms-table .index-col {
      color: var(--fog-light);
    }

    .terms-table .value-col {
      color: var(--regular-sequence);
    }

    .terms-table .bound-col {
      color: var(--convergence-band);
    }

    .terms-table .error-col {
      color: var(--limit-point);
    }

    /* ============================================
       NAVIGATION
       ============================================ */

    .next-section {
      padding: 4rem 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, var(--regular-sequence) 0%, #1E3A5F 100%);
      color: var(--ink-light);
      text-align: center;
    }

    .next-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.7);
      margin-bottom: 1rem;
    }

    .next-title {
      font-family: var(--display);
      font-size: 1.6rem;
      margin-bottom: 0.5rem;
    }

    .next-description {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.8);
      max-width: 500px;
    }

    /* ============================================
       RESPONSIVE
       ============================================ */

    @media (max-width: 768px) {
      .controls-grid {
        grid-template-columns: 1fr;
      }

      .visualizer-header {
        flex-direction: column;
        text-align: center;
      }
    }
  </style>
</head>
<body>

  <!-- Opening -->
  <section class="opening">
    <div class="opening-content">
      <p class="chapter-label">Chapter 2: Calculus and the Real Numbers</p>
      <p class="section-label">Section 2: The Real Number System</p>
      <h1 class="main-title">The Regular Sequence Machine</h1>
      <p class="subtitle">A real number is not a mystical point on a line—it's an algorithm that produces rational approximations with guaranteed convergence.</p>
    </div>
  </section>

  <!-- Narrative: Introduction -->
  <section class="narrative-section">
    <div class="narrative-content" data-animate>
      <p>In classical mathematics, real numbers simply "exist"—points on a number line, limits of Cauchy sequences. But constructively, we must ask: <em>how do we actually build a real number?</em></p>
      <p>Bishop's answer is elegant: a real number is a <strong>regular sequence</strong> of rationals. Not just any Cauchy sequence—one with a specific convergence guarantee built into its definition.</p>
    </div>
  </section>

  <!-- Narrative: The Definition -->
  <section class="narrative-section">
    <div class="narrative-content" data-animate>
      <p>Here is the fundamental definition:</p>
      <div class="math-display">
        A sequence (xₙ) of rationals is <strong>regular</strong> if<br><br>
        |x_m − x_n| < m⁻¹ + n⁻¹ for all m, n ∈ ℤ⁺
      </div>
      <p>This is stronger than Cauchy. It doesn't just say "terms get close eventually"—it gives an <em>explicit bound</em> on how close terms must be, depending only on their indices.</p>
      <p>A real number is a regular sequence. Two reals x = (xₙ) and y = (yₙ) are equal if |xₙ − yₙ| < 2n⁻¹ for all n.</p>
    </div>
  </section>

  <!-- Regularity Visualizer -->
  <section class="regularity-section">
    <div class="section-header">
      <h2 class="section-title">Watch Regularity in Action</h2>
      <p class="section-subtitle">Select a sequence and see how the regularity condition controls convergence</p>
    </div>

    <div class="visualizer-container">
      <div class="sequence-selector">
        <button class="seq-btn active" data-sequence="sqrt2">√2</button>
        <button class="seq-btn" data-sequence="pi">π</button>
        <button class="seq-btn" data-sequence="e">e</button>
        <button class="seq-btn" data-sequence="golden">φ</button>
        <button class="seq-btn" data-sequence="ln2">ln 2</button>
      </div>

      <div class="visualizer-panel">
        <div class="visualizer-header">
          <span class="sequence-name" id="seqName">√2 via Newton-Raphson</span>
          <span class="sequence-formula" id="seqFormula">xₙ₊₁ = (xₙ + 2/xₙ) / 2</span>
        </div>

        <div class="visualizer-body">
          <div class="canvas-container">
            <canvas id="regularityCanvas"></canvas>
          </div>

          <div class="controls-grid">
            <div class="control-card">
              <label class="control-label">Index m</label>
              <div class="slider-row">
                <input type="range" class="control-slider" id="mSlider" min="1" max="15" value="3">
                <span class="control-value" id="mValue">m = 3</span>
              </div>
            </div>

            <div class="control-card">
              <label class="control-label">Index n</label>
              <div class="slider-row">
                <input type="range" class="control-slider" id="nSlider" min="1" max="15" value="7">
                <span class="control-value" id="nValue">n = 7</span>
              </div>
            </div>

            <div class="control-card">
              <label class="control-label">Regularity Bound</label>
              <div class="bound-display">
                <p class="bound-formula">m⁻¹ + n⁻¹</p>
                <p class="bound-value" id="boundValue">0.476</p>
              </div>
            </div>

            <div class="control-card">
              <label class="control-label">Status</label>
              <div class="status-indicator valid" id="regularityStatus">
                <span class="status-dot"></span>
                <span class="status-text">|x_m − x_n| = 0.089 < 0.476 ✓</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- The Funnel -->
  <section class="funnel-section">
    <div class="funnel-container">
      <div class="funnel-header">
        <h2 class="funnel-title">The Regularity Funnel</h2>
        <p class="funnel-subtitle">As indices increase, the allowed deviation shrinks—terms are forced toward the limit</p>
      </div>

      <div class="funnel-panel">
        <div class="funnel-canvas-container">
          <canvas id="funnelCanvas"></canvas>
        </div>
        <p class="funnel-explanation">
          The funnel shows the bound m⁻¹ + n⁻¹ shrinking as m and n grow. Every regular sequence must keep its terms within this funnel. The narrowing is what guarantees convergence—there's no escape.
        </p>
      </div>
    </div>
  </section>

  <!-- Equality Visualization -->
  <section class="equality-section">
    <div class="equality-container">
      <div class="equality-header">
        <h2 class="equality-title">When Are Two Reals Equal?</h2>
        <p class="equality-subtitle">x = y when |xₙ − yₙ| < 2n⁻¹ for all n</p>
      </div>

      <div class="equality-panel">
        <div class="equality-canvas-container">
          <canvas id="equalityCanvas"></canvas>
        </div>

        <div class="equality-controls">
          <button class="equality-btn active" data-pair="same">Same limit (√2 twice)</button>
          <button class="equality-btn" data-pair="different">Different limits (√2 vs √3)</button>
          <button class="equality-btn" data-pair="subtle">Subtle difference</button>
        </div>

        <div class="equality-result equal" id="equalityResult">
          These sequences represent the same real number: their terms stay within 2n⁻¹ of each other.
        </div>
      </div>
    </div>
  </section>

  <!-- Terms Table -->
  <section class="terms-section">
    <div class="terms-container">
      <div class="terms-header">
        <h2 class="terms-title">The Rational Approximations</h2>
      </div>

      <div class="terms-table-wrapper">
        <table class="terms-table" id="termsTable">
          <thead>
            <tr>
              <th>n</th>
              <th>xₙ (rational approx)</th>
              <th>Bound: 2/n</th>
              <th>|xₙ − limit|</th>
              <th>Within bound?</th>
            </tr>
          </thead>
          <tbody id="termsBody">
            <!-- Generated by JavaScript -->
          </tbody>
        </table>
      </div>
    </div>
  </section>

  <!-- Narrative: Insight -->
  <section class="narrative-section dark">
    <div class="narrative-content" data-animate>
      <p>The regularity condition is not arbitrary. It encodes the <em>rate of convergence</em> directly into the definition of a real number.</p>
      <p>By term n, you're guaranteed to be within 2/n of the limit. Need 6 decimal places of accuracy? Compute x₁₀₀₀₀₀₀. The bound tells you exactly how far to go.</p>
      <div class="quote-block">
        "The rational number xₙ is called the n-th rational approximation to the real number x = (xₙ)."
        <br><span style="font-size: 0.85rem; color: rgba(255,255,255,0.6); font-style: normal;">— Bishop & Bridges</span>
      </div>
    </div>
  </section>

  <!-- Navigation -->
  <section class="next-section">
    <p class="next-label">Coming Next</p>
    <h3 class="next-title">The Order Relations & The Undecidable Gap</h3>
    <p class="next-description">Why x ≤ y does not imply (x < y or x = y)—and what this means for constructive mathematics.</p>
  </section>

  <script>
    // ============================================
    // SCROLL ANIMATIONS
    // ============================================
    
    const observerOptions = { threshold: 0.3, rootMargin: '0px 0px -10% 0px' };
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) entry.target.classList.add('visible');
      });
    }, observerOptions);

    document.querySelectorAll('[data-animate], .narrative-content').forEach(el => observer.observe(el));

    // ============================================
    // SEQUENCE DEFINITIONS
    // ============================================
    
    const sequences = {
      sqrt2: {
        name: '√2 via Newton-Raphson',
        formula: 'xₙ₊₁ = (xₙ + 2/xₙ) / 2',
        limit: Math.sqrt(2),
        generate: (n) => {
          let x = 1;
          for (let i = 0; i < n + 2; i++) {
            x = (x + 2/x) / 2;
          }
          return x;
        }
      },
      pi: {
        name: 'π via Machin\'s Formula',
        formula: 'π = 4(4·arctan(1/5) − arctan(1/239))',
        limit: Math.PI,
        generate: (n) => {
          // Use partial sums of arctan series
          const arctan = (x, terms) => {
            let sum = 0;
            for (let k = 0; k < terms; k++) {
              sum += Math.pow(-1, k) * Math.pow(x, 2*k + 1) / (2*k + 1);
            }
            return sum;
          };
          return 4 * (4 * arctan(1/5, n * 3) - arctan(1/239, n * 2));
        }
      },
      e: {
        name: 'e via Factorial Series',
        formula: 'e = Σ 1/n!',
        limit: Math.E,
        generate: (n) => {
          let sum = 0;
          let factorial = 1;
          for (let k = 0; k <= n + 5; k++) {
            if (k > 0) factorial *= k;
            sum += 1 / factorial;
          }
          return sum;
        }
      },
      golden: {
        name: 'φ via Fibonacci Ratios',
        formula: 'φ = lim Fₙ₊₁/Fₙ',
        limit: (1 + Math.sqrt(5)) / 2,
        generate: (n) => {
          let a = 1, b = 1;
          for (let i = 0; i < n + 3; i++) {
            [a, b] = [b, a + b];
          }
          return b / a;
        }
      },
      ln2: {
        name: 'ln 2 via Alternating Series',
        formula: 'ln 2 = 1 − 1/2 + 1/3 − 1/4 + ...',
        limit: Math.LN2,
        generate: (n) => {
          let sum = 0;
          for (let k = 1; k <= (n + 1) * 50; k++) {
            sum += Math.pow(-1, k + 1) / k;
          }
          return sum;
        }
      }
    };

    let currentSequence = 'sqrt2';

    // ============================================
    // CANVAS UTILITIES
    // ============================================
    
    function setupCanvas(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      return { ctx, width: rect.width, height: rect.height };
    }

    // ============================================
    // REGULARITY VISUALIZER
    // ============================================
    
    const regularityCanvas = document.getElementById('regularityCanvas');
    const mSlider = document.getElementById('mSlider');
    const nSlider = document.getElementById('nSlider');
    const mValueEl = document.getElementById('mValue');
    const nValueEl = document.getElementById('nValue');
    const boundValueEl = document.getElementById('boundValue');
    const regularityStatus = document.getElementById('regularityStatus');
    const seqNameEl = document.getElementById('seqName');
    const seqFormulaEl = document.getElementById('seqFormula');

    function drawRegularity() {
      const { ctx, width, height } = setupCanvas(regularityCanvas);
      const seq = sequences[currentSequence];
      const limit = seq.limit;
      
      const m = parseInt(mSlider.value);
      const n = parseInt(nSlider.value);
      
      // Generate terms
      const terms = [];
      for (let i = 1; i <= 15; i++) {
        terms.push(seq.generate(i));
      }

      const padding = { left: 50, right: 30, top: 30, bottom: 50 };
      const plotWidth = width - padding.left - padding.right;
      const plotHeight = height - padding.top - padding.bottom;

      // Clear
      ctx.fillStyle = '#FAFAFA';
      ctx.fillRect(0, 0, width, height);

      // Calculate y-range
      const allVals = [...terms, limit];
      let minY = Math.min(...allVals);
      let maxY = Math.max(...allVals);
      const yMargin = (maxY - minY) * 0.2 || 0.1;
      minY -= yMargin;
      maxY += yMargin;

      const toScreenX = (i) => padding.left + ((i - 1) / 14) * plotWidth;
      const toScreenY = (v) => padding.top + ((maxY - v) / (maxY - minY)) * plotHeight;

      // Grid
      ctx.strokeStyle = '#E8E8E8';
      ctx.lineWidth = 1;
      for (let i = 1; i <= 15; i++) {
        const x = toScreenX(i);
        ctx.beginPath();
        ctx.moveTo(x, padding.top);
        ctx.lineTo(x, height - padding.bottom);
        ctx.stroke();
      }

      // Limit line
      const limitY = toScreenY(limit);
      ctx.strokeStyle = '#EC4899';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(padding.left, limitY);
      ctx.lineTo(width - padding.right, limitY);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw bound band for m and n
      const xm = seq.generate(m);
      const xn = seq.generate(n);
      const bound = 1/m + 1/n;
      
      ctx.fillStyle = 'rgba(16, 185, 129, 0.15)';
      const bandTop = toScreenY(Math.max(xm, xn) + bound/2);
      const bandBottom = toScreenY(Math.min(xm, xn) - bound/2);
      ctx.fillRect(padding.left, bandTop, plotWidth, bandBottom - bandTop);

      // Draw terms
      terms.forEach((val, i) => {
        const x = toScreenX(i + 1);
        const y = toScreenY(val);
        
        const isM = (i + 1) === m;
        const isN = (i + 1) === n;
        
        ctx.fillStyle = isM || isN ? '#2563EB' : 'rgba(37, 99, 235, 0.4)';
        ctx.beginPath();
        ctx.arc(x, y, isM || isN ? 8 : 5, 0, Math.PI * 2);
        ctx.fill();

        if (isM || isN) {
          ctx.fillStyle = '#2563EB';
          ctx.font = 'bold 12px "JetBrains Mono"';
          ctx.textAlign = 'center';
          ctx.fillText(isM ? 'm' : 'n', x, y - 15);
        }
      });

      // Draw connection line between m and n
      const xmScreen = toScreenX(m);
      const xnScreen = toScreenX(n);
      const ymScreen = toScreenY(xm);
      const ynScreen = toScreenY(xn);

      ctx.strokeStyle = 'rgba(37, 99, 235, 0.5)';
      ctx.lineWidth = 2;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(xmScreen, ymScreen);
      ctx.lineTo(xnScreen, ynScreen);
      ctx.stroke();
      ctx.setLineDash([]);

      // Axis labels
      ctx.fillStyle = '#666';
      ctx.font = '11px "JetBrains Mono"';
      ctx.textAlign = 'center';
      for (let i = 1; i <= 15; i += 2) {
        ctx.fillText(i.toString(), toScreenX(i), height - padding.bottom + 20);
      }

      ctx.fillStyle = '#EC4899';
      ctx.textAlign = 'right';
      ctx.fillText(`L = ${limit.toFixed(5)}`, width - padding.right, limitY - 8);

      // Update controls
      mValueEl.textContent = `m = ${m}`;
      nValueEl.textContent = `n = ${n}`;
      boundValueEl.textContent = bound.toFixed(4);

      const diff = Math.abs(xm - xn);
      const isRegular = diff < bound;
      
      regularityStatus.className = 'status-indicator ' + (isRegular ? 'valid' : 'invalid');
      regularityStatus.querySelector('.status-text').textContent = 
        `|x_m − x_n| = ${diff.toFixed(4)} ${isRegular ? '<' : '≥'} ${bound.toFixed(4)} ${isRegular ? '✓' : '✗'}`;
    }

    mSlider.addEventListener('input', drawRegularity);
    nSlider.addEventListener('input', drawRegularity);

    // Sequence selector
    document.querySelectorAll('.seq-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.seq-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentSequence = btn.dataset.sequence;
        
        const seq = sequences[currentSequence];
        seqNameEl.textContent = seq.name;
        seqFormulaEl.textContent = seq.formula;
        
        drawRegularity();
        drawFunnel();
        updateTermsTable();
      });
    });

    // ============================================
    // FUNNEL VISUALIZATION
    // ============================================
    
    const funnelCanvas = document.getElementById('funnelCanvas');

    function drawFunnel() {
      const { ctx, width, height } = setupCanvas(funnelCanvas);
      const seq = sequences[currentSequence];
      const limit = seq.limit;

      const padding = { left: 60, right: 30, top: 40, bottom: 50 };
      const plotWidth = width - padding.left - padding.right;
      const plotHeight = height - padding.top - padding.bottom;

      // Clear
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, width, height);

      const maxN = 20;
      const toScreenX = (n) => padding.left + ((n - 1) / (maxN - 1)) * plotWidth;
      
      // Calculate y scale based on deviation
      const maxDev = 2; // Maximum deviation to show
      const toScreenY = (dev) => padding.top + ((maxDev - dev) / (2 * maxDev)) * plotHeight;

      // Draw funnel shape
      ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
      ctx.beginPath();
      ctx.moveTo(toScreenX(1), toScreenY(2 / 1));
      
      for (let n = 1; n <= maxN; n++) {
        ctx.lineTo(toScreenX(n), toScreenY(2 / n));
      }
      for (let n = maxN; n >= 1; n--) {
        ctx.lineTo(toScreenX(n), toScreenY(-2 / n));
      }
      ctx.closePath();
      ctx.fill();

      // Draw funnel edges
      ctx.strokeStyle = 'rgba(16, 185, 129, 0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let n = 1; n <= maxN; n++) {
        const x = toScreenX(n);
        const y = toScreenY(2 / n);
        if (n === 1) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      ctx.beginPath();
      for (let n = 1; n <= maxN; n++) {
        const x = toScreenX(n);
        const y = toScreenY(-2 / n);
        if (n === 1) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Center line (limit)
      ctx.strokeStyle = '#EC4899';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      const centerY = toScreenY(0);
      ctx.beginPath();
      ctx.moveTo(padding.left, centerY);
      ctx.lineTo(width - padding.right, centerY);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw sequence points
      for (let n = 1; n <= Math.min(maxN, 15); n++) {
        const val = seq.generate(n);
        const dev = val - limit;
        const x = toScreenX(n);
        const y = toScreenY(dev);

        ctx.fillStyle = '#2563EB';
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      // Labels
      ctx.fillStyle = '#666';
      ctx.font = '11px "JetBrains Mono"';
      ctx.textAlign = 'center';
      
      for (let n = 1; n <= maxN; n += 3) {
        ctx.fillText(n.toString(), toScreenX(n), height - padding.bottom + 20);
      }
      ctx.fillText('n', width - padding.right + 15, height - padding.bottom + 20);

      ctx.textAlign = 'right';
      ctx.fillText('+2/n', padding.left - 10, toScreenY(0.5));
      ctx.fillText('0', padding.left - 10, centerY + 4);
      ctx.fillText('−2/n', padding.left - 10, toScreenY(-0.5));

      ctx.fillStyle = '#EC4899';
      ctx.fillText('limit', padding.left - 10, centerY - 10);
    }

    // ============================================
    // EQUALITY VISUALIZATION
    // ============================================
    
    const equalityCanvas = document.getElementById('equalityCanvas');
    const equalityResult = document.getElementById('equalityResult');
    let currentPair = 'same';

    const equalityPairs = {
      same: {
        name1: '√2 (Newton)',
        name2: '√2 (Halley)',
        seq1: (n) => {
          let x = 1;
          for (let i = 0; i < n + 2; i++) x = (x + 2/x) / 2;
          return x;
        },
        seq2: (n) => {
          // Slightly different starting point, same limit
          let x = 1.5;
          for (let i = 0; i < n + 2; i++) x = (x + 2/x) / 2;
          return x;
        },
        limit1: Math.sqrt(2),
        limit2: Math.sqrt(2),
        equal: true
      },
      different: {
        name1: '√2',
        name2: '√3',
        seq1: (n) => {
          let x = 1;
          for (let i = 0; i < n + 2; i++) x = (x + 2/x) / 2;
          return x;
        },
        seq2: (n) => {
          let x = 1.5;
          for (let i = 0; i < n + 2; i++) x = (x + 3/x) / 2;
          return x;
        },
        limit1: Math.sqrt(2),
        limit2: Math.sqrt(3),
        equal: false
      },
      subtle: {
        name1: 'e',
        name2: 'e + 10⁻⁶',
        seq1: (n) => {
          let sum = 0, fact = 1;
          for (let k = 0; k <= n + 5; k++) {
            if (k > 0) fact *= k;
            sum += 1 / fact;
          }
          return sum;
        },
        seq2: (n) => {
          let sum = 0.000001, fact = 1;
          for (let k = 0; k <= n + 5; k++) {
            if (k > 0) fact *= k;
            sum += 1 / fact;
          }
          return sum;
        },
        limit1: Math.E,
        limit2: Math.E + 0.000001,
        equal: false
      }
    };

    function drawEquality() {
      const { ctx, width, height } = setupCanvas(equalityCanvas);
      const pair = equalityPairs[currentPair];

      const padding = { left: 50, right: 30, top: 30, bottom: 50 };
      const plotWidth = width - padding.left - padding.right;
      const plotHeight = height - padding.top - padding.bottom;

      ctx.fillStyle = '#0A0A0F';
      ctx.fillRect(0, 0, width, height);

      const maxN = 12;
      const toScreenX = (n) => padding.left + ((n - 1) / (maxN - 1)) * plotWidth;

      // Generate terms
      const terms1 = [], terms2 = [];
      for (let n = 1; n <= maxN; n++) {
        terms1.push(pair.seq1(n));
        terms2.push(pair.seq2(n));
      }

      // Calculate y-range
      const allVals = [...terms1, ...terms2, pair.limit1, pair.limit2];
      let minY = Math.min(...allVals);
      let maxY = Math.max(...allVals);
      const yMargin = (maxY - minY) * 0.15 || 0.01;
      minY -= yMargin;
      maxY += yMargin;

      const toScreenY = (v) => padding.top + ((maxY - v) / (maxY - minY)) * plotHeight;

      // Draw 2/n band
      ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
      for (let n = 1; n <= maxN; n++) {
        const x = toScreenX(n);
        const avgVal = (terms1[n-1] + terms2[n-1]) / 2;
        const bandHalf = 1 / n;
        ctx.fillRect(x - 10, toScreenY(avgVal + bandHalf), 20, toScreenY(avgVal - bandHalf) - toScreenY(avgVal + bandHalf));
      }

      // Draw limit lines
      ctx.strokeStyle = 'rgba(236, 72, 153, 0.5)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(padding.left, toScreenY(pair.limit1));
      ctx.lineTo(width - padding.right, toScreenY(pair.limit1));
      ctx.stroke();
      
      if (Math.abs(pair.limit1 - pair.limit2) > 0.0001) {
        ctx.beginPath();
        ctx.moveTo(padding.left, toScreenY(pair.limit2));
        ctx.lineTo(width - padding.right, toScreenY(pair.limit2));
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // Draw sequence 1
      ctx.fillStyle = '#2563EB';
      terms1.forEach((val, i) => {
        ctx.beginPath();
        ctx.arc(toScreenX(i + 1), toScreenY(val), 5, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw sequence 2
      ctx.fillStyle = '#F59E0B';
      terms2.forEach((val, i) => {
        ctx.beginPath();
        ctx.arc(toScreenX(i + 1), toScreenY(val), 5, 0, Math.PI * 2);
        ctx.fill();
      });

      // Check equality condition for each n
      let allWithinBound = true;
      for (let n = 1; n <= maxN; n++) {
        const diff = Math.abs(terms1[n-1] - terms2[n-1]);
        const bound = 2 / n;
        if (diff >= bound) {
          allWithinBound = false;
          break;
        }
      }

      // Update result
      if (pair.equal) {
        equalityResult.className = 'equality-result equal';
        equalityResult.textContent = 'These sequences represent the same real number: their terms stay within 2n⁻¹ of each other.';
      } else {
        equalityResult.className = 'equality-result different';
        equalityResult.textContent = 'These sequences represent different real numbers: for large enough n, |xₙ − yₙ| exceeds 2n⁻¹.';
      }

      // Labels
      ctx.fillStyle = '#9CA3AF';
      ctx.font = '11px "JetBrains Mono"';
      ctx.textAlign = 'center';
      for (let n = 1; n <= maxN; n += 2) {
        ctx.fillText(n.toString(), toScreenX(n), height - padding.bottom + 20);
      }

      // Legend
      ctx.fillStyle = '#2563EB';
      ctx.fillRect(width - 120, 15, 10, 10);
      ctx.fillStyle = '#9CA3AF';
      ctx.textAlign = 'left';
      ctx.fillText(pair.name1, width - 105, 24);

      ctx.fillStyle = '#F59E0B';
      ctx.fillRect(width - 120, 32, 10, 10);
      ctx.fillStyle = '#9CA3AF';
      ctx.fillText(pair.name2, width - 105, 41);
    }

    document.querySelectorAll('.equality-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.equality-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentPair = btn.dataset.pair;
        drawEquality();
      });
    });

    // ============================================
    // TERMS TABLE
    // ============================================
    
    const termsBody = document.getElementById('termsBody');

    function updateTermsTable() {
      const seq = sequences[currentSequence];
      const limit = seq.limit;
      
      termsBody.innerHTML = '';
      
      for (let n = 1; n <= 10; n++) {
        const val = seq.generate(n);
        const bound = 2 / n;
        const error = Math.abs(val - limit);
        const withinBound = error < bound;
        
        const row = document.createElement('tr');
        row.innerHTML = `
          <td class="index-col">${n}</td>
          <td class="value-col">${val.toFixed(8)}</td>
          <td class="bound-col">${bound.toFixed(6)}</td>
          <td class="error-col">${error.toExponential(3)}</td>
          <td style="color: ${withinBound ? 'var(--convergence-band)' : 'var(--divergence)'}">
            ${withinBound ? '✓' : '✗'}
          </td>
        `;
        termsBody.appendChild(row);
      }
    }

    // ============================================
    // INITIALIZE
    // ============================================
    
    drawRegularity();
    drawFunnel();
    drawEquality();
    updateTermsTable();

    window.addEventListener('resize', () => {
      drawRegularity();
      drawFunnel();
      drawEquality();
    });
  </script>
</body>
</html>
