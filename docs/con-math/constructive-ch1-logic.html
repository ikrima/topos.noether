<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Constructive Logic — The Proof Factory</title>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Source+Sans+Pro:wght@300;400;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --constructive-primary: #2D5A4A;
      --constructive-glow: #4A9D7C;
      --classical-primary: #4A3C6D;
      --classical-secondary: #C9B037;
      --algorithm-accent: #E07B39;
      --undecidable-fog: #6B7280;
      --fog-light: #9CA3AF;
      --proof-valid: #059669;
      --proof-invalid: #DC2626;
      --and-color: #3B82F6;
      --or-color: #8B5CF6;
      --implies-color: #EC4899;
      --not-color: #F59E0B;
      --background: #FAF8F5;
      --background-dark: #0F0F12;
      --ink: #1A1A1A;
      --ink-light: #FAF8F5;
      
      --display: 'Crimson Text', serif;
      --body: 'Source Sans Pro', sans-serif;
      --mono: 'JetBrains Mono', monospace;
      
      --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: var(--body);
      background: var(--background);
      color: var(--ink);
      line-height: 1.7;
      overflow-x: hidden;
    }

    /* ============================================
       OPENING
       ============================================ */
    
    .opening {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      background: linear-gradient(180deg, #1A1A20 0%, #0F0F12 100%);
      color: var(--ink-light);
      position: relative;
      overflow: hidden;
    }

    .opening::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 30%, rgba(59, 130, 246, 0.08) 0%, transparent 40%),
        radial-gradient(circle at 80% 70%, rgba(139, 92, 246, 0.08) 0%, transparent 40%),
        radial-gradient(circle at 50% 50%, rgba(236, 72, 153, 0.05) 0%, transparent 50%);
      pointer-events: none;
    }

    .opening-content {
      text-align: center;
      max-width: 800px;
      position: relative;
      z-index: 1;
    }

    .section-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--fog-light);
      margin-bottom: 1rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.2s forwards;
    }

    .main-title {
      font-family: var(--display);
      font-size: clamp(2rem, 6vw, 3.5rem);
      font-weight: 400;
      line-height: 1.2;
      margin-bottom: 1.5rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.4s forwards;
    }

    .connective-symbols {
      display: flex;
      justify-content: center;
      gap: 2rem;
      margin-bottom: 2rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.6s forwards;
    }

    .symbol {
      font-family: var(--mono);
      font-size: 2rem;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.05);
    }

    .symbol.and { color: var(--and-color); }
    .symbol.or { color: var(--or-color); }
    .symbol.implies { color: var(--implies-color); }
    .symbol.not { color: var(--not-color); }

    .subtitle {
      font-size: 1.15rem;
      color: var(--fog-light);
      max-width: 600px;
      margin: 0 auto;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.8s forwards;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* ============================================
       NARRATIVE SECTIONS
       ============================================ */

    .narrative-section {
      min-height: 60vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4rem 2rem;
    }

    .narrative-section.dark {
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .narrative-content {
      max-width: 650px;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.8s var(--ease-out-expo), transform 0.8s var(--ease-out-expo);
    }

    .narrative-content.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .narrative-content p {
      font-size: 1.2rem;
      margin-bottom: 1.5rem;
    }

    .quote-block {
      border-left: 3px solid var(--constructive-primary);
      padding-left: 1.5rem;
      margin: 2rem 0;
      font-family: var(--display);
      font-style: italic;
      font-size: 1.25rem;
    }

    /* ============================================
       CONNECTIVE WORKSPACE
       ============================================ */

    .workspace-section {
      padding: 4rem 2rem;
      background: linear-gradient(180deg, #F5F3F0 0%, var(--background) 100%);
    }

    .workspace-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .workspace-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .workspace-subtitle {
      color: #666;
      font-size: 1rem;
    }

    .connective-tabs {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    .tab-btn {
      padding: 0.8rem 1.5rem;
      border: 2px solid #E0E0E0;
      border-radius: 8px;
      background: white;
      font-family: var(--mono);
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .tab-btn:hover {
      border-color: #CCC;
    }

    .tab-btn.active {
      border-color: currentColor;
      background: currentColor;
      color: white;
    }

    .tab-btn.active .tab-symbol {
      color: white;
    }

    .tab-btn[data-connective="and"] { color: var(--and-color); }
    .tab-btn[data-connective="or"] { color: var(--or-color); }
    .tab-btn[data-connective="implies"] { color: var(--implies-color); }
    .tab-btn[data-connective="not"] { color: var(--not-color); }

    .workspace-container {
      max-width: 1000px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.08);
      overflow: hidden;
    }

    .workspace-panel {
      display: none;
      padding: 2rem;
    }

    .workspace-panel.active {
      display: block;
    }

    .panel-grid {
      display: grid;
      grid-template-columns: 1fr 1.5fr;
      gap: 2rem;
      align-items: start;
    }

    @media (max-width: 800px) {
      .panel-grid {
        grid-template-columns: 1fr;
      }
    }

    .explanation-side {
      padding-right: 1rem;
    }

    .connective-name {
      font-family: var(--display);
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .connective-symbol {
      font-family: var(--mono);
      font-size: 1.8rem;
    }

    .classical-view, .constructive-view {
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 1rem;
    }

    .classical-view {
      background: rgba(74, 60, 109, 0.08);
      border-left: 3px solid var(--classical-primary);
    }

    .constructive-view {
      background: rgba(45, 90, 74, 0.08);
      border-left: 3px solid var(--constructive-primary);
    }

    .view-label {
      font-family: var(--mono);
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 0.5rem;
    }

    .classical-view .view-label { color: var(--classical-primary); }
    .constructive-view .view-label { color: var(--constructive-primary); }

    .view-text {
      font-size: 0.95rem;
      line-height: 1.6;
    }

    /* Interactive Side */
    .interactive-side {
      background: #FAFAFA;
      border-radius: 12px;
      padding: 1.5rem;
    }

    .machine-title {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--undecidable-fog);
      margin-bottom: 1rem;
      text-align: center;
    }

    /* ============================================
       AND MACHINE
       ============================================ */

    .and-machine {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .proof-inputs {
      display: flex;
      gap: 1.5rem;
    }

    .proof-slot {
      width: 100px;
      height: 80px;
      border: 3px dashed #CCC;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      background: white;
    }

    .proof-slot:hover {
      border-color: var(--and-color);
    }

    .proof-slot.filled {
      border-style: solid;
      border-color: var(--proof-valid);
      background: rgba(5, 150, 105, 0.1);
    }

    .slot-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      color: var(--undecidable-fog);
      margin-bottom: 0.3rem;
    }

    .slot-content {
      font-family: var(--mono);
      font-size: 1.2rem;
      color: var(--proof-valid);
    }

    .combiner {
      width: 60px;
      height: 60px;
      background: linear-gradient(135deg, var(--and-color) 0%, #2563EB 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-family: var(--mono);
      font-size: 1.5rem;
      box-shadow: 0 4px 15px rgba(59, 130, 246, 0.3);
    }

    .output-slot {
      width: 140px;
      height: 60px;
      border: 3px solid #CCC;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: white;
      transition: all 0.3s;
    }

    .output-slot.valid {
      border-color: var(--proof-valid);
      background: rgba(5, 150, 105, 0.1);
    }

    .output-slot .slot-content {
      font-size: 1rem;
    }

    .arrow-down {
      width: 0;
      height: 0;
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-top: 15px solid #CCC;
    }

    .arrow-down.active {
      border-top-color: var(--proof-valid);
    }

    /* ============================================
       OR MACHINE
       ============================================ */

    .or-machine {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .or-switch {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: white;
      border-radius: 12px;
      border: 2px solid #E0E0E0;
    }

    .switch-option {
      padding: 0.8rem 1.2rem;
      border: 2px solid #CCC;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-family: var(--mono);
      font-size: 0.9rem;
    }

    .switch-option:hover {
      border-color: var(--or-color);
    }

    .switch-option.selected {
      border-color: var(--or-color);
      background: var(--or-color);
      color: white;
    }

    .switch-divider {
      font-family: var(--mono);
      color: var(--undecidable-fog);
    }

    .or-proof-slot {
      width: 120px;
      height: 70px;
      border: 3px dashed #CCC;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: white;
      transition: all 0.2s;
    }

    .or-proof-slot.active {
      border-color: var(--or-color);
      border-style: solid;
    }

    .or-proof-slot.filled {
      border-color: var(--proof-valid);
      background: rgba(5, 150, 105, 0.1);
    }

    /* ============================================
       IMPLIES MACHINE
       ============================================ */

    .implies-machine {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1rem;
    }

    .transformer-box {
      width: 200px;
      padding: 1.5rem;
      background: linear-gradient(135deg, rgba(236, 72, 153, 0.1) 0%, rgba(236, 72, 153, 0.05) 100%);
      border: 2px solid var(--implies-color);
      border-radius: 12px;
      text-align: center;
    }

    .transformer-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      color: var(--implies-color);
      margin-bottom: 0.5rem;
    }

    .transformer-diagram {
      font-family: var(--mono);
      font-size: 1rem;
      color: var(--ink);
    }

    .implies-demo {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: white;
      border-radius: 12px;
      border: 2px solid #E0E0E0;
    }

    .demo-input {
      padding: 0.6rem 1rem;
      border: 2px solid #CCC;
      border-radius: 8px;
      font-family: var(--mono);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .demo-input:hover {
      border-color: var(--implies-color);
    }

    .demo-input.active {
      border-color: var(--proof-valid);
      background: rgba(5, 150, 105, 0.1);
    }

    .demo-arrow {
      font-size: 1.5rem;
      color: var(--implies-color);
    }

    .demo-output {
      padding: 0.6rem 1rem;
      border: 2px solid #CCC;
      border-radius: 8px;
      font-family: var(--mono);
      font-size: 0.85rem;
      transition: all 0.2s;
    }

    .demo-output.active {
      border-color: var(--proof-valid);
      background: rgba(5, 150, 105, 0.1);
    }

    /* ============================================
       NOT / DOUBLE NEGATION
       ============================================ */

    .not-machine {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
    }

    .negation-flow {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .negation-box {
      padding: 1rem 1.5rem;
      border: 2px solid #CCC;
      border-radius: 8px;
      font-family: var(--mono);
      font-size: 0.9rem;
      background: white;
      text-align: center;
    }

    .negation-box.highlight {
      border-color: var(--not-color);
      background: rgba(245, 158, 11, 0.1);
    }

    .flow-arrow {
      font-size: 1.5rem;
      color: var(--not-color);
    }

    .flow-arrow.valid {
      color: var(--proof-valid);
    }

    .flow-arrow.invalid {
      color: var(--proof-invalid);
      text-decoration: line-through;
    }

    .double-neg-demo {
      padding: 1.5rem;
      background: white;
      border-radius: 12px;
      border: 2px solid #E0E0E0;
      width: 100%;
      max-width: 400px;
    }

    .demo-title {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--undecidable-fog);
      margin-bottom: 1rem;
      text-align: center;
    }

    .demo-row {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.8rem;
      margin-bottom: 0.8rem;
      padding: 0.5rem;
      border-radius: 6px;
    }

    .demo-row.valid-row {
      background: rgba(5, 150, 105, 0.08);
    }

    .demo-row.invalid-row {
      background: rgba(220, 38, 38, 0.08);
    }

    .demo-row .formula {
      font-family: var(--mono);
      font-size: 0.85rem;
    }

    .demo-row .status {
      font-size: 0.75rem;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
    }

    .demo-row .status.valid {
      background: var(--proof-valid);
      color: white;
    }

    .demo-row .status.invalid {
      background: var(--proof-invalid);
      color: white;
    }

    /* ============================================
       PROOF PLAYGROUND
       ============================================ */

    .playground-section {
      min-height: 100vh;
      padding: 4rem 2rem;
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .playground-container {
      max-width: 1000px;
      margin: 0 auto;
    }

    .playground-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .playground-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .playground-subtitle {
      color: var(--fog-light);
      font-size: 1rem;
    }

    .playground-grid {
      display: grid;
      grid-template-columns: 250px 1fr;
      gap: 2rem;
    }

    @media (max-width: 800px) {
      .playground-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Proof Palette */
    .proof-palette {
      background: rgba(30, 30, 40, 0.5);
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 12px;
      padding: 1.5rem;
    }

    .palette-title {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--fog-light);
      margin-bottom: 1rem;
    }

    .palette-section {
      margin-bottom: 1.5rem;
    }

    .palette-section-title {
      font-size: 0.8rem;
      color: var(--fog-light);
      margin-bottom: 0.5rem;
    }

    .proof-blocks {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .proof-block {
      padding: 0.5rem 0.8rem;
      border: 2px solid;
      border-radius: 6px;
      font-family: var(--mono);
      font-size: 0.8rem;
      cursor: grab;
      transition: all 0.2s;
      user-select: none;
    }

    .proof-block:hover {
      transform: translateY(-2px);
    }

    .proof-block.atom {
      border-color: var(--constructive-glow);
      color: var(--constructive-glow);
      background: rgba(74, 157, 124, 0.1);
    }

    .proof-block.connective {
      border-color: var(--or-color);
      color: var(--or-color);
      background: rgba(139, 92, 246, 0.1);
    }

    /* Proof Canvas */
    .proof-canvas {
      background: rgba(30, 30, 40, 0.5);
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 12px;
      padding: 1.5rem;
      min-height: 400px;
    }

    .canvas-title {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--fog-light);
      margin-bottom: 1rem;
    }

    .proof-tree {
      min-height: 300px;
      border: 2px dashed rgba(107, 114, 128, 0.3);
      border-radius: 8px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }

    .tree-empty {
      color: var(--fog-light);
      font-style: italic;
      text-align: center;
    }

    .tree-node {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .node-content {
      padding: 0.8rem 1.2rem;
      border: 2px solid var(--constructive-glow);
      border-radius: 8px;
      font-family: var(--mono);
      font-size: 0.9rem;
      color: var(--constructive-glow);
      background: rgba(74, 157, 124, 0.1);
    }

    .node-children {
      display: flex;
      gap: 2rem;
      position: relative;
    }

    .node-children::before {
      content: '';
      position: absolute;
      top: -15px;
      left: 50%;
      width: 2px;
      height: 15px;
      background: var(--fog-light);
    }

    .proof-status {
      margin-top: 1rem;
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      font-family: var(--mono);
      font-size: 0.85rem;
    }

    .proof-status.valid {
      background: rgba(5, 150, 105, 0.15);
      color: var(--proof-valid);
    }

    .proof-status.incomplete {
      background: rgba(245, 158, 11, 0.15);
      color: var(--not-color);
    }

    /* ============================================
       COMPARISON TABLE
       ============================================ */

    .comparison-section {
      padding: 4rem 2rem;
      background: var(--background);
    }

    .comparison-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .comparison-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .comparison-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .comparison-table {
      width: 100%;
      border-collapse: collapse;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    }

    .comparison-table th,
    .comparison-table td {
      padding: 1rem 1.5rem;
      text-align: left;
      border-bottom: 1px solid #E8E4DC;
    }

    .comparison-table th {
      background: #F5F3F0;
      font-family: var(--mono);
      font-size: 0.75rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--undecidable-fog);
    }

    .comparison-table td {
      font-size: 0.95rem;
    }

    .comparison-table tr:last-child td {
      border-bottom: none;
    }

    .connective-cell {
      font-family: var(--mono);
      font-weight: 600;
    }

    .example-cell {
      font-family: var(--mono);
      font-size: 0.85rem;
      color: var(--undecidable-fog);
    }

    /* ============================================
       NAVIGATION
       ============================================ */

    .next-section {
      padding: 4rem 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, var(--constructive-primary) 0%, #1E3D31 100%);
      color: var(--ink-light);
      text-align: center;
    }

    .next-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--constructive-glow);
      margin-bottom: 1rem;
    }

    .next-title {
      font-family: var(--display);
      font-size: 1.6rem;
      margin-bottom: 0.5rem;
    }

    .next-description {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.8);
      max-width: 500px;
    }
  </style>
</head>
<body>

  <!-- Opening -->
  <section class="opening">
    <div class="opening-content">
      <p class="section-label">Brouwer's Interpretation</p>
      <h1 class="main-title">The Proof Factory</h1>
      
      <div class="connective-symbols">
        <span class="symbol and">∧</span>
        <span class="symbol or">∨</span>
        <span class="symbol implies">→</span>
        <span class="symbol not">¬</span>
      </div>
      
      <p class="subtitle">In constructive mathematics, logical connectives aren't truth tables—they're instructions for building proofs from other proofs.</p>
    </div>
  </section>

  <!-- Narrative: Introduction -->
  <section class="narrative-section">
    <div class="narrative-content" data-animate>
      <p>Classical logic tells us what statements are <em>true</em>. Constructive logic tells us how to <em>build proofs</em>.</p>
      <p>This shift has profound consequences. A classical mathematician can prove "P or Q" without knowing which one holds. A constructive mathematician must actually produce a proof of P, or a proof of Q—and declare which.</p>
      <div class="quote-block">
        "The constructive interpretations of the mathematical connectives and quantifiers have been established by Brouwer."
        <br><span style="font-size: 0.85rem; color: #888; font-style: normal;">— Bishop</span>
      </div>
    </div>
  </section>

  <!-- Connective Workspace -->
  <section class="workspace-section">
    <div class="workspace-header">
      <h2 class="workspace-title">The Four Connectives</h2>
      <p class="workspace-subtitle">Click each to explore its constructive meaning</p>
    </div>

    <div class="connective-tabs">
      <button class="tab-btn active" data-connective="and">
        <span class="tab-symbol">∧</span> AND
      </button>
      <button class="tab-btn" data-connective="or">
        <span class="tab-symbol">∨</span> OR
      </button>
      <button class="tab-btn" data-connective="implies">
        <span class="tab-symbol">→</span> IMPLIES
      </button>
      <button class="tab-btn" data-connective="not">
        <span class="tab-symbol">¬</span> NOT
      </button>
    </div>

    <div class="workspace-container">
      <!-- AND Panel -->
      <div class="workspace-panel active" data-panel="and">
        <div class="panel-grid">
          <div class="explanation-side">
            <h3 class="connective-name">
              <span class="connective-symbol" style="color: var(--and-color);">∧</span>
              Conjunction
            </h3>
            
            <div class="classical-view">
              <p class="view-label">Classical</p>
              <p class="view-text">"P ∧ Q" is true when both P and Q are true. A truth table with four rows.</p>
            </div>
            
            <div class="constructive-view">
              <p class="view-label">Constructive</p>
              <p class="view-text">A proof of "P ∧ Q" is a <strong>pair</strong>: a proof of P together with a proof of Q. You need both pieces.</p>
            </div>
            
            <p style="font-size: 0.9rem; color: #666; margin-top: 1rem;">
              <strong>Same as classical?</strong> Yes! AND works the same way in both systems. To prove a conjunction, you must prove both conjuncts.
            </p>
          </div>
          
          <div class="interactive-side">
            <p class="machine-title">The AND Combiner</p>
            <div class="and-machine">
              <div class="proof-inputs">
                <div class="proof-slot" id="andSlotP">
                  <span class="slot-label">Proof of P</span>
                  <span class="slot-content">?</span>
                </div>
                <div class="proof-slot" id="andSlotQ">
                  <span class="slot-label">Proof of Q</span>
                  <span class="slot-content">?</span>
                </div>
              </div>
              
              <div class="arrow-down" id="andArrow1"></div>
              
              <div class="combiner">∧</div>
              
              <div class="arrow-down" id="andArrow2"></div>
              
              <div class="output-slot" id="andOutput">
                <span class="slot-label">Result:</span>
                <span class="slot-content" style="margin-left: 0.5rem;">—</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- OR Panel -->
      <div class="workspace-panel" data-panel="or">
        <div class="panel-grid">
          <div class="explanation-side">
            <h3 class="connective-name">
              <span class="connective-symbol" style="color: var(--or-color);">∨</span>
              Disjunction
            </h3>
            
            <div class="classical-view">
              <p class="view-label">Classical</p>
              <p class="view-text">"P ∨ Q" is true when at least one of P, Q is true. You can prove "P ∨ Q" without knowing which holds.</p>
            </div>
            
            <div class="constructive-view">
              <p class="view-label">Constructive</p>
              <p class="view-text">A proof of "P ∨ Q" is a <strong>tagged proof</strong>: either "left" plus a proof of P, or "right" plus a proof of Q. You must <em>choose a side</em>.</p>
            </div>
            
            <p style="font-size: 0.9rem; color: #666; margin-top: 1rem;">
              <strong>Different from classical!</strong> You cannot prove "P ∨ ¬P" constructively without already knowing which one holds. This is why the law of excluded middle fails.
            </p>
          </div>
          
          <div class="interactive-side">
            <p class="machine-title">The OR Switch</p>
            <div class="or-machine">
              <div class="or-switch">
                <div class="switch-option" id="orLeft">LEFT (P)</div>
                <span class="switch-divider">or</span>
                <div class="switch-option" id="orRight">RIGHT (Q)</div>
              </div>
              
              <div class="arrow-down" id="orArrow1"></div>
              
              <div class="or-proof-slot" id="orProofSlot">
                <span class="slot-label" id="orSlotLabel">Choose a side first</span>
                <span class="slot-content">?</span>
              </div>
              
              <div class="arrow-down" id="orArrow2"></div>
              
              <div class="output-slot" id="orOutput">
                <span class="slot-label">Result:</span>
                <span class="slot-content" style="margin-left: 0.5rem;">—</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- IMPLIES Panel -->
      <div class="workspace-panel" data-panel="implies">
        <div class="panel-grid">
          <div class="explanation-side">
            <h3 class="connective-name">
              <span class="connective-symbol" style="color: var(--implies-color);">→</span>
              Implication
            </h3>
            
            <div class="classical-view">
              <p class="view-label">Classical</p>
              <p class="view-text">"P → Q" is true unless P is true and Q is false. Vacuously true when P is false.</p>
            </div>
            
            <div class="constructive-view">
              <p class="view-label">Constructive</p>
              <p class="view-text">A proof of "P → Q" is a <strong>function</strong> (algorithm) that transforms any proof of P into a proof of Q. It's a proof transformer.</p>
            </div>
            
            <p style="font-size: 0.9rem; color: #666; margin-top: 1rem;">
              <strong>Subtly different:</strong> Nested implications like "(P → Q) → R" have less immediate meaning—you need to see the actual proof to understand what's happening.
            </p>
          </div>
          
          <div class="interactive-side">
            <p class="machine-title">The Proof Transformer</p>
            <div class="implies-machine">
              <div class="transformer-box">
                <p class="transformer-label">The Machine Inside</p>
                <p class="transformer-diagram">proof(P) ↦ proof(Q)</p>
              </div>
              
              <p style="font-size: 0.8rem; color: #666; margin: 0.5rem 0;">Example: "n is even → n² is even"</p>
              
              <div class="implies-demo">
                <div class="demo-input" id="impliesInput">
                  proof(4 is even)
                </div>
                <span class="demo-arrow">→</span>
                <div class="demo-output" id="impliesOutput">
                  proof(16 is even)
                </div>
              </div>
              
              <p style="font-size: 0.75rem; color: #888; margin-top: 1rem; text-align: center;">
                Click the input to feed a proof into the machine
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- NOT Panel -->
      <div class="workspace-panel" data-panel="not">
        <div class="panel-grid">
          <div class="explanation-side">
            <h3 class="connective-name">
              <span class="connective-symbol" style="color: var(--not-color);">¬</span>
              Negation
            </h3>
            
            <div class="classical-view">
              <p class="view-label">Classical</p>
              <p class="view-text">"¬P" is true when P is false. Double negation cancels: ¬¬P = P.</p>
            </div>
            
            <div class="constructive-view">
              <p class="view-label">Constructive</p>
              <p class="view-text">"¬P" means "P → ⊥" (P implies absurdity). A proof of ¬P is a function that turns any proof of P into a proof of 0 = 1.</p>
            </div>
            
            <p style="font-size: 0.9rem; color: #666; margin-top: 1rem;">
              <strong>The gap:</strong> P → ¬¬P is constructively valid. But ¬¬P → P is <em>not</em>! Knowing that P is not false doesn't give you a proof of P.
            </p>
          </div>
          
          <div class="interactive-side">
            <p class="machine-title">The Double Negation Gap</p>
            <div class="not-machine">
              <div class="negation-flow">
                <div class="negation-box">P</div>
                <span class="flow-arrow valid">→</span>
                <div class="negation-box highlight">¬¬P</div>
              </div>
              
              <p style="font-size: 0.8rem; color: var(--proof-valid);">✓ Always valid: If you have P, you can prove ¬¬P</p>
              
              <div class="negation-flow" style="margin-top: 1rem;">
                <div class="negation-box highlight">¬¬P</div>
                <span class="flow-arrow" style="color: var(--proof-invalid); position: relative;">
                  →
                  <span style="position: absolute; top: -2px; left: 50%; transform: translateX(-50%); font-size: 1.5rem;">✕</span>
                </span>
                <div class="negation-box">P</div>
              </div>
              
              <p style="font-size: 0.8rem; color: var(--proof-invalid);">✗ Not valid: Knowing P isn't false doesn't construct P</p>
              
              <div class="double-neg-demo">
                <p class="demo-title">Why the gap matters</p>
                <div class="demo-row valid-row">
                  <span class="formula">¬¬(P ∨ ¬P)</span>
                  <span class="status valid">✓ provable</span>
                </div>
                <div class="demo-row invalid-row">
                  <span class="formula">P ∨ ¬P</span>
                  <span class="status invalid">✗ not provable</span>
                </div>
                <p style="font-size: 0.75rem; color: #666; margin-top: 0.5rem;">
                  We can prove it's not false that "P or not P", but we can't always produce a proof of P or a proof of ¬P!
                </p>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Comparison Table -->
  <section class="comparison-section">
    <div class="comparison-container">
      <div class="comparison-header">
        <h2 class="comparison-title">Classical vs Constructive: At a Glance</h2>
      </div>

      <table class="comparison-table">
        <thead>
          <tr>
            <th>Connective</th>
            <th>Classical Meaning</th>
            <th>Constructive Meaning</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="connective-cell" style="color: var(--and-color);">P ∧ Q</td>
            <td>Both P and Q are true</td>
            <td>A pair: (proof of P, proof of Q)</td>
          </tr>
          <tr>
            <td class="connective-cell" style="color: var(--or-color);">P ∨ Q</td>
            <td>At least one is true</td>
            <td>A tagged proof: "left" + proof(P) or "right" + proof(Q)</td>
          </tr>
          <tr>
            <td class="connective-cell" style="color: var(--implies-color);">P → Q</td>
            <td>If P then Q (truth table)</td>
            <td>A function: proof(P) ↦ proof(Q)</td>
          </tr>
          <tr>
            <td class="connective-cell" style="color: var(--not-color);">¬P</td>
            <td>P is false</td>
            <td>P → ⊥ (P leads to contradiction)</td>
          </tr>
          <tr>
            <td class="connective-cell">∃x.P(x)</td>
            <td>Some x makes P(x) true</td>
            <td>A witness: specific x + proof of P(x)</td>
          </tr>
          <tr>
            <td class="connective-cell">∀x.P(x)</td>
            <td>Every x makes P(x) true</td>
            <td>A function: x ↦ proof of P(x)</td>
          </tr>
        </tbody>
      </table>
    </div>
  </section>

  <!-- Key Insight -->
  <section class="narrative-section dark">
    <div class="narrative-content" data-animate>
      <p>The constructive interpretation isn't just philosophy—it has computational content. Under the Curry-Howard correspondence:</p>
      <p style="text-align: center; font-family: var(--mono); font-size: 1.1rem; color: var(--constructive-glow);">
        Proofs = Programs<br>
        Propositions = Types
      </p>
      <p>A proof of "P → Q" literally <em>is</em> a function from P-proofs to Q-proofs. A proof of "P ∧ Q" literally <em>is</em> a pair. The logical connectives become programming constructs.</p>
      <p>This is why constructive mathematics has such natural computational meaning—it was built to describe <em>what can be computed</em>.</p>
    </div>
  </section>

  <!-- Navigation -->
  <section class="next-section">
    <p class="next-label">Coming Next</p>
    <h3 class="next-title">Constructing the Real Numbers</h3>
    <p class="next-description">Cauchy sequences with a computable modulus of convergence—building the continuum from algorithms.</p>
  </section>

  <script>
    // ============================================
    // SCROLL ANIMATIONS
    // ============================================
    
    const observerOptions = { threshold: 0.3, rootMargin: '0px 0px -10% 0px' };
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) entry.target.classList.add('visible');
      });
    }, observerOptions);

    document.querySelectorAll('[data-animate], .narrative-content').forEach(el => observer.observe(el));

    // ============================================
    // CONNECTIVE TABS
    // ============================================
    
    const tabBtns = document.querySelectorAll('.tab-btn');
    const panels = document.querySelectorAll('.workspace-panel');

    tabBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const connective = btn.dataset.connective;
        
        tabBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        panels.forEach(p => {
          p.classList.remove('active');
          if (p.dataset.panel === connective) {
            p.classList.add('active');
          }
        });
      });
    });

    // ============================================
    // AND MACHINE
    // ============================================
    
    const andSlotP = document.getElementById('andSlotP');
    const andSlotQ = document.getElementById('andSlotQ');
    const andArrow1 = document.getElementById('andArrow1');
    const andArrow2 = document.getElementById('andArrow2');
    const andOutput = document.getElementById('andOutput');

    let andStateP = false;
    let andStateQ = false;

    andSlotP.addEventListener('click', () => {
      andStateP = !andStateP;
      updateAndMachine();
    });

    andSlotQ.addEventListener('click', () => {
      andStateQ = !andStateQ;
      updateAndMachine();
    });

    function updateAndMachine() {
      // Update P slot
      if (andStateP) {
        andSlotP.classList.add('filled');
        andSlotP.querySelector('.slot-content').textContent = '✓';
      } else {
        andSlotP.classList.remove('filled');
        andSlotP.querySelector('.slot-content').textContent = '?';
      }

      // Update Q slot
      if (andStateQ) {
        andSlotQ.classList.add('filled');
        andSlotQ.querySelector('.slot-content').textContent = '✓';
      } else {
        andSlotQ.classList.remove('filled');
        andSlotQ.querySelector('.slot-content').textContent = '?';
      }

      // Update output
      if (andStateP && andStateQ) {
        andArrow1.classList.add('active');
        andArrow2.classList.add('active');
        andOutput.classList.add('valid');
        andOutput.querySelector('.slot-content').textContent = 'P ∧ Q ✓';
        andOutput.querySelector('.slot-content').style.color = 'var(--proof-valid)';
      } else {
        andArrow1.classList.remove('active');
        andArrow2.classList.remove('active');
        andOutput.classList.remove('valid');
        andOutput.querySelector('.slot-content').textContent = 'need both';
        andOutput.querySelector('.slot-content').style.color = 'var(--undecidable-fog)';
      }
    }

    // ============================================
    // OR MACHINE
    // ============================================
    
    const orLeft = document.getElementById('orLeft');
    const orRight = document.getElementById('orRight');
    const orProofSlot = document.getElementById('orProofSlot');
    const orSlotLabel = document.getElementById('orSlotLabel');
    const orArrow1 = document.getElementById('orArrow1');
    const orArrow2 = document.getElementById('orArrow2');
    const orOutput = document.getElementById('orOutput');

    let orSelection = null; // 'left', 'right', or null
    let orProofFilled = false;

    orLeft.addEventListener('click', () => {
      orSelection = 'left';
      orProofFilled = false;
      updateOrMachine();
    });

    orRight.addEventListener('click', () => {
      orSelection = 'right';
      orProofFilled = false;
      updateOrMachine();
    });

    orProofSlot.addEventListener('click', () => {
      if (orSelection) {
        orProofFilled = !orProofFilled;
        updateOrMachine();
      }
    });

    function updateOrMachine() {
      // Update switch
      orLeft.classList.toggle('selected', orSelection === 'left');
      orRight.classList.toggle('selected', orSelection === 'right');

      // Update proof slot
      if (orSelection) {
        orProofSlot.classList.add('active');
        orSlotLabel.textContent = orSelection === 'left' ? 'Proof of P' : 'Proof of Q';
        
        if (orProofFilled) {
          orProofSlot.classList.add('filled');
          orProofSlot.querySelector('.slot-content').textContent = '✓';
        } else {
          orProofSlot.classList.remove('filled');
          orProofSlot.querySelector('.slot-content').textContent = '?';
        }
      } else {
        orProofSlot.classList.remove('active', 'filled');
        orSlotLabel.textContent = 'Choose a side first';
        orProofSlot.querySelector('.slot-content').textContent = '?';
      }

      // Update output
      if (orSelection && orProofFilled) {
        orArrow1.classList.add('active');
        orArrow2.classList.add('active');
        orOutput.classList.add('valid');
        const tag = orSelection === 'left' ? 'inl' : 'inr';
        orOutput.querySelector('.slot-content').textContent = `${tag}(P ∨ Q) ✓`;
        orOutput.querySelector('.slot-content').style.color = 'var(--proof-valid)';
      } else {
        orArrow1.classList.remove('active');
        orArrow2.classList.remove('active');
        orOutput.classList.remove('valid');
        orOutput.querySelector('.slot-content').textContent = '—';
        orOutput.querySelector('.slot-content').style.color = 'var(--undecidable-fog)';
      }
    }

    // ============================================
    // IMPLIES MACHINE
    // ============================================
    
    const impliesInput = document.getElementById('impliesInput');
    const impliesOutput = document.getElementById('impliesOutput');

    let impliesActive = false;

    impliesInput.addEventListener('click', () => {
      impliesActive = !impliesActive;
      
      if (impliesActive) {
        impliesInput.classList.add('active');
        impliesOutput.classList.add('active');
        
        // Animate the transformation
        impliesInput.style.transform = 'scale(0.95)';
        setTimeout(() => {
          impliesInput.style.transform = '';
        }, 150);
      } else {
        impliesInput.classList.remove('active');
        impliesOutput.classList.remove('active');
      }
    });

    // ============================================
    // Initialize
    // ============================================
    
    updateAndMachine();
    updateOrMachine();
  </script>
</body>
</html>
