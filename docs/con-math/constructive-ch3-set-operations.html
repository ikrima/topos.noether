<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Constructive Set Operations — Chapter 3</title>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Source+Sans+Pro:wght@300;400;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --set-primary: #4F46E5;
      --union-color: #F97316;
      --intersection-color: #22C55E;
      --complement-color: #EC4899;
      --inclusion-color: #06B6D4;
      --detachable: #8B5CF6;
      --fog-zone: #6B7280;
      --background: #FAF8F5;
      --background-dark: #0F0F12;
      --ink: #1A1A1A;
      --ink-light: #FAF8F5;
      
      --display: 'Crimson Text', serif;
      --body: 'Source Sans Pro', sans-serif;
      --mono: 'JetBrains Mono', monospace;
      
      --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body {
      font-family: var(--body);
      background: var(--background);
      color: var(--ink);
      line-height: 1.7;
      overflow-x: hidden;
    }

    /* Opening */
    .opening {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      background: linear-gradient(180deg, var(--set-primary) 0%, #3730A3 100%);
      color: var(--ink-light);
      position: relative;
    }

    .opening-content {
      text-align: center;
      max-width: 800px;
    }

    .chapter-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.7);
      margin-bottom: 0.5rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.2s forwards;
    }

    .section-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.9);
      margin-bottom: 1rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.3s forwards;
    }

    .main-title {
      font-family: var(--display);
      font-size: clamp(2rem, 6vw, 3.5rem);
      font-weight: 400;
      line-height: 1.2;
      margin-bottom: 1.5rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.4s forwards;
    }

    .subtitle {
      font-size: 1.15rem;
      color: rgba(255, 255, 255, 0.9);
      max-width: 600px;
      margin: 0 auto;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.6s forwards;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Narrative */
    .narrative-section {
      min-height: 60vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4rem 2rem;
    }

    .narrative-section.dark {
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .narrative-content {
      max-width: 650px;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.8s var(--ease-out-expo), transform 0.8s var(--ease-out-expo);
    }

    .narrative-content.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .narrative-content p {
      font-size: 1.2rem;
      margin-bottom: 1.5rem;
    }

    .math-display {
      font-family: var(--mono);
      font-size: 0.95rem;
      background: rgba(79, 70, 229, 0.1);
      padding: 1.5rem;
      border-radius: 8px;
      text-align: center;
      margin: 1.5rem 0;
      border-left: 3px solid var(--set-primary);
    }

    .dark .math-display {
      background: rgba(79, 70, 229, 0.15);
    }

    /* Section headers */
    .section-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .section-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .section-subtitle {
      color: #666;
      font-size: 1rem;
      max-width: 600px;
      margin: 0 auto;
    }

    /* Inclusion Map Section */
    .inclusion-section {
      padding: 4rem 2rem;
      background: linear-gradient(180deg, #F5F3F0 0%, var(--background) 100%);
    }

    .inclusion-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .inclusion-panel {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.08);
      padding: 2rem;
    }

    .inclusion-canvas-container {
      height: 300px;
      background: #FAFAFA;
      border-radius: 12px;
      margin-bottom: 1.5rem;
    }

    #inclusionCanvas {
      width: 100%;
      height: 100%;
    }

    .inclusion-explanation {
      padding: 1.5rem;
      background: rgba(6, 182, 212, 0.1);
      border-radius: 12px;
      border-left: 3px solid var(--inclusion-color);
    }

    .inclusion-explanation p {
      font-size: 0.95rem;
      margin-bottom: 0.8rem;
    }

    .inclusion-explanation p:last-child {
      margin-bottom: 0;
    }

    /* Union Section */
    .union-section {
      min-height: 100vh;
      padding: 4rem 2rem;
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .union-container {
      max-width: 1000px;
      margin: 0 auto;
    }

    .union-panel {
      background: rgba(30, 30, 40, 0.5);
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 16px;
      padding: 2rem;
    }

    .union-canvas-container {
      height: 350px;
      margin-bottom: 1.5rem;
    }

    #unionCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #0A0A0F;
    }

    .union-controls {
      display: flex;
      justify-content: center;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .choice-btn {
      padding: 1rem 2rem;
      border: 2px solid var(--union-color);
      border-radius: 12px;
      background: transparent;
      color: var(--union-color);
      font-family: var(--mono);
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s;
    }

    .choice-btn:hover {
      background: rgba(249, 115, 22, 0.2);
      transform: scale(1.05);
    }

    .choice-btn.selected {
      background: var(--union-color);
      color: var(--background-dark);
    }

    .union-result {
      text-align: center;
      padding: 1.5rem;
      border-radius: 12px;
      font-family: var(--mono);
    }

    .union-result.waiting {
      background: rgba(107, 114, 128, 0.2);
      color: var(--fog-zone);
    }

    .union-result.chosen {
      background: rgba(249, 115, 22, 0.2);
      color: var(--union-color);
    }

    /* Intersection Section */
    .intersection-section {
      padding: 4rem 2rem;
      background: var(--background);
    }

    .intersection-container {
      max-width: 1000px;
      margin: 0 auto;
    }

    .intersection-panel {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.08);
      padding: 2rem;
    }

    .intersection-canvas-container {
      height: 350px;
      background: #FAFAFA;
      border-radius: 12px;
      margin-bottom: 1.5rem;
    }

    #intersectionCanvas {
      width: 100%;
      height: 100%;
    }

    .intersection-controls {
      display: flex;
      justify-content: center;
      gap: 2rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }

    .element-selector {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .selector-label {
      font-family: var(--mono);
      font-size: 0.75rem;
      color: var(--fog-zone);
    }

    .selector-btns {
      display: flex;
      gap: 0.3rem;
    }

    .elem-btn {
      width: 40px;
      height: 40px;
      border: 2px solid #E0E0E0;
      border-radius: 8px;
      background: white;
      font-family: var(--mono);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .elem-btn:hover {
      border-color: var(--intersection-color);
    }

    .elem-btn.selected {
      border-color: var(--intersection-color);
      background: var(--intersection-color);
      color: white;
    }

    .intersection-result {
      text-align: center;
      padding: 1.5rem;
      border-radius: 12px;
    }

    .intersection-result.match {
      background: rgba(34, 197, 94, 0.1);
      border: 2px solid var(--intersection-color);
    }

    .intersection-result.no-match {
      background: rgba(239, 68, 68, 0.1);
      border: 2px solid #EF4444;
    }

    /* Detachable Section */
    .detachable-section {
      min-height: 100vh;
      padding: 4rem 2rem;
      background: linear-gradient(180deg, #1A1A20 0%, var(--background-dark) 100%);
      color: var(--ink-light);
    }

    .detachable-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .detachable-panel {
      background: rgba(30, 30, 40, 0.5);
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 16px;
      padding: 2rem;
    }

    .detachable-canvas-container {
      height: 280px;
      margin-bottom: 1.5rem;
    }

    #detachableCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #0A0A0F;
    }

    .detachable-controls {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }

    .subset-btn {
      padding: 0.8rem 1.2rem;
      border: 2px solid var(--detachable);
      border-radius: 8px;
      background: transparent;
      color: var(--detachable);
      font-family: var(--mono);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .subset-btn:hover {
      background: rgba(139, 92, 246, 0.2);
    }

    .subset-btn.active {
      background: var(--detachable);
      color: white;
    }

    .detachable-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    @media (max-width: 600px) {
      .detachable-info { grid-template-columns: 1fr; }
    }

    .info-card {
      background: rgba(20, 20, 30, 0.5);
      padding: 1.2rem;
      border-radius: 10px;
      text-align: center;
    }

    .info-label {
      font-family: var(--mono);
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--fog-zone);
      margin-bottom: 0.3rem;
    }

    .info-value {
      font-family: var(--mono);
      font-size: 1rem;
    }

    .info-value.yes { color: var(--intersection-color); }
    .info-value.no { color: #EF4444; }
    .info-value.unknown { color: var(--fog-zone); }

    /* Navigation */
    .next-section {
      padding: 4rem 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, var(--set-primary) 0%, #3730A3 100%);
      color: var(--ink-light);
      text-align: center;
    }

    .next-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.7);
      margin-bottom: 1rem;
    }

    .next-title {
      font-family: var(--display);
      font-size: 1.6rem;
      margin-bottom: 0.5rem;
    }

    .next-description {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.9);
      max-width: 500px;
    }
  </style>
</head>
<body>

  <!-- Opening -->
  <section class="opening">
    <div class="opening-content">
      <p class="chapter-label">Chapter 3: Set Theory</p>
      <p class="section-label">Section 1: Basic Notions</p>
      <h1 class="main-title">Constructive Set Operations</h1>
      <p class="subtitle">A set is not a passive container. It's a construction protocol. And set operations require you to do work.</p>
    </div>
  </section>

  <!-- Narrative: Introduction -->
  <section class="narrative-section">
    <div class="narrative-content" data-animate>
      <p>In classical mathematics, a set is a collection of objects. You can ask "is x in S?" and get a yes or no answer.</p>
      <p>Constructively, sets are different. To <em>have</em> an element of S, you must <em>construct</em> one. To <em>be</em> a subset, you need an explicit inclusion map. Every set-theoretic statement carries computational content.</p>
    </div>
  </section>

  <!-- Narrative: Subsets -->
  <section class="narrative-section">
    <div class="narrative-content" data-animate>
      <div class="math-display">
        <strong>Definition 1.1:</strong> A subset of B is a pair (A, i)<br>
        where i : A → B is the <em>inclusion map</em><br><br>
        such that a = a' ⟺ i(a) = i(a')
      </div>
      <p>A subset isn't just "A contained in B." It's a set A together with a function i that embeds A into B, preserving and reflecting equality.</p>
      <p>The inclusion map is not optional—it's part of the definition.</p>
    </div>
  </section>

  <!-- Inclusion Map Visualization -->
  <section class="inclusion-section">
    <div class="section-header">
      <h2 class="section-title">The Inclusion Map</h2>
      <p class="section-subtitle">A subset (A, i) of B requires an explicit embedding</p>
    </div>

    <div class="inclusion-container">
      <div class="inclusion-panel">
        <div class="inclusion-canvas-container">
          <canvas id="inclusionCanvas"></canvas>
        </div>

        <div class="inclusion-explanation">
          <p><strong>What you're seeing:</strong> Set A on the left, set B on the right. The arrows show the inclusion map i : A → B.</p>
          <p><strong>Key insight:</strong> Elements a₁ and a₂ in A are equal precisely when i(a₁) = i(a₂) in B. The inclusion map doesn't just place A inside B—it defines equality on A.</p>
          <p><strong>This is not containment:</strong> We don't say "A ⊆ B" as if A were literally inside B. We have a pair (A, i) where i witnesses how A relates to B.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Union Section -->
  <section class="union-section">
    <div class="section-header" style="color: var(--ink-light);">
      <h2 class="section-title">Union Requires Choice</h2>
      <p class="section-subtitle" style="color: var(--fog-zone);">To construct c ∈ A ∪ B, you must choose: construct from A, or from B?</p>
    </div>

    <div class="union-container">
      <div class="union-panel">
        <div class="union-canvas-container">
          <canvas id="unionCanvas"></canvas>
        </div>

        <div class="union-controls">
          <button class="choice-btn" id="chooseA">Construct from A</button>
          <button class="choice-btn" id="chooseB">Construct from B</button>
        </div>

        <div class="union-result waiting" id="unionResult">
          To construct an element of A ∪ B, you must make a choice.
        </div>
      </div>
    </div>
  </section>

  <!-- Intersection Section -->
  <section class="intersection-section">
    <div class="section-header">
      <h2 class="section-title">Intersection Requires Matching</h2>
      <p class="section-subtitle">To construct c ∈ A ∩ B, find (a, b) with i_A(a) = i_B(b)</p>
    </div>

    <div class="intersection-container">
      <div class="intersection-panel">
        <div class="intersection-canvas-container">
          <canvas id="intersectionCanvas"></canvas>
        </div>

        <div class="intersection-controls">
          <div class="element-selector">
            <span class="selector-label">Choose a ∈ A</span>
            <div class="selector-btns" id="aButtons">
              <button class="elem-btn" data-elem="a1">a₁</button>
              <button class="elem-btn" data-elem="a2">a₂</button>
              <button class="elem-btn" data-elem="a3">a₃</button>
            </div>
          </div>

          <div class="element-selector">
            <span class="selector-label">Choose b ∈ B</span>
            <div class="selector-btns" id="bButtons">
              <button class="elem-btn" data-elem="b1">b₁</button>
              <button class="elem-btn" data-elem="b2">b₂</button>
              <button class="elem-btn" data-elem="b3">b₃</button>
            </div>
          </div>
        </div>

        <div class="intersection-result no-match" id="intersectionResult">
          Select elements from A and B to check if they match in S.
        </div>
      </div>
    </div>
  </section>

  <!-- Detachable Subsets -->
  <section class="detachable-section">
    <div class="section-header" style="color: var(--ink-light);">
      <h2 class="section-title">Detachable Subsets</h2>
      <p class="section-subtitle" style="color: var(--fog-zone);">A subset is detachable if we have a decision procedure for membership</p>
    </div>

    <div class="detachable-container">
      <div class="detachable-panel">
        <div class="detachable-canvas-container">
          <canvas id="detachableCanvas"></canvas>
        </div>

        <div class="detachable-controls">
          <button class="subset-btn active" data-subset="evens">Even integers (detachable)</button>
          <button class="subset-btn" data-subset="primes">Primes (detachable)</button>
          <button class="subset-btn" data-subset="halting">Halting programs (not detachable)</button>
        </div>

        <div class="detachable-info">
          <div class="info-card">
            <p class="info-label">Membership decidable?</p>
            <p class="info-value yes" id="decidableStatus">Yes</p>
          </div>
          <div class="info-card">
            <p class="info-label">Decision function</p>
            <p class="info-value" id="decisionFunction" style="color: var(--detachable);">f(n) = (n mod 2 = 0) ? 1 : 0</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Narrative: Discrete Sets -->
  <section class="narrative-section dark">
    <div class="narrative-content" data-animate>
      <p>A related concept: a set S is <strong>discrete</strong> if equality is decidable—that is, for any s, s' ∈ S, we can determine whether s = s' or s ≠ s'.</p>
      <div class="math-display">
        S is discrete ⟺ {(s, s') : s = s'} is detachable in S × S
      </div>
      <p>The integers are discrete. The reals are not—we cannot always decide if two real numbers are equal.</p>
    </div>
  </section>

  <!-- Navigation -->
  <section class="next-section">
    <p class="next-label">Coming Next</p>
    <h3 class="next-title">Complemented Sets & The Inequality Relation</h3>
    <p class="next-description">Complementation requires inequality, not negation. And some familiar laws will fail.</p>
  </section>

  <script>
    // Scroll animations
    const observerOptions = { threshold: 0.3, rootMargin: '0px 0px -10% 0px' };
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) entry.target.classList.add('visible');
      });
    }, observerOptions);
    document.querySelectorAll('[data-animate], .narrative-content').forEach(el => observer.observe(el));

    function setupCanvas(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      return { ctx, width: rect.width, height: rect.height };
    }

    // ============================================
    // INCLUSION MAP VISUALIZATION
    // ============================================
    
    const inclusionCanvas = document.getElementById('inclusionCanvas');

    function drawInclusion() {
      const { ctx, width, height } = setupCanvas(inclusionCanvas);

      ctx.fillStyle = '#FAFAFA';
      ctx.fillRect(0, 0, width, height);

      const setAx = width * 0.25;
      const setBx = width * 0.75;
      const centerY = height * 0.5;
      const radius = Math.min(width * 0.15, height * 0.35);

      // Draw set B (larger, on right)
      ctx.strokeStyle = '#4F46E5';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(setBx, centerY, radius * 1.3, radius * 1.2, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = 'rgba(79, 70, 229, 0.05)';
      ctx.fill();

      // Draw set A (smaller, on left)
      ctx.strokeStyle = '#06B6D4';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(setAx, centerY, radius * 0.8, radius * 0.75, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = 'rgba(6, 182, 212, 0.1)';
      ctx.fill();

      // Elements in A
      const elementsA = [
        { x: setAx - 25, y: centerY - 30, label: 'a₁' },
        { x: setAx + 20, y: centerY, label: 'a₂' },
        { x: setAx - 10, y: centerY + 35, label: 'a₃' }
      ];

      // Elements in B (images under i)
      const elementsB = [
        { x: setBx - 40, y: centerY - 40, label: 'i(a₁)' },
        { x: setBx + 30, y: centerY - 10, label: 'i(a₂)' },
        { x: setBx - 20, y: centerY + 45, label: 'i(a₃)' }
      ];

      // Draw arrows (inclusion map)
      ctx.strokeStyle = 'rgba(6, 182, 212, 0.6)';
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++) {
        const startX = elementsA[i].x + 15;
        const startY = elementsA[i].y;
        const endX = elementsB[i].x - 20;
        const endY = elementsB[i].y;

        // Curved arrow
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        const cpX = (startX + endX) / 2;
        const cpY = startY + (i - 1) * 20;
        ctx.quadraticCurveTo(cpX, cpY, endX, endY);
        ctx.stroke();

        // Arrow head
        const angle = Math.atan2(endY - cpY, endX - cpX);
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(endX - 8 * Math.cos(angle - 0.4), endY - 8 * Math.sin(angle - 0.4));
        ctx.moveTo(endX, endY);
        ctx.lineTo(endX - 8 * Math.cos(angle + 0.4), endY - 8 * Math.sin(angle + 0.4));
        ctx.stroke();
      }

      // Draw elements in A
      ctx.fillStyle = '#06B6D4';
      elementsA.forEach(el => {
        ctx.beginPath();
        ctx.arc(el.x, el.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#06B6D4';
        ctx.font = '12px "JetBrains Mono"';
        ctx.textAlign = 'center';
        ctx.fillText(el.label, el.x, el.y - 12);
        ctx.fillStyle = '#06B6D4';
      });

      // Draw elements in B
      ctx.fillStyle = '#4F46E5';
      elementsB.forEach(el => {
        ctx.beginPath();
        ctx.arc(el.x, el.y, 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#4F46E5';
        ctx.font = '11px "JetBrains Mono"';
        ctx.textAlign = 'center';
        ctx.fillText(el.label, el.x, el.y - 12);
        ctx.fillStyle = '#4F46E5';
      });

      // Labels
      ctx.font = 'bold 16px "JetBrains Mono"';
      ctx.fillStyle = '#06B6D4';
      ctx.textAlign = 'center';
      ctx.fillText('A', setAx, centerY + radius + 25);

      ctx.fillStyle = '#4F46E5';
      ctx.fillText('B', setBx, centerY + radius * 1.2 + 25);

      // Arrow label
      ctx.fillStyle = '#666';
      ctx.font = 'italic 14px "JetBrains Mono"';
      ctx.fillText('i : A → B', width / 2, 30);
    }

    // ============================================
    // UNION VISUALIZATION
    // ============================================
    
    const unionCanvas = document.getElementById('unionCanvas');
    const unionResult = document.getElementById('unionResult');
    let unionChoice = null;

    function drawUnion() {
      const { ctx, width, height } = setupCanvas(unionCanvas);

      ctx.fillStyle = '#0A0A0F';
      ctx.fillRect(0, 0, width, height);

      const centerY = height * 0.5;
      const setAx = width * 0.3;
      const setBx = width * 0.7;
      const radius = Math.min(width * 0.18, height * 0.35);

      // Draw branching paths
      ctx.strokeStyle = 'rgba(249, 115, 22, 0.3)';
      ctx.lineWidth = 3;
      ctx.setLineDash([5, 5]);
      
      // Path to A
      ctx.beginPath();
      ctx.moveTo(width / 2, height - 40);
      ctx.quadraticCurveTo(width / 2 - 50, centerY + 30, setAx, centerY);
      ctx.stroke();

      // Path to B
      ctx.beginPath();
      ctx.moveTo(width / 2, height - 40);
      ctx.quadraticCurveTo(width / 2 + 50, centerY + 30, setBx, centerY);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw set A
      ctx.strokeStyle = unionChoice === 'A' ? '#F97316' : 'rgba(249, 115, 22, 0.4)';
      ctx.lineWidth = unionChoice === 'A' ? 4 : 2;
      ctx.beginPath();
      ctx.ellipse(setAx, centerY, radius, radius * 0.9, 0, 0, Math.PI * 2);
      ctx.stroke();
      if (unionChoice === 'A') {
        ctx.fillStyle = 'rgba(249, 115, 22, 0.15)';
        ctx.fill();
      }

      // Draw set B
      ctx.strokeStyle = unionChoice === 'B' ? '#F97316' : 'rgba(249, 115, 22, 0.4)';
      ctx.lineWidth = unionChoice === 'B' ? 4 : 2;
      ctx.beginPath();
      ctx.ellipse(setBx, centerY, radius, radius * 0.9, 0, 0, Math.PI * 2);
      ctx.stroke();
      if (unionChoice === 'B') {
        ctx.fillStyle = 'rgba(249, 115, 22, 0.15)';
        ctx.fill();
      }

      // Labels
      ctx.font = 'bold 18px "JetBrains Mono"';
      ctx.fillStyle = unionChoice === 'A' ? '#F97316' : 'rgba(249, 115, 22, 0.5)';
      ctx.textAlign = 'center';
      ctx.fillText('A', setAx, centerY + 8);

      ctx.fillStyle = unionChoice === 'B' ? '#F97316' : 'rgba(249, 115, 22, 0.5)';
      ctx.fillText('B', setBx, centerY + 8);

      // Choice point
      ctx.fillStyle = '#F97316';
      ctx.beginPath();
      ctx.arc(width / 2, height - 40, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.font = '12px "JetBrains Mono"';
      ctx.fillText('?', width / 2, height - 36);

      // Title
      ctx.font = '14px "JetBrains Mono"';
      ctx.fillStyle = '#9CA3AF';
      ctx.fillText('A ∪ B', width / 2, 30);
    }

    document.getElementById('chooseA').addEventListener('click', () => {
      unionChoice = 'A';
      document.getElementById('chooseA').classList.add('selected');
      document.getElementById('chooseB').classList.remove('selected');
      unionResult.className = 'union-result chosen';
      unionResult.textContent = 'You chose to construct from A. Element c ∈ A ∪ B comes with i(c) = iₐ(a) for your chosen a ∈ A.';
      drawUnion();
    });

    document.getElementById('chooseB').addEventListener('click', () => {
      unionChoice = 'B';
      document.getElementById('chooseB').classList.add('selected');
      document.getElementById('chooseA').classList.remove('selected');
      unionResult.className = 'union-result chosen';
      unionResult.textContent = 'You chose to construct from B. Element c ∈ A ∪ B comes with i(c) = i_B(b) for your chosen b ∈ B.';
      drawUnion();
    });

    // ============================================
    // INTERSECTION VISUALIZATION
    // ============================================
    
    const intersectionCanvas = document.getElementById('intersectionCanvas');
    const intersectionResult = document.getElementById('intersectionResult');
    let selectedA = null;
    let selectedB = null;

    // Define the mapping: which elements map to same point in S
    const mappingA = { a1: 's1', a2: 's2', a3: 's3' };
    const mappingB = { b1: 's2', b2: 's3', b3: 's4' };  // b1 and a2 both map to s2!

    function drawIntersection() {
      const { ctx, width, height } = setupCanvas(intersectionCanvas);

      ctx.fillStyle = '#FAFAFA';
      ctx.fillRect(0, 0, width, height);

      const setAx = width * 0.2;
      const setSx = width * 0.5;
      const setBx = width * 0.8;
      const centerY = height * 0.5;
      const radius = Math.min(width * 0.12, height * 0.3);

      // Draw set S (in middle)
      ctx.strokeStyle = '#4F46E5';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(setSx, centerY, radius * 1.3, radius * 1.2, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fillStyle = 'rgba(79, 70, 229, 0.05)';
      ctx.fill();

      // Draw set A
      ctx.strokeStyle = '#22C55E';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(setAx, centerY, radius, radius * 0.9, 0, 0, Math.PI * 2);
      ctx.stroke();

      // Draw set B
      ctx.strokeStyle = '#F97316';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(setBx, centerY, radius, radius * 0.9, 0, 0, Math.PI * 2);
      ctx.stroke();

      // Elements
      const posA = {
        a1: { x: setAx - 15, y: centerY - 25 },
        a2: { x: setAx + 10, y: centerY + 5 },
        a3: { x: setAx - 5, y: centerY + 30 }
      };

      const posB = {
        b1: { x: setBx + 15, y: centerY - 20 },
        b2: { x: setBx - 10, y: centerY + 10 },
        b3: { x: setBx + 5, y: centerY + 35 }
      };

      const posS = {
        s1: { x: setSx - 30, y: centerY - 35 },
        s2: { x: setSx + 25, y: centerY - 10 },
        s3: { x: setSx - 20, y: centerY + 25 },
        s4: { x: setSx + 30, y: centerY + 40 }
      };

      // Draw arrows from A to S
      ctx.strokeStyle = 'rgba(34, 197, 94, 0.4)';
      ctx.lineWidth = 1.5;
      Object.keys(posA).forEach(key => {
        const sKey = mappingA[key];
        ctx.beginPath();
        ctx.moveTo(posA[key].x + 10, posA[key].y);
        ctx.lineTo(posS[sKey].x - 10, posS[sKey].y);
        ctx.stroke();
      });

      // Draw arrows from B to S
      ctx.strokeStyle = 'rgba(249, 115, 22, 0.4)';
      Object.keys(posB).forEach(key => {
        const sKey = mappingB[key];
        ctx.beginPath();
        ctx.moveTo(posB[key].x - 10, posB[key].y);
        ctx.lineTo(posS[sKey].x + 10, posS[sKey].y);
        ctx.stroke();
      });

      // Draw elements in A
      Object.keys(posA).forEach(key => {
        const isSelected = selectedA === key;
        ctx.fillStyle = isSelected ? '#22C55E' : 'rgba(34, 197, 94, 0.6)';
        ctx.beginPath();
        ctx.arc(posA[key].x, posA[key].y, isSelected ? 8 : 6, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw elements in B
      Object.keys(posB).forEach(key => {
        const isSelected = selectedB === key;
        ctx.fillStyle = isSelected ? '#F97316' : 'rgba(249, 115, 22, 0.6)';
        ctx.beginPath();
        ctx.arc(posB[key].x, posB[key].y, isSelected ? 8 : 6, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw elements in S
      Object.keys(posS).forEach(key => {
        const isMatchA = selectedA && mappingA[selectedA] === key;
        const isMatchB = selectedB && mappingB[selectedB] === key;
        
        if (isMatchA && isMatchB) {
          ctx.fillStyle = '#22C55E';
          ctx.strokeStyle = '#F97316';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(posS[key].x, posS[key].y, 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        } else if (isMatchA) {
          ctx.fillStyle = 'rgba(34, 197, 94, 0.8)';
          ctx.beginPath();
          ctx.arc(posS[key].x, posS[key].y, 8, 0, Math.PI * 2);
          ctx.fill();
        } else if (isMatchB) {
          ctx.fillStyle = 'rgba(249, 115, 22, 0.8)';
          ctx.beginPath();
          ctx.arc(posS[key].x, posS[key].y, 8, 0, Math.PI * 2);
          ctx.fill();
        } else {
          ctx.fillStyle = 'rgba(79, 70, 229, 0.4)';
          ctx.beginPath();
          ctx.arc(posS[key].x, posS[key].y, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      });

      // Labels
      ctx.font = 'bold 14px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillStyle = '#22C55E';
      ctx.fillText('A', setAx, centerY + radius + 20);
      ctx.fillStyle = '#4F46E5';
      ctx.fillText('S', setSx, centerY + radius * 1.2 + 20);
      ctx.fillStyle = '#F97316';
      ctx.fillText('B', setBx, centerY + radius + 20);
    }

    function updateIntersectionResult() {
      if (!selectedA || !selectedB) {
        intersectionResult.className = 'intersection-result no-match';
        intersectionResult.innerHTML = 'Select elements from A and B to check if they match in S.';
        return;
      }

      const sA = mappingA[selectedA];
      const sB = mappingB[selectedB];

      if (sA === sB) {
        intersectionResult.className = 'intersection-result match';
        intersectionResult.innerHTML = `<strong>Match!</strong> iₐ(${selectedA}) = ${sA} = i_B(${selectedB})<br>This pair (${selectedA}, ${selectedB}) is in A ∩ B.`;
      } else {
        intersectionResult.className = 'intersection-result no-match';
        intersectionResult.innerHTML = `<strong>No match.</strong> iₐ(${selectedA}) = ${sA} ≠ ${sB} = i_B(${selectedB})<br>Try different elements to find a match.`;
      }
    }

    document.querySelectorAll('#aButtons .elem-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#aButtons .elem-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        selectedA = btn.dataset.elem;
        drawIntersection();
        updateIntersectionResult();
      });
    });

    document.querySelectorAll('#bButtons .elem-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('#bButtons .elem-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        selectedB = btn.dataset.elem;
        drawIntersection();
        updateIntersectionResult();
      });
    });

    // ============================================
    // DETACHABLE SUBSETS
    // ============================================
    
    const detachableCanvas = document.getElementById('detachableCanvas');
    let currentSubset = 'evens';

    const subsetData = {
      evens: {
        name: 'Even integers',
        detachable: true,
        decision: 'f(n) = (n mod 2 = 0) ? 1 : 0',
        elements: [2, 4, 6, 8, 10, 12, 14, 16],
        nonElements: [1, 3, 5, 7, 9, 11, 13, 15]
      },
      primes: {
        name: 'Prime numbers',
        detachable: true,
        decision: 'f(n) = isPrime(n) ? 1 : 0',
        elements: [2, 3, 5, 7, 11, 13],
        nonElements: [1, 4, 6, 8, 9, 10, 12, 14, 15]
      },
      halting: {
        name: 'Halting programs',
        detachable: false,
        decision: 'No computable decision function exists',
        elements: ['?', '?', '?'],
        nonElements: ['?', '?', '?']
      }
    };

    function drawDetachable() {
      const { ctx, width, height } = setupCanvas(detachableCanvas);
      const data = subsetData[currentSubset];

      ctx.fillStyle = '#0A0A0F';
      ctx.fillRect(0, 0, width, height);

      if (data.detachable) {
        // Draw decision machine
        const machineX = width / 2;
        const machineY = height / 2;
        const machineW = 120;
        const machineH = 80;

        ctx.fillStyle = 'rgba(139, 92, 246, 0.2)';
        ctx.fillRect(machineX - machineW/2, machineY - machineH/2, machineW, machineH);
        ctx.strokeStyle = '#8B5CF6';
        ctx.lineWidth = 2;
        ctx.strokeRect(machineX - machineW/2, machineY - machineH/2, machineW, machineH);

        ctx.fillStyle = '#8B5CF6';
        ctx.font = '14px "JetBrains Mono"';
        ctx.textAlign = 'center';
        ctx.fillText('Decision', machineX, machineY - 5);
        ctx.fillText('Machine', machineX, machineY + 15);

        // Input arrow
        ctx.strokeStyle = '#9CA3AF';
        ctx.beginPath();
        ctx.moveTo(machineX - machineW/2 - 60, machineY);
        ctx.lineTo(machineX - machineW/2 - 5, machineY);
        ctx.stroke();
        ctx.fillStyle = '#9CA3AF';
        ctx.font = '12px "JetBrains Mono"';
        ctx.textAlign = 'right';
        ctx.fillText('n', machineX - machineW/2 - 65, machineY + 4);

        // Output arrows
        ctx.strokeStyle = '#22C55E';
        ctx.beginPath();
        ctx.moveTo(machineX + machineW/2 + 5, machineY - 20);
        ctx.lineTo(machineX + machineW/2 + 60, machineY - 20);
        ctx.stroke();
        ctx.fillStyle = '#22C55E';
        ctx.textAlign = 'left';
        ctx.fillText('1 (∈ A)', machineX + machineW/2 + 65, machineY - 16);

        ctx.strokeStyle = '#EF4444';
        ctx.beginPath();
        ctx.moveTo(machineX + machineW/2 + 5, machineY + 20);
        ctx.lineTo(machineX + machineW/2 + 60, machineY + 20);
        ctx.stroke();
        ctx.fillStyle = '#EF4444';
        ctx.fillText('0 (∉ A)', machineX + machineW/2 + 65, machineY + 24);

        // Sample elements
        ctx.font = '11px "JetBrains Mono"';
        ctx.fillStyle = '#22C55E';
        ctx.textAlign = 'center';
        ctx.fillText('Elements: ' + data.elements.slice(0, 6).join(', ') + '...', width / 2, height - 40);

        ctx.fillStyle = '#EF4444';
        ctx.fillText('Non-elements: ' + data.nonElements.slice(0, 5).join(', ') + '...', width / 2, height - 20);

      } else {
        // Undecidable visualization
        ctx.fillStyle = 'rgba(107, 114, 128, 0.2)';
        ctx.fillRect(width/2 - 100, height/2 - 50, 200, 100);
        ctx.strokeStyle = '#6B7280';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(width/2 - 100, height/2 - 50, 200, 100);
        ctx.setLineDash([]);

        ctx.fillStyle = '#6B7280';
        ctx.font = '24px "JetBrains Mono"';
        ctx.textAlign = 'center';
        ctx.fillText('?', width/2, height/2 + 10);

        ctx.font = '12px "JetBrains Mono"';
        ctx.fillText('No decision procedure exists', width/2, height - 30);
      }

      // Update info cards
      document.getElementById('decidableStatus').textContent = data.detachable ? 'Yes' : 'No';
      document.getElementById('decidableStatus').className = 'info-value ' + (data.detachable ? 'yes' : 'no');
      document.getElementById('decisionFunction').textContent = data.decision;
      document.getElementById('decisionFunction').style.color = data.detachable ? '#8B5CF6' : '#6B7280';
    }

    document.querySelectorAll('.subset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.subset-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentSubset = btn.dataset.subset;
        drawDetachable();
      });
    });

    // Initialize
    drawInclusion();
    drawUnion();
    drawIntersection();
    drawDetachable();

    window.addEventListener('resize', () => {
      drawInclusion();
      drawUnion();
      drawIntersection();
      drawDetachable();
    });
  </script>
</body>
</html>
