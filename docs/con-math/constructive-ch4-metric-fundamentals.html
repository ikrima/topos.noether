<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Metric Space Fundamentals — Chapter 4</title>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Source+Sans+Pro:wght@300;400;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --metric-primary: #0EA5E9;
      --sphere-color: #22C55E;
      --triangle-color: #F59E0B;
      --point-color: #EC4899;
      --background: #FAF8F5;
      --background-dark: #0F0F12;
      --ink: #1A1A1A;
      --ink-light: #FAF8F5;
      
      --display: 'Crimson Text', serif;
      --body: 'Source Sans Pro', sans-serif;
      --mono: 'JetBrains Mono', monospace;
      
      --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body {
      font-family: var(--body);
      background: var(--background);
      color: var(--ink);
      line-height: 1.7;
      overflow-x: hidden;
    }

    /* Opening */
    .opening {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      background: linear-gradient(180deg, var(--metric-primary) 0%, #0284C7 100%);
      color: var(--ink-light);
      position: relative;
    }

    .opening-content {
      text-align: center;
      max-width: 800px;
    }

    .chapter-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.7);
      margin-bottom: 0.5rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.2s forwards;
    }

    .section-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.9);
      margin-bottom: 1rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.3s forwards;
    }

    .main-title {
      font-family: var(--display);
      font-size: clamp(2rem, 6vw, 3.5rem);
      font-weight: 400;
      line-height: 1.2;
      margin-bottom: 1.5rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.4s forwards;
    }

    .subtitle {
      font-size: 1.15rem;
      color: rgba(255, 255, 255, 0.9);
      max-width: 600px;
      margin: 0 auto;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.6s forwards;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Narrative */
    .narrative-section {
      min-height: 60vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4rem 2rem;
    }

    .narrative-section.dark {
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .narrative-content {
      max-width: 650px;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.8s var(--ease-out-expo), transform 0.8s var(--ease-out-expo);
    }

    .narrative-content.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .narrative-content p {
      font-size: 1.2rem;
      margin-bottom: 1.5rem;
    }

    .math-display {
      font-family: var(--mono);
      font-size: 0.95rem;
      background: rgba(14, 165, 233, 0.1);
      padding: 1.5rem;
      border-radius: 8px;
      text-align: center;
      margin: 1.5rem 0;
      border-left: 3px solid var(--metric-primary);
    }

    .dark .math-display {
      background: rgba(14, 165, 233, 0.15);
    }

    /* Section headers */
    .section-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .section-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .section-subtitle {
      color: #666;
      font-size: 1rem;
      max-width: 600px;
      margin: 0 auto;
    }

    /* Interactive Metric Section */
    .metric-section {
      padding: 4rem 2rem;
      background: linear-gradient(180deg, #F5F3F0 0%, var(--background) 100%);
    }

    .metric-container {
      max-width: 1000px;
      margin: 0 auto;
    }

    .metric-panel {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.08);
      padding: 2rem;
    }

    .metric-canvas-container {
      height: 400px;
      background: #FAFAFA;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      position: relative;
      cursor: crosshair;
    }

    #metricCanvas {
      width: 100%;
      height: 100%;
    }

    .metric-info {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
    }

    @media (max-width: 700px) {
      .metric-info { grid-template-columns: 1fr; }
    }

    .info-card {
      background: #FAFAFA;
      padding: 1.2rem;
      border-radius: 10px;
      text-align: center;
    }

    .info-label {
      font-family: var(--mono);
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #666;
      margin-bottom: 0.3rem;
    }

    .info-value {
      font-family: var(--mono);
      font-size: 1.1rem;
      color: var(--metric-primary);
    }

    .instructions {
      text-align: center;
      padding: 1rem;
      background: rgba(14, 165, 233, 0.1);
      border-radius: 8px;
      margin-top: 1rem;
      font-size: 0.9rem;
      color: #666;
    }

    /* Triangle Inequality Section */
    .triangle-section {
      min-height: 100vh;
      padding: 4rem 2rem;
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .triangle-container {
      max-width: 1000px;
      margin: 0 auto;
    }

    .triangle-panel {
      background: rgba(30, 30, 40, 0.5);
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 16px;
      padding: 2rem;
    }

    .triangle-canvas-container {
      height: 350px;
      margin-bottom: 1.5rem;
    }

    #triangleCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #0A0A0F;
    }

    .triangle-info {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 1rem;
    }

    @media (max-width: 800px) {
      .triangle-info { grid-template-columns: repeat(2, 1fr); }
    }

    .triangle-card {
      background: rgba(20, 20, 30, 0.5);
      padding: 1rem;
      border-radius: 10px;
      text-align: center;
    }

    .triangle-card.highlight {
      border: 2px solid var(--triangle-color);
      background: rgba(245, 158, 11, 0.1);
    }

    .triangle-label {
      font-family: var(--mono);
      font-size: 0.6rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #9CA3AF;
      margin-bottom: 0.3rem;
    }

    .triangle-value {
      font-family: var(--mono);
      font-size: 1rem;
    }

    .satisfied { color: var(--sphere-color); }
    .checking { color: var(--triangle-color); }

    /* Open Sphere Section */
    .sphere-section {
      padding: 4rem 2rem;
      background: var(--background);
    }

    .sphere-container {
      max-width: 1000px;
      margin: 0 auto;
    }

    .sphere-panel {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.08);
      padding: 2rem;
    }

    .sphere-canvas-container {
      height: 350px;
      background: #FAFAFA;
      border-radius: 12px;
      margin-bottom: 1.5rem;
    }

    #sphereCanvas {
      width: 100%;
      height: 100%;
    }

    .sphere-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 2rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    .control-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #666;
    }

    .slider-container {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    input[type="range"] {
      width: 150px;
      accent-color: var(--sphere-color);
    }

    .slider-value {
      font-family: var(--mono);
      font-size: 0.9rem;
      min-width: 50px;
      color: var(--sphere-color);
    }

    .sphere-explanation {
      background: rgba(34, 197, 94, 0.1);
      padding: 1.5rem;
      border-radius: 12px;
      border-left: 3px solid var(--sphere-color);
    }

    .sphere-explanation p {
      font-size: 0.95rem;
      margin-bottom: 0.5rem;
    }

    .sphere-explanation p:last-child {
      margin-bottom: 0;
    }

    /* Product Metric Section */
    .product-section {
      min-height: 80vh;
      padding: 4rem 2rem;
      background: linear-gradient(180deg, #1A1A20 0%, var(--background-dark) 100%);
      color: var(--ink-light);
    }

    .product-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .product-panel {
      background: rgba(30, 30, 40, 0.5);
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 16px;
      padding: 2rem;
    }

    .product-canvas-container {
      height: 300px;
      margin-bottom: 1.5rem;
    }

    #productCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #0A0A0F;
    }

    .product-controls {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }

    .metric-btn {
      padding: 0.8rem 1.5rem;
      border: 2px solid var(--metric-primary);
      border-radius: 8px;
      background: transparent;
      color: var(--metric-primary);
      font-family: var(--mono);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .metric-btn:hover {
      background: rgba(14, 165, 233, 0.2);
    }

    .metric-btn.active {
      background: var(--metric-primary);
      color: white;
    }

    .product-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }

    @media (max-width: 600px) {
      .product-info { grid-template-columns: 1fr; }
    }

    /* Navigation */
    .next-section {
      padding: 4rem 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, var(--metric-primary) 0%, #0284C7 100%);
      color: var(--ink-light);
      text-align: center;
    }

    .next-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.7);
      margin-bottom: 1rem;
    }

    .next-title {
      font-family: var(--display);
      font-size: 1.6rem;
      margin-bottom: 0.5rem;
    }

    .next-description {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.9);
      max-width: 500px;
    }
  </style>
</head>
<body>

  <!-- Opening -->
  <section class="opening">
    <div class="opening-content">
      <p class="chapter-label">Chapter 4: Metric Spaces</p>
      <p class="section-label">Section 1: Fundamental Definitions</p>
      <h1 class="main-title">The Geometry of Distance</h1>
      <p class="subtitle">A metric quantifies proximity. But constructively, distance isn't just measured—it's computed.</p>
    </div>
  </section>

  <!-- Narrative: What is a Metric? -->
  <section class="narrative-section">
    <div class="narrative-content" data-animate>
      <p>A <strong>metric</strong> is a function ρ: X × X → ℝ⁺ that measures distance between points. It must satisfy three axioms:</p>
      <div class="math-display">
        <strong>Definition 1.1:</strong><br><br>
        (1) ρ(x, y) = 0 ⟺ x = y &nbsp;<em>(identity)</em><br>
        (2) ρ(x, y) = ρ(y, x) &nbsp;<em>(symmetry)</em><br>
        (3) ρ(x, y) ≤ ρ(x, z) + ρ(z, y) &nbsp;<em>(triangle inequality)</em>
      </div>
      <p>The triangle inequality is the crucial constraint. It says: the direct path is never longer than going through an intermediate point.</p>
    </div>
  </section>

  <!-- Interactive Metric Visualization -->
  <section class="metric-section">
    <div class="section-header">
      <h2 class="section-title">Interactive Distance</h2>
      <p class="section-subtitle">Drag points to explore distance in ℝ²</p>
    </div>

    <div class="metric-container">
      <div class="metric-panel">
        <div class="metric-canvas-container" id="metricCanvasContainer">
          <canvas id="metricCanvas"></canvas>
        </div>

        <div class="metric-info">
          <div class="info-card">
            <p class="info-label">Point X</p>
            <p class="info-value" id="pointX">(0.00, 0.00)</p>
          </div>
          <div class="info-card">
            <p class="info-label">Point Y</p>
            <p class="info-value" id="pointY">(0.00, 0.00)</p>
          </div>
          <div class="info-card">
            <p class="info-label">Distance ρ(x, y)</p>
            <p class="info-value" id="distanceXY">0.00</p>
          </div>
        </div>

        <div class="instructions">
          Click and drag the points to move them. The Euclidean distance updates in real-time.
        </div>
      </div>
    </div>
  </section>

  <!-- Triangle Inequality -->
  <section class="triangle-section">
    <div class="section-header" style="color: var(--ink-light);">
      <h2 class="section-title">The Triangle Inequality</h2>
      <p class="section-subtitle" style="color: #9CA3AF;">ρ(x, y) ≤ ρ(x, z) + ρ(z, y) — the direct path is never longer</p>
    </div>

    <div class="triangle-container">
      <div class="triangle-panel">
        <div class="triangle-canvas-container">
          <canvas id="triangleCanvas"></canvas>
        </div>

        <div class="triangle-info">
          <div class="triangle-card">
            <p class="triangle-label">ρ(x, y)</p>
            <p class="triangle-value" id="triXY" style="color: var(--point-color);">0.00</p>
          </div>
          <div class="triangle-card">
            <p class="triangle-label">ρ(x, z)</p>
            <p class="triangle-value" id="triXZ" style="color: var(--metric-primary);">0.00</p>
          </div>
          <div class="triangle-card">
            <p class="triangle-label">ρ(z, y)</p>
            <p class="triangle-value" id="triZY" style="color: var(--sphere-color);">0.00</p>
          </div>
          <div class="triangle-card highlight">
            <p class="triangle-label">ρ(x,z) + ρ(z,y)</p>
            <p class="triangle-value checking" id="triSum">0.00</p>
          </div>
        </div>

        <div class="instructions" style="background: rgba(245, 158, 11, 0.15); margin-top: 1rem;">
          <span id="triangleStatus" style="color: var(--sphere-color);">✓ Triangle inequality satisfied: ρ(x,y) ≤ ρ(x,z) + ρ(z,y)</span>
        </div>
      </div>
    </div>
  </section>

  <!-- Open Spheres -->
  <section class="sphere-section">
    <div class="section-header">
      <h2 class="section-title">Open Spheres</h2>
      <p class="section-subtitle">S(x, r) = { y ∈ X : ρ(x, y) < r }</p>
    </div>

    <div class="sphere-container">
      <div class="sphere-panel">
        <div class="sphere-canvas-container">
          <canvas id="sphereCanvas"></canvas>
        </div>

        <div class="sphere-controls">
          <div class="control-group">
            <span class="control-label">Radius r</span>
            <div class="slider-container">
              <input type="range" id="radiusSlider" min="0.1" max="2" step="0.05" value="0.8">
              <span class="slider-value" id="radiusValue">0.80</span>
            </div>
          </div>
        </div>

        <div class="sphere-explanation">
          <p><strong>Definition 2.1:</strong> The open sphere S(x, r) consists of all points y with ρ(x, y) < r (strictly less than).</p>
          <p>The <em>boundary</em> consists of points at distance exactly r. The <em>closed sphere</em> Sᶜ(x, r) includes the boundary: ρ(x, y) ≤ r.</p>
          <p>Open spheres form the <strong>neighborhood structure</strong> of a metric space.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Product Metrics -->
  <section class="product-section">
    <div class="section-header" style="color: var(--ink-light);">
      <h2 class="section-title">Product Metrics on ℝⁿ</h2>
      <p class="section-subtitle" style="color: #9CA3AF;">Different metrics give different "shapes" to spheres</p>
    </div>

    <div class="product-container">
      <div class="product-panel">
        <div class="product-canvas-container">
          <canvas id="productCanvas"></canvas>
        </div>

        <div class="product-controls">
          <button class="metric-btn active" data-metric="euclidean">Euclidean (L²)</button>
          <button class="metric-btn" data-metric="taxicab">Taxicab (L¹)</button>
          <button class="metric-btn" data-metric="chebyshev">Chebyshev (L∞)</button>
        </div>

        <div class="product-info">
          <div class="info-card" style="background: rgba(20, 20, 30, 0.5);">
            <p class="info-label" style="color: #9CA3AF;">Formula</p>
            <p class="info-value" id="metricFormula" style="font-size: 0.85rem;">√(Σ(xᵢ - yᵢ)²)</p>
          </div>
          <div class="info-card" style="background: rgba(20, 20, 30, 0.5);">
            <p class="info-label" style="color: #9CA3AF;">Unit Sphere Shape</p>
            <p class="info-value" id="sphereShape" style="font-size: 0.85rem;">Circle</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Narrative: Uniform Continuity -->
  <section class="narrative-section dark">
    <div class="narrative-content" data-animate>
      <p>A function f: X → X' between metric spaces is <strong>uniformly continuous</strong> if:</p>
      <div class="math-display">
        ∃ω: ℝ⁺ → ℝ⁺ such that<br>
        ρ(x, y) ≤ ω(ε) ⟹ ρ'(f(x), f(y)) ≤ ε
      </div>
      <p>The function ω is the <strong>modulus of continuity</strong>. It tells you how close inputs must be to guarantee outputs within ε.</p>
      <p>This is the constructive content: ω is computable.</p>
    </div>
  </section>

  <!-- Navigation -->
  <section class="next-section">
    <p class="next-label">Coming Next</p>
    <h3 class="next-title">Located Sets & The Metric Complement</h3>
    <p class="next-description">Not every set has a well-defined distance. The concept of "locatedness" is essential for constructive analysis.</p>
  </section>

  <script>
    // Scroll animations
    const observerOptions = { threshold: 0.3, rootMargin: '0px 0px -10% 0px' };
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) entry.target.classList.add('visible');
      });
    }, observerOptions);
    document.querySelectorAll('[data-animate], .narrative-content').forEach(el => observer.observe(el));

    function setupCanvas(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      return { ctx, width: rect.width, height: rect.height };
    }

    // ============================================
    // INTERACTIVE METRIC VISUALIZATION
    // ============================================
    
    const metricCanvas = document.getElementById('metricCanvas');
    const metricContainer = document.getElementById('metricCanvasContainer');
    
    let pointX = { x: 150, y: 200 };
    let pointY = { x: 350, y: 150 };
    let dragging = null;

    function drawMetric() {
      const { ctx, width, height } = setupCanvas(metricCanvas);

      ctx.fillStyle = '#FAFAFA';
      ctx.fillRect(0, 0, width, height);

      // Grid
      ctx.strokeStyle = '#E5E5E5';
      ctx.lineWidth = 1;
      const gridSize = 50;
      for (let x = 0; x <= width; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = 0; y <= height; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      // Distance line
      ctx.strokeStyle = var(--metric-primary);
      ctx.strokeStyle = '#0EA5E9';
      ctx.lineWidth = 3;
      ctx.setLineDash([8, 4]);
      ctx.beginPath();
      ctx.moveTo(pointX.x, pointX.y);
      ctx.lineTo(pointY.x, pointY.y);
      ctx.stroke();
      ctx.setLineDash([]);

      // Distance label
      const midX = (pointX.x + pointY.x) / 2;
      const midY = (pointX.y + pointY.y) / 2;
      const dist = Math.sqrt(Math.pow(pointX.x - pointY.x, 2) + Math.pow(pointX.y - pointY.y, 2));
      
      ctx.fillStyle = '#0EA5E9';
      ctx.font = 'bold 14px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillText(`ρ = ${(dist / 50).toFixed(2)}`, midX, midY - 15);

      // Point X
      ctx.fillStyle = '#EC4899';
      ctx.beginPath();
      ctx.arc(pointX.x, pointX.y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.font = 'bold 12px "JetBrains Mono"';
      ctx.fillText('x', pointX.x, pointX.y + 4);

      // Point Y
      ctx.fillStyle = '#22C55E';
      ctx.beginPath();
      ctx.arc(pointY.x, pointY.y, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.fillText('y', pointY.x, pointY.y + 4);

      // Update info
      document.getElementById('pointX').textContent = `(${(pointX.x / 50).toFixed(2)}, ${((height - pointX.y) / 50).toFixed(2)})`;
      document.getElementById('pointY').textContent = `(${(pointY.x / 50).toFixed(2)}, ${((height - pointY.y) / 50).toFixed(2)})`;
      document.getElementById('distanceXY').textContent = (dist / 50).toFixed(2);
    }

    metricContainer.addEventListener('mousedown', (e) => {
      const rect = metricCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      const distToX = Math.sqrt(Math.pow(mx - pointX.x, 2) + Math.pow(my - pointX.y, 2));
      const distToY = Math.sqrt(Math.pow(mx - pointY.x, 2) + Math.pow(my - pointY.y, 2));

      if (distToX < 20) dragging = 'X';
      else if (distToY < 20) dragging = 'Y';
    });

    metricContainer.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const rect = metricCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      if (dragging === 'X') {
        pointX.x = Math.max(20, Math.min(rect.width - 20, mx));
        pointX.y = Math.max(20, Math.min(rect.height - 20, my));
      } else {
        pointY.x = Math.max(20, Math.min(rect.width - 20, mx));
        pointY.y = Math.max(20, Math.min(rect.height - 20, my));
      }
      drawMetric();
    });

    metricContainer.addEventListener('mouseup', () => { dragging = null; });
    metricContainer.addEventListener('mouseleave', () => { dragging = null; });

    // ============================================
    // TRIANGLE INEQUALITY
    // ============================================
    
    const triangleCanvas = document.getElementById('triangleCanvas');
    let triPoints = {
      x: { x: 100, y: 250 },
      y: { x: 400, y: 250 },
      z: { x: 250, y: 100 }
    };
    let triDragging = null;

    function drawTriangle() {
      const { ctx, width, height } = setupCanvas(triangleCanvas);

      ctx.fillStyle = '#0A0A0F';
      ctx.fillRect(0, 0, width, height);

      const x = triPoints.x;
      const y = triPoints.y;
      const z = triPoints.z;

      // Calculate distances
      const dXY = Math.sqrt(Math.pow(x.x - y.x, 2) + Math.pow(x.y - y.y, 2));
      const dXZ = Math.sqrt(Math.pow(x.x - z.x, 2) + Math.pow(x.y - z.y, 2));
      const dZY = Math.sqrt(Math.pow(z.x - y.x, 2) + Math.pow(z.y - y.y, 2));

      // Draw edges
      // x-y (direct)
      ctx.strokeStyle = '#EC4899';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x.x, x.y);
      ctx.lineTo(y.x, y.y);
      ctx.stroke();

      // x-z
      ctx.strokeStyle = '#0EA5E9';
      ctx.beginPath();
      ctx.moveTo(x.x, x.y);
      ctx.lineTo(z.x, z.y);
      ctx.stroke();

      // z-y
      ctx.strokeStyle = '#22C55E';
      ctx.beginPath();
      ctx.moveTo(z.x, z.y);
      ctx.lineTo(y.x, y.y);
      ctx.stroke();

      // Points
      ctx.fillStyle = '#EC4899';
      ctx.beginPath();
      ctx.arc(x.x, x.y, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.font = 'bold 11px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillText('x', x.x, x.y + 4);

      ctx.fillStyle = '#22C55E';
      ctx.beginPath();
      ctx.arc(y.x, y.y, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.fillText('y', y.x, y.y + 4);

      ctx.fillStyle = '#F59E0B';
      ctx.beginPath();
      ctx.arc(z.x, z.y, 10, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.fillText('z', z.x, z.y + 4);

      // Update info
      const scale = 100;
      document.getElementById('triXY').textContent = (dXY / scale).toFixed(2);
      document.getElementById('triXZ').textContent = (dXZ / scale).toFixed(2);
      document.getElementById('triZY').textContent = (dZY / scale).toFixed(2);
      document.getElementById('triSum').textContent = ((dXZ + dZY) / scale).toFixed(2);

      const satisfied = dXY <= dXZ + dZY + 0.001;
      document.getElementById('triangleStatus').textContent = satisfied 
        ? '✓ Triangle inequality satisfied: ρ(x,y) ≤ ρ(x,z) + ρ(z,y)'
        : '⚠ Checking...';
      document.getElementById('triangleStatus').style.color = satisfied ? '#22C55E' : '#F59E0B';
    }

    triangleCanvas.addEventListener('mousedown', (e) => {
      const rect = triangleCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;

      for (const [key, pt] of Object.entries(triPoints)) {
        if (Math.sqrt(Math.pow(mx - pt.x, 2) + Math.pow(my - pt.y, 2)) < 20) {
          triDragging = key;
          break;
        }
      }
    });

    triangleCanvas.addEventListener('mousemove', (e) => {
      if (!triDragging) return;
      const rect = triangleCanvas.getBoundingClientRect();
      triPoints[triDragging].x = Math.max(20, Math.min(rect.width - 20, e.clientX - rect.left));
      triPoints[triDragging].y = Math.max(20, Math.min(rect.height - 20, e.clientY - rect.top));
      drawTriangle();
    });

    triangleCanvas.addEventListener('mouseup', () => { triDragging = null; });
    triangleCanvas.addEventListener('mouseleave', () => { triDragging = null; });

    // ============================================
    // OPEN SPHERES
    // ============================================
    
    const sphereCanvas = document.getElementById('sphereCanvas');
    const radiusSlider = document.getElementById('radiusSlider');
    let sphereRadius = 0.8;

    function drawSphere() {
      const { ctx, width, height } = setupCanvas(sphereCanvas);

      ctx.fillStyle = '#FAFAFA';
      ctx.fillRect(0, 0, width, height);

      const centerX = width / 2;
      const centerY = height / 2;
      const scale = 100;
      const r = sphereRadius * scale;

      // Grid
      ctx.strokeStyle = '#E5E5E5';
      ctx.lineWidth = 1;
      for (let x = centerX % 50; x <= width; x += 50) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      for (let y = centerY % 50; y <= height; y += 50) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      // Open sphere (filled)
      ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
      ctx.beginPath();
      ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
      ctx.fill();

      // Boundary (dashed - not included)
      ctx.strokeStyle = '#22C55E';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      ctx.beginPath();
      ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);

      // Center point
      ctx.fillStyle = '#EC4899';
      ctx.beginPath();
      ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = 'white';
      ctx.font = 'bold 10px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillText('x', centerX, centerY + 3);

      // Radius line
      ctx.strokeStyle = '#22C55E';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(centerX, centerY);
      ctx.lineTo(centerX + r, centerY);
      ctx.stroke();

      // Radius label
      ctx.fillStyle = '#22C55E';
      ctx.font = '12px "JetBrains Mono"';
      ctx.fillText(`r = ${sphereRadius.toFixed(2)}`, centerX + r / 2, centerY - 10);

      // Label
      ctx.fillStyle = '#666';
      ctx.font = '14px "JetBrains Mono"';
      ctx.fillText('S(x, r)', centerX, centerY + r + 25);
      ctx.font = '11px "JetBrains Mono"';
      ctx.fillText('(boundary not included)', centerX, centerY + r + 45);
    }

    radiusSlider.addEventListener('input', (e) => {
      sphereRadius = parseFloat(e.target.value);
      document.getElementById('radiusValue').textContent = sphereRadius.toFixed(2);
      drawSphere();
    });

    // ============================================
    // PRODUCT METRICS
    // ============================================
    
    const productCanvas = document.getElementById('productCanvas');
    let currentMetric = 'euclidean';

    const metricInfo = {
      euclidean: { formula: '√(Σ(xᵢ - yᵢ)²)', shape: 'Circle' },
      taxicab: { formula: 'Σ|xᵢ - yᵢ|', shape: 'Diamond' },
      chebyshev: { formula: 'max|xᵢ - yᵢ|', shape: 'Square' }
    };

    function drawProduct() {
      const { ctx, width, height } = setupCanvas(productCanvas);

      ctx.fillStyle = '#0A0A0F';
      ctx.fillRect(0, 0, width, height);

      const centerX = width / 2;
      const centerY = height / 2;
      const r = 80;

      // Axes
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, centerY);
      ctx.lineTo(width, centerY);
      ctx.moveTo(centerX, 0);
      ctx.lineTo(centerX, height);
      ctx.stroke();

      // Unit sphere
      ctx.strokeStyle = '#0EA5E9';
      ctx.lineWidth = 3;
      ctx.fillStyle = 'rgba(14, 165, 233, 0.15)';

      if (currentMetric === 'euclidean') {
        ctx.beginPath();
        ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      } else if (currentMetric === 'taxicab') {
        ctx.beginPath();
        ctx.moveTo(centerX, centerY - r);
        ctx.lineTo(centerX + r, centerY);
        ctx.lineTo(centerX, centerY + r);
        ctx.lineTo(centerX - r, centerY);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      } else if (currentMetric === 'chebyshev') {
        ctx.beginPath();
        ctx.rect(centerX - r, centerY - r, r * 2, r * 2);
        ctx.fill();
        ctx.stroke();
      }

      // Center point
      ctx.fillStyle = '#EC4899';
      ctx.beginPath();
      ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
      ctx.fill();

      // Label
      ctx.fillStyle = '#9CA3AF';
      ctx.font = '12px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillText('Unit sphere: { y : ρ(0, y) = 1 }', centerX, height - 20);

      // Update info
      document.getElementById('metricFormula').textContent = metricInfo[currentMetric].formula;
      document.getElementById('sphereShape').textContent = metricInfo[currentMetric].shape;
    }

    document.querySelectorAll('.metric-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.metric-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentMetric = btn.dataset.metric;
        drawProduct();
      });
    });

    // Initialize all
    drawMetric();
    drawTriangle();
    drawSphere();
    drawProduct();

    window.addEventListener('resize', () => {
      drawMetric();
      drawTriangle();
      drawSphere();
      drawProduct();
    });
  </script>
</body>
</html>
