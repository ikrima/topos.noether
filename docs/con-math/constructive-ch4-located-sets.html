<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Located Sets & Metric Complement — Chapter 4</title>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Source+Sans+Pro:wght@300;400;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --metric-primary: #0EA5E9;
      --located-color: #F59E0B;
      --complement-color: #8B5CF6;
      --positive-color: #22C55E;
      --negative-color: #EF4444;
      --fog-color: #6B7280;
      --background: #FAF8F5;
      --background-dark: #0F0F12;
      --ink: #1A1A1A;
      --ink-light: #FAF8F5;
      
      --display: 'Crimson Text', serif;
      --body: 'Source Sans Pro', sans-serif;
      --mono: 'JetBrains Mono', monospace;
      
      --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body {
      font-family: var(--body);
      background: var(--background);
      color: var(--ink);
      line-height: 1.7;
      overflow-x: hidden;
    }

    /* Opening */
    .opening {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      background: linear-gradient(180deg, var(--located-color) 0%, #D97706 100%);
      color: var(--ink-light);
      position: relative;
    }

    .opening-content {
      text-align: center;
      max-width: 800px;
    }

    .chapter-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.7);
      margin-bottom: 0.5rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.2s forwards;
    }

    .section-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.9);
      margin-bottom: 1rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.3s forwards;
    }

    .main-title {
      font-family: var(--display);
      font-size: clamp(2rem, 6vw, 3.5rem);
      font-weight: 400;
      line-height: 1.2;
      margin-bottom: 1.5rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.4s forwards;
    }

    .subtitle {
      font-size: 1.15rem;
      color: rgba(255, 255, 255, 0.9);
      max-width: 600px;
      margin: 0 auto;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.6s forwards;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Narrative */
    .narrative-section {
      min-height: 60vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4rem 2rem;
    }

    .narrative-section.dark {
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .narrative-content {
      max-width: 650px;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.8s var(--ease-out-expo), transform 0.8s var(--ease-out-expo);
    }

    .narrative-content.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .narrative-content p {
      font-size: 1.2rem;
      margin-bottom: 1.5rem;
    }

    .math-display {
      font-family: var(--mono);
      font-size: 0.95rem;
      background: rgba(245, 158, 11, 0.1);
      padding: 1.5rem;
      border-radius: 8px;
      text-align: center;
      margin: 1.5rem 0;
      border-left: 3px solid var(--located-color);
    }

    .dark .math-display {
      background: rgba(245, 158, 11, 0.15);
    }

    /* Section headers */
    .section-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .section-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .section-subtitle {
      color: #666;
      font-size: 1rem;
      max-width: 600px;
      margin: 0 auto;
    }

    /* Located Sets Section */
    .located-section {
      padding: 4rem 2rem;
      background: linear-gradient(180deg, #F5F3F0 0%, var(--background) 100%);
    }

    .located-container {
      max-width: 1000px;
      margin: 0 auto;
    }

    .located-panel {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.08);
      padding: 2rem;
    }

    .located-canvas-container {
      height: 350px;
      background: #FAFAFA;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      cursor: crosshair;
    }

    #locatedCanvas {
      width: 100%;
      height: 100%;
    }

    .located-controls {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }

    .set-btn {
      padding: 0.8rem 1.2rem;
      border: 2px solid var(--located-color);
      border-radius: 8px;
      background: transparent;
      color: var(--located-color);
      font-family: var(--mono);
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .set-btn:hover {
      background: rgba(245, 158, 11, 0.15);
    }

    .set-btn.active {
      background: var(--located-color);
      color: white;
    }

    .located-info {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
    }

    @media (max-width: 700px) {
      .located-info { grid-template-columns: 1fr; }
    }

    .info-card {
      background: #FAFAFA;
      padding: 1.2rem;
      border-radius: 10px;
      text-align: center;
    }

    .info-label {
      font-family: var(--mono);
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #666;
      margin-bottom: 0.3rem;
    }

    .info-value {
      font-family: var(--mono);
      font-size: 1rem;
    }

    .info-value.yes { color: var(--positive-color); }
    .info-value.no { color: var(--negative-color); }
    .info-value.unknown { color: var(--fog-color); }

    /* Metric Complement Section */
    .complement-section {
      min-height: 100vh;
      padding: 4rem 2rem;
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .complement-container {
      max-width: 1000px;
      margin: 0 auto;
    }

    .complement-panel {
      background: rgba(30, 30, 40, 0.5);
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 16px;
      padding: 2rem;
    }

    .complement-canvas-container {
      height: 350px;
      margin-bottom: 1.5rem;
    }

    #complementCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #0A0A0F;
    }

    .complement-explanation {
      background: rgba(139, 92, 246, 0.1);
      padding: 1.5rem;
      border-radius: 12px;
      border-left: 3px solid var(--complement-color);
      margin-bottom: 1.5rem;
    }

    .complement-explanation p {
      font-size: 0.95rem;
      margin-bottom: 0.8rem;
    }

    .complement-explanation p:last-child {
      margin-bottom: 0;
    }

    .complement-info {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
    }

    @media (max-width: 700px) {
      .complement-info { grid-template-columns: 1fr; }
    }

    .complement-card {
      background: rgba(20, 20, 30, 0.5);
      padding: 1.2rem;
      border-radius: 10px;
      text-align: center;
    }

    .complement-label {
      font-family: var(--mono);
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #9CA3AF;
      margin-bottom: 0.3rem;
    }

    .complement-value {
      font-family: var(--mono);
      font-size: 0.95rem;
    }

    /* Distance Calculator Section */
    .distance-section {
      padding: 4rem 2rem;
      background: var(--background);
    }

    .distance-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .distance-panel {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.08);
      padding: 2rem;
    }

    .distance-canvas-container {
      height: 300px;
      background: #FAFAFA;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      cursor: crosshair;
    }

    #distanceCanvas {
      width: 100%;
      height: 100%;
    }

    .distance-result {
      text-align: center;
      padding: 1.5rem;
      border-radius: 12px;
      margin-bottom: 1rem;
    }

    .distance-result.computed {
      background: rgba(34, 197, 94, 0.1);
      border: 2px solid var(--positive-color);
    }

    .distance-result.undefined {
      background: rgba(107, 114, 128, 0.1);
      border: 2px solid var(--fog-color);
    }

    .distance-formula {
      font-family: var(--mono);
      font-size: 1.1rem;
      margin-bottom: 0.5rem;
    }

    .distance-note {
      font-size: 0.9rem;
      color: #666;
    }

    /* Navigation */
    .next-section {
      padding: 4rem 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, var(--located-color) 0%, #D97706 100%);
      color: var(--ink-light);
      text-align: center;
    }

    .next-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: rgba(255,255,255,0.7);
      margin-bottom: 1rem;
    }

    .next-title {
      font-family: var(--display);
      font-size: 1.6rem;
      margin-bottom: 0.5rem;
    }

    .next-description {
      font-size: 1rem;
      color: rgba(255, 255, 255, 0.9);
      max-width: 500px;
    }
  </style>
</head>
<body>

  <!-- Opening -->
  <section class="opening">
    <div class="opening-content">
      <p class="chapter-label">Chapter 4: Metric Spaces</p>
      <p class="section-label">Section 2: Associated Structures</p>
      <h1 class="main-title">Located Sets & The Metric Complement</h1>
      <p class="subtitle">Not every set has a computable distance. "Locatedness" is a constructive requirement for sets to behave well.</p>
    </div>
  </section>

  <!-- Narrative: The Problem -->
  <section class="narrative-section">
    <div class="narrative-content" data-animate>
      <p>Given a point x and a set A, what is the distance from x to A?</p>
      <div class="math-display">
        ρ(x, A) = inf { ρ(x, y) : y ∈ A }
      </div>
      <p>This infimum may not exist constructively! Without a way to compute the greatest lower bound, ρ(x, A) is undefined.</p>
      <p>A set A is <strong>located</strong> if ρ(x, A) exists for every x in X.</p>
    </div>
  </section>

  <!-- Located Sets -->
  <section class="located-section">
    <div class="section-header">
      <h2 class="section-title">Located vs Non-Located Sets</h2>
      <p class="section-subtitle">Click to place a point and compute distance to the set</p>
    </div>

    <div class="located-container">
      <div class="located-panel">
        <div class="located-canvas-container" id="locatedCanvasContainer">
          <canvas id="locatedCanvas"></canvas>
        </div>

        <div class="located-controls">
          <button class="set-btn active" data-set="interval">Interval [0, 1] (located)</button>
          <button class="set-btn" data-set="rationals">Rationals ℚ (located)</button>
          <button class="set-btn" data-set="fuzzy">Fuzzy set (not located)</button>
        </div>

        <div class="located-info">
          <div class="info-card">
            <p class="info-label">Set A</p>
            <p class="info-value" id="setDescription" style="color: var(--located-color);">[0, 1]</p>
          </div>
          <div class="info-card">
            <p class="info-label">Located?</p>
            <p class="info-value yes" id="isLocated">Yes</p>
          </div>
          <div class="info-card">
            <p class="info-label">ρ(x, A)</p>
            <p class="info-value" id="distanceToSet" style="color: var(--metric-primary);">—</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Narrative: Why Non-Located? -->
  <section class="narrative-section dark">
    <div class="narrative-content" data-animate>
      <p>Why would a set fail to be located? Consider a set defined by an undecidable property:</p>
      <div class="math-display">
        A = { x ∈ ℝ : some undecidable condition on x }
      </div>
      <p>To compute ρ(x, A), we'd need to search through A. But if we can't decide membership, we can't find the infimum.</p>
      <p><strong>Key insight:</strong> Locatedness is a computational property, not just a set-theoretic one.</p>
    </div>
  </section>

  <!-- Metric Complement -->
  <section class="complement-section">
    <div class="section-header" style="color: var(--ink-light);">
      <h2 class="section-title">The Metric Complement</h2>
      <p class="section-subtitle" style="color: #9CA3AF;">X - A = { x ∈ X : ρ(x, A) > 0 }</p>
    </div>

    <div class="complement-container">
      <div class="complement-panel">
        <div class="complement-canvas-container">
          <canvas id="complementCanvas"></canvas>
        </div>

        <div class="complement-explanation">
          <p><strong>Definition:</strong> The metric complement X - A consists of all points at <em>positive distance</em> from A.</p>
          <p><strong>This is NOT "everything not in A"!</strong> The metric complement requires ρ(x, A) > 0, which is a positive condition.</p>
          <p>If A is located, then X - A is an <strong>open set</strong>. The union A ∪ (X - A) is dense in X, but may not equal X.</p>
        </div>

        <div class="complement-info">
          <div class="complement-card">
            <p class="complement-label">Set A (the interval)</p>
            <p class="complement-value" style="color: var(--located-color);">{ x : 0 ≤ x ≤ 1 }</p>
          </div>
          <div class="complement-card">
            <p class="complement-label">Metric Complement -A</p>
            <p class="complement-value" style="color: var(--complement-color);">{ x : |x - [0,1]| > 0 }</p>
          </div>
          <div class="complement-card">
            <p class="complement-label">The Gap</p>
            <p class="complement-value" style="color: var(--fog-color);">boundary points</p>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Distance Calculator -->
  <section class="distance-section">
    <div class="section-header">
      <h2 class="section-title">Computing Distance to a Set</h2>
      <p class="section-subtitle">For located sets, ρ(x, A) is computable</p>
    </div>

    <div class="distance-container">
      <div class="distance-panel">
        <div class="distance-canvas-container" id="distanceCanvasContainer">
          <canvas id="distanceCanvas"></canvas>
        </div>

        <div class="distance-result computed" id="distanceResult">
          <p class="distance-formula" id="distanceFormula">ρ(x, A) = |x - closest point in A|</p>
          <p class="distance-note" id="distanceNote">Click on the number line to place x and see the distance computation.</p>
        </div>
      </div>
    </div>
  </section>

  <!-- Narrative: Inequality -->
  <section class="narrative-section">
    <div class="narrative-content" data-animate>
      <p>The distance function satisfies a key inequality:</p>
      <div class="math-display">
        ρ(x, A) ≤ ρ(x, y) + ρ(y, A)
      </div>
      <p>This follows from the triangle inequality applied to any point z in A:</p>
      <p style="font-family: var(--mono); text-align: center;">ρ(x, A) ≤ ρ(x, z) ≤ ρ(x, y) + ρ(y, z)</p>
      <p>Taking the infimum over z gives the result.</p>
    </div>
  </section>

  <!-- Navigation -->
  <section class="next-section">
    <p class="next-label">Coming Next</p>
    <h3 class="next-title">Completeness & The Completion</h3>
    <p class="next-description">Cauchy sequences, regular sequences, and how to fill the gaps in a metric space.</p>
  </section>

  <script>
    // Scroll animations
    const observerOptions = { threshold: 0.3, rootMargin: '0px 0px -10% 0px' };
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) entry.target.classList.add('visible');
      });
    }, observerOptions);
    document.querySelectorAll('[data-animate], .narrative-content').forEach(el => observer.observe(el));

    function setupCanvas(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      return { ctx, width: rect.width, height: rect.height };
    }

    // ============================================
    // LOCATED SETS VISUALIZATION
    // ============================================
    
    const locatedCanvas = document.getElementById('locatedCanvas');
    const locatedContainer = document.getElementById('locatedCanvasContainer');
    let currentSetType = 'interval';
    let queryPoint = null;

    const setInfo = {
      interval: {
        name: '[0, 1]',
        located: true,
        draw: (ctx, width, height, scale, offsetX) => {
          const y = height / 2;
          const x0 = offsetX + 0 * scale;
          const x1 = offsetX + 1 * scale;
          
          ctx.strokeStyle = '#F59E0B';
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(x0, y);
          ctx.lineTo(x1, y);
          ctx.stroke();
          
          ctx.fillStyle = '#F59E0B';
          ctx.beginPath();
          ctx.arc(x0, y, 8, 0, Math.PI * 2);
          ctx.arc(x1, y, 8, 0, Math.PI * 2);
          ctx.fill();
          
          return { x0, x1, y };
        },
        distance: (px, bounds, scale, offsetX) => {
          const x = (px - offsetX) / scale;
          if (x < 0) return Math.abs(x);
          if (x > 1) return Math.abs(x - 1);
          return 0;
        }
      },
      rationals: {
        name: 'ℚ ∩ [0, 2]',
        located: true,
        draw: (ctx, width, height, scale, offsetX) => {
          const y = height / 2;
          // Draw some rationals as dots
          const rationals = [0, 0.25, 0.333, 0.5, 0.666, 0.75, 1, 1.25, 1.333, 1.5, 1.666, 1.75, 2];
          
          ctx.fillStyle = '#F59E0B';
          rationals.forEach(r => {
            ctx.beginPath();
            ctx.arc(offsetX + r * scale, y, 4, 0, Math.PI * 2);
            ctx.fill();
          });
          
          ctx.fillStyle = '#666';
          ctx.font = '10px "JetBrains Mono"';
          ctx.textAlign = 'center';
          ctx.fillText('(dense in [0, 2])', offsetX + scale, y + 30);
          
          return { x0: offsetX, x1: offsetX + 2 * scale, y };
        },
        distance: (px, bounds, scale, offsetX) => {
          // Distance to rationals is 0 (they're dense)
          const x = (px - offsetX) / scale;
          if (x < 0) return Math.abs(x);
          if (x > 2) return Math.abs(x - 2);
          return 0; // rationals are dense
        }
      },
      fuzzy: {
        name: 'Undecidable set',
        located: false,
        draw: (ctx, width, height, scale, offsetX) => {
          const y = height / 2;
          
          // Draw fog/uncertainty
          const gradient = ctx.createLinearGradient(offsetX, 0, offsetX + 2 * scale, 0);
          gradient.addColorStop(0, 'rgba(107, 114, 128, 0)');
          gradient.addColorStop(0.3, 'rgba(107, 114, 128, 0.3)');
          gradient.addColorStop(0.5, 'rgba(107, 114, 128, 0.5)');
          gradient.addColorStop(0.7, 'rgba(107, 114, 128, 0.3)');
          gradient.addColorStop(1, 'rgba(107, 114, 128, 0)');
          
          ctx.fillStyle = gradient;
          ctx.fillRect(offsetX, y - 20, 2 * scale, 40);
          
          ctx.strokeStyle = '#6B7280';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(offsetX + 0.5 * scale, y);
          ctx.lineTo(offsetX + 1.5 * scale, y);
          ctx.stroke();
          ctx.setLineDash([]);
          
          ctx.fillStyle = '#6B7280';
          ctx.font = '10px "JetBrains Mono"';
          ctx.textAlign = 'center';
          ctx.fillText('membership undecidable', offsetX + scale, y + 35);
          
          return { x0: offsetX + 0.5 * scale, x1: offsetX + 1.5 * scale, y };
        },
        distance: (px, bounds, scale, offsetX) => {
          return null; // Cannot compute
        }
      }
    };

    function drawLocated() {
      const { ctx, width, height } = setupCanvas(locatedCanvas);
      const set = setInfo[currentSetType];
      
      ctx.fillStyle = '#FAFAFA';
      ctx.fillRect(0, 0, width, height);
      
      const scale = width / 4;
      const offsetX = width / 4;
      
      // Number line
      ctx.strokeStyle = '#DDD';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(30, height / 2);
      ctx.lineTo(width - 30, height / 2);
      ctx.stroke();
      
      // Ticks
      for (let i = -1; i <= 3; i++) {
        const x = offsetX + i * scale;
        ctx.beginPath();
        ctx.moveTo(x, height / 2 - 5);
        ctx.lineTo(x, height / 2 + 5);
        ctx.stroke();
        
        ctx.fillStyle = '#999';
        ctx.font = '11px "JetBrains Mono"';
        ctx.textAlign = 'center';
        ctx.fillText(i.toString(), x, height / 2 + 20);
      }
      
      // Draw set
      const bounds = set.draw(ctx, width, height, scale, offsetX);
      
      // Draw query point if exists
      if (queryPoint !== null) {
        const qx = offsetX + queryPoint * scale;
        
        // Distance line
        const dist = set.distance(qx, bounds, scale, offsetX);
        if (dist !== null && dist > 0) {
          const closestX = queryPoint < 0 ? offsetX : (queryPoint > (currentSetType === 'rationals' ? 2 : 1) ? bounds.x1 : qx);
          
          ctx.strokeStyle = '#0EA5E9';
          ctx.lineWidth = 2;
          ctx.setLineDash([4, 4]);
          ctx.beginPath();
          ctx.moveTo(qx, bounds.y);
          ctx.lineTo(closestX, bounds.y);
          ctx.stroke();
          ctx.setLineDash([]);
        }
        
        // Query point
        ctx.fillStyle = '#EC4899';
        ctx.beginPath();
        ctx.arc(qx, bounds.y, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = 'bold 10px "JetBrains Mono"';
        ctx.textAlign = 'center';
        ctx.fillText('x', qx, bounds.y + 4);
        
        // Update display
        if (dist !== null) {
          document.getElementById('distanceToSet').textContent = dist.toFixed(3);
          document.getElementById('distanceToSet').style.color = '#0EA5E9';
        } else {
          document.getElementById('distanceToSet').textContent = 'undefined';
          document.getElementById('distanceToSet').style.color = '#6B7280';
        }
      }
      
      // Update info
      document.getElementById('setDescription').textContent = set.name;
      document.getElementById('isLocated').textContent = set.located ? 'Yes' : 'No';
      document.getElementById('isLocated').className = 'info-value ' + (set.located ? 'yes' : 'no');
    }

    locatedContainer.addEventListener('click', (e) => {
      const rect = locatedCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const scale = rect.width / 4;
      const offsetX = rect.width / 4;
      queryPoint = (mx - offsetX) / scale;
      drawLocated();
    });

    document.querySelectorAll('.set-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.set-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentSetType = btn.dataset.set;
        queryPoint = null;
        document.getElementById('distanceToSet').textContent = '—';
        drawLocated();
      });
    });

    // ============================================
    // METRIC COMPLEMENT VISUALIZATION
    // ============================================
    
    const complementCanvas = document.getElementById('complementCanvas');

    function drawComplement() {
      const { ctx, width, height } = setupCanvas(complementCanvas);
      
      ctx.fillStyle = '#0A0A0F';
      ctx.fillRect(0, 0, width, height);
      
      const centerY = height / 2;
      const scale = width / 5;
      const offsetX = width / 2 - scale / 2;
      
      // Number line
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(30, centerY);
      ctx.lineTo(width - 30, centerY);
      ctx.stroke();
      
      // Ticks
      ctx.fillStyle = '#666';
      ctx.font = '10px "JetBrains Mono"';
      ctx.textAlign = 'center';
      for (let i = -2; i <= 3; i++) {
        const x = offsetX + i * scale;
        ctx.beginPath();
        ctx.moveTo(x, centerY - 5);
        ctx.lineTo(x, centerY + 5);
        ctx.stroke();
        ctx.fillText(i.toString(), x, centerY + 20);
      }
      
      // The set A = [0, 1]
      const x0 = offsetX;
      const x1 = offsetX + scale;
      
      ctx.fillStyle = 'rgba(245, 158, 11, 0.3)';
      ctx.fillRect(x0, centerY - 30, scale, 60);
      ctx.strokeStyle = '#F59E0B';
      ctx.lineWidth = 3;
      ctx.strokeRect(x0, centerY - 30, scale, 60);
      
      ctx.fillStyle = '#F59E0B';
      ctx.font = 'bold 14px "JetBrains Mono"';
      ctx.fillText('A', offsetX + scale / 2, centerY + 5);
      
      // The metric complement (left side)
      ctx.fillStyle = 'rgba(139, 92, 246, 0.2)';
      ctx.fillRect(30, centerY - 20, x0 - 40, 40);
      
      // The metric complement (right side)
      ctx.fillRect(x1 + 10, centerY - 20, width - x1 - 40, 40);
      
      // Labels
      ctx.fillStyle = '#8B5CF6';
      ctx.font = '12px "JetBrains Mono"';
      ctx.fillText('-A', (30 + x0) / 2, centerY + 5);
      ctx.fillText('-A', (x1 + width - 30) / 2, centerY + 5);
      
      // Boundary indicators
      ctx.strokeStyle = '#6B7280';
      ctx.setLineDash([3, 3]);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x0, centerY - 35);
      ctx.lineTo(x0, centerY + 35);
      ctx.moveTo(x1, centerY - 35);
      ctx.lineTo(x1, centerY + 35);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Gap labels
      ctx.fillStyle = '#6B7280';
      ctx.font = '9px "JetBrains Mono"';
      ctx.fillText('boundary', x0, centerY + 50);
      ctx.fillText('boundary', x1, centerY + 50);
      
      // Arrow showing positive distance
      ctx.strokeStyle = '#8B5CF6';
      ctx.lineWidth = 2;
      const arrowX = x0 - 60;
      ctx.beginPath();
      ctx.moveTo(arrowX, centerY);
      ctx.lineTo(x0 - 15, centerY);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x0 - 15, centerY);
      ctx.lineTo(x0 - 22, centerY - 5);
      ctx.moveTo(x0 - 15, centerY);
      ctx.lineTo(x0 - 22, centerY + 5);
      ctx.stroke();
      
      ctx.fillStyle = '#8B5CF6';
      ctx.font = '10px "JetBrains Mono"';
      ctx.fillText('ρ(x,A)>0', arrowX - 25, centerY + 4);
    }

    // ============================================
    // DISTANCE CALCULATOR
    // ============================================
    
    const distanceCanvas = document.getElementById('distanceCanvas');
    const distanceContainer = document.getElementById('distanceCanvasContainer');
    let distPoint = null;

    function drawDistance() {
      const { ctx, width, height } = setupCanvas(distanceCanvas);
      
      ctx.fillStyle = '#FAFAFA';
      ctx.fillRect(0, 0, width, height);
      
      const centerY = height / 2;
      const scale = width / 5;
      const offsetX = width / 2 - scale / 2;
      
      // Number line
      ctx.strokeStyle = '#DDD';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(30, centerY);
      ctx.lineTo(width - 30, centerY);
      ctx.stroke();
      
      // Ticks
      ctx.fillStyle = '#999';
      ctx.font = '11px "JetBrains Mono"';
      ctx.textAlign = 'center';
      for (let i = -2; i <= 3; i++) {
        const x = offsetX + i * scale;
        ctx.beginPath();
        ctx.moveTo(x, centerY - 5);
        ctx.lineTo(x, centerY + 5);
        ctx.stroke();
        ctx.fillText(i.toString(), x, centerY + 20);
      }
      
      // The set A = [0, 1]
      const x0 = offsetX;
      const x1 = offsetX + scale;
      
      ctx.strokeStyle = '#F59E0B';
      ctx.lineWidth = 8;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(x0, centerY);
      ctx.lineTo(x1, centerY);
      ctx.stroke();
      
      ctx.fillStyle = '#F59E0B';
      ctx.font = '12px "JetBrains Mono"';
      ctx.fillText('A = [0, 1]', offsetX + scale / 2, centerY - 20);
      
      // Query point
      if (distPoint !== null) {
        const qx = offsetX + distPoint * scale;
        
        // Compute distance
        let dist, closestX, closestVal;
        if (distPoint < 0) {
          dist = Math.abs(distPoint);
          closestX = x0;
          closestVal = 0;
        } else if (distPoint > 1) {
          dist = distPoint - 1;
          closestX = x1;
          closestVal = 1;
        } else {
          dist = 0;
          closestX = qx;
          closestVal = distPoint;
        }
        
        // Distance line
        if (dist > 0) {
          ctx.strokeStyle = '#0EA5E9';
          ctx.lineWidth = 3;
          ctx.setLineDash([6, 4]);
          ctx.beginPath();
          ctx.moveTo(qx, centerY);
          ctx.lineTo(closestX, centerY);
          ctx.stroke();
          ctx.setLineDash([]);
          
          // Closest point marker
          ctx.fillStyle = '#22C55E';
          ctx.beginPath();
          ctx.arc(closestX, centerY, 6, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Query point
        ctx.fillStyle = '#EC4899';
        ctx.beginPath();
        ctx.arc(qx, centerY, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.font = 'bold 10px "JetBrains Mono"';
        ctx.textAlign = 'center';
        ctx.fillText('x', qx, centerY + 4);
        
        // Update result
        const formula = dist > 0 
          ? `ρ(${distPoint.toFixed(2)}, A) = |${distPoint.toFixed(2)} - ${closestVal}| = ${dist.toFixed(3)}`
          : `ρ(${distPoint.toFixed(2)}, A) = 0  (x ∈ A)`;
        
        document.getElementById('distanceFormula').textContent = formula;
        document.getElementById('distanceNote').textContent = dist > 0 
          ? `Distance to closest point in A (at ${closestVal})`
          : 'Point is inside the set, distance is 0';
      }
    }

    distanceContainer.addEventListener('click', (e) => {
      const rect = distanceCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const scale = rect.width / 5;
      const offsetX = rect.width / 2 - scale / 2;
      distPoint = (mx - offsetX) / scale;
      drawDistance();
    });

    // Initialize
    drawLocated();
    drawComplement();
    drawDistance();

    window.addEventListener('resize', () => {
      drawLocated();
      drawComplement();
      drawDistance();
    });
  </script>
</body>
</html>
