<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Failure of the Intermediate Value Theorem — Constructive Analysis</title>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&family=Source+Sans+Pro:wght@300;400;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --constructive-primary: #2D5A4A;
      --constructive-glow: #4A9D7C;
      --classical-primary: #4A3C6D;
      --classical-secondary: #C9B037;
      --algorithm-accent: #E07B39;
      --undecidable-fog: #6B7280;
      --fog-light: #9CA3AF;
      --proof-valid: #059669;
      --proof-invalid: #DC2626;
      --zero-line: #3B82F6;
      --function-color: #8B5CF6;
      --background: #FAF8F5;
      --background-dark: #0F0F12;
      --ink: #1A1A1A;
      --ink-light: #FAF8F5;
      
      --display: 'Crimson Text', serif;
      --body: 'Source Sans Pro', sans-serif;
      --mono: 'JetBrains Mono', monospace;
      
      --ease-out-expo: cubic-bezier(0.16, 1, 0.3, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: var(--body);
      background: var(--background);
      color: var(--ink);
      line-height: 1.7;
      overflow-x: hidden;
    }

    /* ============================================
       OPENING
       ============================================ */
    
    .opening {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      background: linear-gradient(180deg, var(--background) 0%, #F0EDE8 100%);
      position: relative;
    }

    .opening-content {
      text-align: center;
      max-width: 800px;
    }

    .section-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--undecidable-fog);
      margin-bottom: 1rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.2s forwards;
    }

    .main-title {
      font-family: var(--display);
      font-size: clamp(2rem, 6vw, 3.5rem);
      font-weight: 400;
      line-height: 1.2;
      margin-bottom: 1.5rem;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.4s forwards;
    }

    .main-title .strike {
      text-decoration: line-through;
      text-decoration-color: var(--proof-invalid);
      opacity: 0.6;
    }

    .subtitle {
      font-size: 1.15rem;
      color: #666;
      max-width: 600px;
      margin: 0 auto;
      opacity: 0;
      animation: fadeUp 0.8s var(--ease-out-expo) 0.6s forwards;
    }

    @keyframes fadeUp {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* ============================================
       NARRATIVE SECTIONS
       ============================================ */

    .narrative-section {
      min-height: 70vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4rem 2rem;
    }

    .narrative-section.dark {
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .narrative-content {
      max-width: 650px;
      opacity: 0;
      transform: translateY(30px);
      transition: opacity 0.8s var(--ease-out-expo), transform 0.8s var(--ease-out-expo);
    }

    .narrative-content.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .narrative-content p {
      font-size: 1.2rem;
      margin-bottom: 1.5rem;
    }

    .math-display {
      font-family: var(--mono);
      font-size: 1.1rem;
      background: rgba(139, 92, 246, 0.1);
      padding: 1.5rem;
      border-radius: 8px;
      text-align: center;
      margin: 1.5rem 0;
      border-left: 3px solid var(--function-color);
    }

    .dark .math-display {
      background: rgba(139, 92, 246, 0.15);
    }

    .quote-block {
      border-left: 3px solid var(--algorithm-accent);
      padding-left: 1.5rem;
      margin: 2rem 0;
      font-family: var(--display);
      font-style: italic;
      font-size: 1.25rem;
    }

    /* ============================================
       CLASSICAL IVT VISUALIZATION
       ============================================ */

    .classical-ivt-section {
      padding: 4rem 2rem;
      background: linear-gradient(180deg, #F0EDE8 0%, var(--background) 100%);
    }

    .section-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .section-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .section-subtitle {
      color: #666;
      font-size: 1rem;
    }

    .ivt-demo {
      max-width: 700px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      padding: 2rem;
      box-shadow: 0 4px 30px rgba(0, 0, 0, 0.08);
    }

    .ivt-canvas-container {
      position: relative;
      width: 100%;
      height: 300px;
      margin-bottom: 1.5rem;
    }

    #ivtCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #FAFAFA;
    }

    .ivt-explanation {
      text-align: center;
      color: #666;
      font-size: 0.95rem;
    }

    /* ============================================
       THE CONSTRUCTION
       ============================================ */

    .construction-section {
      min-height: 100vh;
      padding: 4rem 2rem;
      background: var(--background-dark);
      color: var(--ink-light);
    }

    .construction-container {
      max-width: 1100px;
      margin: 0 auto;
    }

    .construction-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .construction-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
    }

    .construction-subtitle {
      color: var(--fog-light);
      font-size: 1rem;
    }

    .construction-grid {
      display: grid;
      grid-template-columns: 1fr 1.5fr;
      gap: 2rem;
      align-items: start;
    }

    @media (max-width: 900px) {
      .construction-grid {
        grid-template-columns: 1fr;
      }
    }

    /* Sequence Builder */
    .sequence-builder {
      background: rgba(30, 30, 40, 0.5);
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 12px;
      padding: 1.5rem;
    }

    .builder-title {
      font-family: var(--mono);
      font-size: 0.75rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--fog-light);
      margin-bottom: 1rem;
    }

    .sequence-display {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 1.5rem;
    }

    .sequence-term {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .term-label {
      font-family: var(--mono);
      font-size: 0.65rem;
      color: var(--fog-light);
    }

    .term-value {
      width: 40px;
      height: 40px;
      border: 2px solid rgba(107, 114, 128, 0.4);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: var(--mono);
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.2s;
      background: rgba(20, 20, 28, 0.5);
    }

    .term-value:hover {
      border-color: var(--algorithm-accent);
    }

    .term-value.negative {
      color: var(--proof-invalid);
      border-color: rgba(220, 38, 38, 0.5);
      background: rgba(220, 38, 38, 0.1);
    }

    .term-value.zero {
      color: var(--fog-light);
      border-color: rgba(107, 114, 128, 0.5);
    }

    .term-value.positive {
      color: var(--constructive-glow);
      border-color: rgba(74, 157, 124, 0.5);
      background: rgba(74, 157, 124, 0.1);
    }

    .term-value.unknown {
      color: var(--algorithm-accent);
      border-color: rgba(224, 123, 57, 0.5);
      background: rgba(224, 123, 57, 0.1);
    }

    .alpha-display {
      background: rgba(139, 92, 246, 0.15);
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
      margin-bottom: 1.5rem;
    }

    .alpha-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      color: var(--fog-light);
      margin-bottom: 0.3rem;
    }

    .alpha-value {
      font-family: var(--mono);
      font-size: 1.3rem;
      color: var(--function-color);
    }

    .alpha-formula {
      font-size: 0.75rem;
      color: var(--fog-light);
      margin-top: 0.5rem;
    }

    .preset-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .preset-btn {
      padding: 0.5rem 0.8rem;
      border: 1px solid rgba(107, 114, 128, 0.4);
      border-radius: 6px;
      background: transparent;
      color: var(--fog-light);
      font-family: var(--mono);
      font-size: 0.7rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .preset-btn:hover {
      border-color: var(--algorithm-accent);
      color: var(--algorithm-accent);
    }

    /* Function Visualization */
    .function-panel {
      background: rgba(30, 30, 40, 0.5);
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 12px;
      padding: 1.5rem;
    }

    .function-canvas-container {
      position: relative;
      width: 100%;
      height: 350px;
      margin-bottom: 1rem;
    }

    #functionCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #12121A;
    }

    .function-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 1rem;
      border-top: 1px solid rgba(107, 114, 128, 0.2);
    }

    .info-item {
      text-align: center;
    }

    .info-label {
      font-family: var(--mono);
      font-size: 0.65rem;
      color: var(--fog-light);
      margin-bottom: 0.2rem;
    }

    .info-value {
      font-family: var(--mono);
      font-size: 0.9rem;
    }

    .info-value.negative { color: var(--proof-invalid); }
    .info-value.positive { color: var(--constructive-glow); }
    .info-value.undecidable { color: var(--algorithm-accent); }

    /* ============================================
       THE TRAP - ZERO FINDER
       ============================================ */

    .trap-section {
      min-height: 100vh;
      padding: 4rem 2rem;
      background: linear-gradient(180deg, #0F0F12 0%, #1A1A20 100%);
      color: var(--ink-light);
    }

    .trap-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .trap-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .trap-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 0.5rem;
      color: var(--algorithm-accent);
    }

    .trap-subtitle {
      color: var(--fog-light);
      font-size: 1rem;
      max-width: 500px;
      margin: 0 auto;
    }

    .zero-finder {
      background: rgba(30, 30, 40, 0.5);
      border: 1px solid rgba(107, 114, 128, 0.3);
      border-radius: 16px;
      padding: 2rem;
    }

    .finder-canvas-container {
      position: relative;
      width: 100%;
      height: 300px;
      margin-bottom: 1.5rem;
    }

    #finderCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #0A0A0F;
    }

    .finder-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }

    .zoom-control {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .zoom-label {
      font-family: var(--mono);
      font-size: 0.75rem;
      color: var(--fog-light);
    }

    .zoom-btn {
      width: 36px;
      height: 36px;
      border: 2px solid var(--fog-light);
      border-radius: 8px;
      background: transparent;
      color: var(--fog-light);
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .zoom-btn:hover {
      border-color: var(--zero-line);
      color: var(--zero-line);
    }

    .zoom-level {
      font-family: var(--mono);
      font-size: 0.9rem;
      min-width: 60px;
      text-align: center;
    }

    .center-control {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .center-input {
      width: 100px;
      padding: 0.5rem;
      border: 2px solid rgba(107, 114, 128, 0.4);
      border-radius: 6px;
      background: rgba(20, 20, 28, 0.8);
      color: var(--ink-light);
      font-family: var(--mono);
      font-size: 0.85rem;
      text-align: center;
    }

    .center-input:focus {
      outline: none;
      border-color: var(--zero-line);
    }

    .finder-status {
      text-align: center;
      padding: 1.5rem;
      border-radius: 12px;
      background: rgba(20, 20, 28, 0.5);
    }

    .status-title {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--fog-light);
      margin-bottom: 0.5rem;
    }

    .status-message {
      font-size: 1rem;
      line-height: 1.6;
    }

    .status-message.warning {
      color: var(--algorithm-accent);
    }

    .status-message .highlight {
      color: var(--zero-line);
      font-weight: 600;
    }

    /* ============================================
       THE UNDECIDABILITY MOMENT
       ============================================ */

    .undecidability-section {
      min-height: 80vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 4rem 2rem;
      background: linear-gradient(180deg, 
        rgba(224, 123, 57, 0.1) 0%, 
        var(--background-dark) 50%,
        rgba(224, 123, 57, 0.1) 100%);
    }

    .undecidability-content {
      max-width: 700px;
      text-align: center;
    }

    .undecidability-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--algorithm-accent);
      margin-bottom: 1.5rem;
    }

    .undecidability-text {
      font-family: var(--display);
      font-size: clamp(1.3rem, 3.5vw, 1.8rem);
      font-style: italic;
      line-height: 1.6;
      color: var(--ink-light);
      margin-bottom: 2rem;
    }

    .undecidability-text em {
      color: var(--algorithm-accent);
      font-style: normal;
    }

    .decision-box {
      display: flex;
      justify-content: center;
      gap: 2rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }

    .decision-option {
      padding: 1.5rem 2rem;
      border: 2px solid rgba(107, 114, 128, 0.4);
      border-radius: 12px;
      background: rgba(20, 20, 28, 0.5);
      min-width: 180px;
    }

    .decision-condition {
      font-family: var(--mono);
      font-size: 0.9rem;
      color: var(--fog-light);
      margin-bottom: 0.5rem;
    }

    .decision-implies {
      font-size: 0.85rem;
      color: var(--ink-light);
    }

    .decision-option.left .decision-implies { color: var(--proof-invalid); }
    .decision-option.right .decision-implies { color: var(--constructive-glow); }

    .undecidability-conclusion {
      font-size: 1rem;
      color: var(--fog-light);
      max-width: 550px;
      margin: 0 auto;
    }

    /* ============================================
       CONSTRUCTIVE ALTERNATIVE
       ============================================ */

    .alternative-section {
      min-height: 100vh;
      padding: 4rem 2rem;
      background: linear-gradient(180deg, var(--constructive-primary) 0%, #1E3D31 100%);
      color: var(--ink-light);
    }

    .alternative-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .alternative-header {
      text-align: center;
      margin-bottom: 3rem;
    }

    .alternative-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--constructive-glow);
      margin-bottom: 1rem;
    }

    .alternative-title {
      font-family: var(--display);
      font-size: 2rem;
      margin-bottom: 1rem;
    }

    .alternative-subtitle {
      font-size: 1.1rem;
      color: rgba(255, 255, 255, 0.8);
      max-width: 600px;
      margin: 0 auto;
    }

    .epsilon-finder {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 16px;
      padding: 2rem;
    }

    .epsilon-canvas-container {
      position: relative;
      width: 100%;
      height: 300px;
      margin-bottom: 1.5rem;
    }

    #epsilonCanvas {
      width: 100%;
      height: 100%;
      border-radius: 8px;
      background: #1A2A22;
    }

    .epsilon-control {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
      flex-wrap: wrap;
    }

    .epsilon-label {
      font-family: var(--mono);
      font-size: 0.9rem;
    }

    .epsilon-slider {
      width: 300px;
      height: 8px;
      -webkit-appearance: none;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      outline: none;
    }

    .epsilon-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: var(--constructive-glow);
      border-radius: 50%;
      cursor: pointer;
    }

    .epsilon-value {
      font-family: var(--mono);
      font-size: 1.1rem;
      color: var(--constructive-glow);
      min-width: 80px;
    }

    .epsilon-result {
      text-align: center;
      padding: 1.5rem;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 12px;
    }

    .result-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(255, 255, 255, 0.6);
      margin-bottom: 0.5rem;
    }

    .result-text {
      font-family: var(--mono);
      font-size: 1rem;
      color: var(--constructive-glow);
    }

    .result-explanation {
      font-size: 0.9rem;
      color: rgba(255, 255, 255, 0.7);
      margin-top: 1rem;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }

    /* ============================================
       NAVIGATION
       ============================================ */

    .next-section {
      padding: 4rem 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--background);
      text-align: center;
    }

    .next-label {
      font-family: var(--mono);
      font-size: 0.7rem;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--undecidable-fog);
      margin-bottom: 1rem;
    }

    .next-title {
      font-family: var(--display);
      font-size: 1.6rem;
      color: var(--constructive-primary);
      margin-bottom: 0.5rem;
    }

    .next-description {
      font-size: 1rem;
      color: #666;
      max-width: 500px;
    }
  </style>
</head>
<body>

  <!-- Opening -->
  <section class="opening">
    <div class="opening-content">
      <p class="section-label">Bishop's Counterexample</p>
      <h1 class="main-title">The <span class="strike">Intermediate Value</span> Theorem</h1>
      <p class="subtitle">A continuous function crosses from negative to positive. Classically, it must hit zero. Constructively, we cannot always find where.</p>
    </div>
  </section>

  <!-- Narrative: Classical IVT -->
  <section class="narrative-section">
    <div class="narrative-content" data-animate>
      <p>The Intermediate Value Theorem is one of the most intuitive results in calculus. If a continuous function f goes from negative to positive over an interval, it must cross zero somewhere in between.</p>
      <div class="math-display">
        f continuous on [0,1], f(0) < 0, f(1) > 0<br>
        ⟹ ∃ x₀ ∈ [0,1] such that f(x₀) = 0
      </div>
      <p>This feels obviously true. Draw any curve that starts below the x-axis and ends above it—it must cross the axis. What could possibly go wrong?</p>
    </div>
  </section>

  <!-- Classical IVT Visualization -->
  <section class="classical-ivt-section">
    <div class="section-header">
      <h2 class="section-title">The Classical Picture</h2>
      <p class="section-subtitle">A continuous function must cross zero... right?</p>
    </div>
    <div class="ivt-demo">
      <div class="ivt-canvas-container">
        <canvas id="ivtCanvas"></canvas>
      </div>
      <p class="ivt-explanation">The function starts at f(0) = -1, ends at f(1) = +1, and is continuous throughout. The zero crossing seems inevitable.</p>
    </div>
  </section>

  <!-- Narrative: The Construction -->
  <section class="narrative-section dark">
    <div class="narrative-content" data-animate>
      <p>Bishop's insight was to construct a specific function where finding the zero would require solving an undecidable problem. The construction is elegant:</p>
      <p>Start with a sequence <span style="font-family: var(--mono); color: var(--algorithm-accent);">(n₁, n₂, n₃, ...)</span> where each term is -1, 0, or +1. Define:</p>
      <div class="math-display">
        α = Σₖ 3⁻ᵏ · nₖ
      </div>
      <p>This α is a real number determined by the sequence. Now build a piecewise linear function f with f(0) = -1, f(1) = +1, and a "kink" in the middle whose height is α.</p>
    </div>
  </section>

  <!-- Interactive Construction -->
  <section class="construction-section">
    <div class="construction-container">
      <div class="construction-header">
        <h2 class="construction-title">Build the Counterexample</h2>
        <p class="construction-subtitle">Click terms to cycle through -1, 0, +1. Watch the function respond.</p>
      </div>

      <div class="construction-grid">
        <!-- Sequence Builder -->
        <div class="sequence-builder">
          <p class="builder-title">The Sequence (nₖ)</p>
          
          <div class="sequence-display" id="sequenceDisplay">
            <!-- Generated by JavaScript -->
          </div>

          <div class="alpha-display">
            <p class="alpha-label">Computed Value</p>
            <p class="alpha-value" id="alphaValue">α = 0</p>
            <p class="alpha-formula">α = Σ 3⁻ᵏ · nₖ</p>
          </div>

          <p class="builder-title" style="margin-top: 1rem;">Presets</p>
          <div class="preset-buttons">
            <button class="preset-btn" data-preset="allzero">All Zeros</button>
            <button class="preset-btn" data-preset="positive">α > 0</button>
            <button class="preset-btn" data-preset="negative">α < 0</button>
            <button class="preset-btn" data-preset="unknown">Unknown</button>
          </div>
        </div>

        <!-- Function Visualization -->
        <div class="function-panel">
          <div class="function-canvas-container">
            <canvas id="functionCanvas"></canvas>
          </div>

          <div class="function-info">
            <div class="info-item">
              <p class="info-label">f(0)</p>
              <p class="info-value negative">-1</p>
            </div>
            <div class="info-item">
              <p class="info-label">f(⅓) = f(⅔)</p>
              <p class="info-value" id="fMiddle">α = 0</p>
            </div>
            <div class="info-item">
              <p class="info-label">f(1)</p>
              <p class="info-value positive">+1</p>
            </div>
            <div class="info-item">
              <p class="info-label">Zero at</p>
              <p class="info-value" id="zeroLocation">x = 0.5</p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- The Trap: Zero Finder -->
  <section class="trap-section">
    <div class="trap-container">
      <div class="trap-header">
        <h2 class="trap-title">Find the Zero</h2>
        <p class="trap-subtitle">Zoom in on where f(x) = 0. Can you pinpoint it exactly?</p>
      </div>

      <div class="zero-finder">
        <div class="finder-canvas-container">
          <canvas id="finderCanvas"></canvas>
        </div>

        <div class="finder-controls">
          <div class="zoom-control">
            <span class="zoom-label">Zoom:</span>
            <button class="zoom-btn" id="zoomOut">−</button>
            <span class="zoom-level" id="zoomLevel">1×</span>
            <button class="zoom-btn" id="zoomIn">+</button>
          </div>
          
          <div class="center-control">
            <span class="zoom-label">Center:</span>
            <input type="number" class="center-input" id="centerInput" value="0.5" min="0" max="1" step="0.01">
          </div>
        </div>

        <div class="finder-status">
          <p class="status-title">Analysis</p>
          <p class="status-message" id="finderStatus">
            Zoom in to locate the zero crossing. As you zoom, a critical question emerges...
          </p>
        </div>
      </div>
    </div>
  </section>

  <!-- The Undecidability Moment -->
  <section class="undecidability-section">
    <div class="undecidability-content" data-animate>
      <p class="undecidability-label">The Undecidability</p>
      <p class="undecidability-text">
        To find x₀ where f(x₀) = 0, you must decide: is the zero to the <em>left</em> of x = ½, or to the <em>right</em>?
      </p>
      
      <div class="decision-box">
        <div class="decision-option left">
          <p class="decision-condition">If x₀ < ½</p>
          <p class="decision-implies">Then α > 0 → first nonzero nₖ is +1</p>
        </div>
        <div class="decision-option right">
          <p class="decision-condition">If x₀ > ½</p>
          <p class="decision-implies">Then α < 0 → first nonzero nₖ is -1</p>
        </div>
      </div>

      <p class="undecidability-conclusion">
        But deciding which side the zero lies on is equivalent to determining the first nonzero term of the sequence—<em>precisely what we cannot do in general</em>. This is the Limited Principle of Omniscience in disguise.
      </p>
    </div>
  </section>

  <!-- Constructive Alternative -->
  <section class="alternative-section">
    <div class="alternative-container">
      <div class="alternative-header">
        <p class="alternative-label">The Constructive Substitute</p>
        <h2 class="alternative-title">Approximate Zeros We Can Find</h2>
        <p class="alternative-subtitle">For any tolerance ε > 0, we CAN find x with |f(x)| < ε. This is constructively valid.</p>
      </div>

      <div class="epsilon-finder">
        <div class="epsilon-canvas-container">
          <canvas id="epsilonCanvas"></canvas>
        </div>

        <div class="epsilon-control">
          <span class="epsilon-label">ε =</span>
          <input type="range" class="epsilon-slider" id="epsilonSlider" min="0.01" max="0.5" step="0.01" value="0.2">
          <span class="epsilon-value" id="epsilonValue">0.20</span>
        </div>

        <div class="epsilon-result">
          <p class="result-label">Algorithm Output</p>
          <p class="result-text" id="epsilonResult">x = 0.500 satisfies |f(x)| < 0.20</p>
          <p class="result-explanation">
            We can always find such an x by bisection: divide the interval, check which half contains a sign change (or both boundary values are within ε of zero), and repeat.
          </p>
        </div>
      </div>
    </div>
  </section>

  <!-- Navigation -->
  <section class="next-section">
    <p class="next-label">Coming Next</p>
    <h3 class="next-title">Constructive Logic: AND, OR, IMPLIES</h3>
    <p class="next-description">The meaning of logical connectives changes when proofs must be constructions.</p>
  </section>

  <script>
    // ============================================
    // SCROLL ANIMATIONS
    // ============================================
    
    const observerOptions = { threshold: 0.3, rootMargin: '0px 0px -10% 0px' };
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) entry.target.classList.add('visible');
      });
    }, observerOptions);

    document.querySelectorAll('[data-animate], .narrative-content').forEach(el => observer.observe(el));

    // ============================================
    // UTILITY: HIGH-DPI CANVAS
    // ============================================
    
    function setupCanvas(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width * dpr;
      canvas.height = rect.height * dpr;
      const ctx = canvas.getContext('2d');
      ctx.scale(dpr, dpr);
      return { ctx, width: rect.width, height: rect.height };
    }

    // ============================================
    // CLASSICAL IVT DEMO
    // ============================================
    
    const ivtCanvas = document.getElementById('ivtCanvas');
    
    function drawClassicalIVT() {
      const { ctx, width, height } = setupCanvas(ivtCanvas);
      const padding = 40;
      const plotWidth = width - 2 * padding;
      const plotHeight = height - 2 * padding;

      ctx.fillStyle = '#FAFAFA';
      ctx.fillRect(0, 0, width, height);

      // Grid
      ctx.strokeStyle = '#E8E8E8';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        const x = padding + (i / 10) * plotWidth;
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      }
      for (let i = 0; i <= 4; i++) {
        const y = padding + (i / 4) * plotHeight;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
      }

      // Zero line
      ctx.strokeStyle = '#3B82F6';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 5]);
      const zeroY = padding + plotHeight / 2;
      ctx.beginPath();
      ctx.moveTo(padding, zeroY);
      ctx.lineTo(width - padding, zeroY);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw a nice S-curve
      ctx.strokeStyle = '#8B5CF6';
      ctx.lineWidth = 3;
      ctx.beginPath();
      for (let i = 0; i <= 100; i++) {
        const t = i / 100;
        const x = padding + t * plotWidth;
        // Smooth curve from -1 to +1
        const fVal = Math.tanh((t - 0.5) * 6);
        const y = zeroY - (fVal * plotHeight / 2.5);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Zero crossing point
      const crossX = padding + 0.5 * plotWidth;
      ctx.fillStyle = '#DC2626';
      ctx.beginPath();
      ctx.arc(crossX, zeroY, 8, 0, Math.PI * 2);
      ctx.fill();

      // Labels
      ctx.fillStyle = '#666';
      ctx.font = '12px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillText('0', padding, height - padding + 20);
      ctx.fillText('1', width - padding, height - padding + 20);
      ctx.fillText('x₀', crossX, zeroY + 30);

      ctx.textAlign = 'right';
      ctx.fillText('f(0) < 0', padding - 10, height - padding - 20);
      ctx.fillText('f(1) > 0', padding - 10, padding + 20);
    }

    drawClassicalIVT();
    window.addEventListener('resize', drawClassicalIVT);

    // ============================================
    // SEQUENCE BUILDER & FUNCTION
    // ============================================
    
    const NUM_TERMS = 8;
    let sequence = [0, 0, 0, 0, 0, 0, 0, 0]; // -1, 0, or 1
    let unknownMode = false;

    const sequenceDisplay = document.getElementById('sequenceDisplay');
    const alphaValueEl = document.getElementById('alphaValue');
    const fMiddleEl = document.getElementById('fMiddle');
    const zeroLocationEl = document.getElementById('zeroLocation');

    function computeAlpha() {
      if (unknownMode) return null;
      let alpha = 0;
      for (let k = 0; k < sequence.length; k++) {
        alpha += sequence[k] * Math.pow(3, -(k + 1));
      }
      return alpha;
    }

    function buildSequenceUI() {
      sequenceDisplay.innerHTML = '';
      for (let i = 0; i < NUM_TERMS; i++) {
        const term = document.createElement('div');
        term.className = 'sequence-term';
        
        const label = document.createElement('span');
        label.className = 'term-label';
        label.textContent = `n${i + 1}`;
        
        const value = document.createElement('div');
        value.className = 'term-value';
        value.dataset.index = i;
        
        if (unknownMode) {
          value.textContent = '?';
          value.classList.add('unknown');
        } else {
          value.textContent = sequence[i] === 0 ? '0' : (sequence[i] > 0 ? '+1' : '-1');
          value.classList.add(sequence[i] === 0 ? 'zero' : (sequence[i] > 0 ? 'positive' : 'negative'));
        }
        
        value.addEventListener('click', () => cycleValue(i));
        
        term.appendChild(label);
        term.appendChild(value);
        sequenceDisplay.appendChild(term);
      }
    }

    function cycleValue(index) {
      if (unknownMode) {
        unknownMode = false;
      }
      // Cycle: 0 -> 1 -> -1 -> 0
      if (sequence[index] === 0) sequence[index] = 1;
      else if (sequence[index] === 1) sequence[index] = -1;
      else sequence[index] = 0;
      
      updateAll();
    }

    function updateAll() {
      buildSequenceUI();
      const alpha = computeAlpha();
      
      if (alpha === null) {
        alphaValueEl.textContent = 'α = ?';
        fMiddleEl.textContent = 'α = ?';
        fMiddleEl.className = 'info-value undecidable';
        zeroLocationEl.textContent = 'undecidable';
        zeroLocationEl.className = 'info-value undecidable';
      } else {
        alphaValueEl.textContent = `α = ${alpha.toFixed(4)}`;
        fMiddleEl.textContent = `α = ${alpha.toFixed(3)}`;
        fMiddleEl.className = 'info-value ' + (alpha > 0 ? 'positive' : alpha < 0 ? 'negative' : '');
        
        // Compute zero location
        if (Math.abs(alpha) < 0.0001) {
          zeroLocationEl.textContent = 'x ∈ [⅓, ⅔]';
          zeroLocationEl.className = 'info-value undecidable';
        } else if (alpha > 0) {
          // Zero is in [0, 1/3], specifically at 1/3 * (1/(1 - alpha/1)) = 1/(3 - alpha*3)
          // More precisely: solve -1 + 3x = 0 for alpha > 0 gives x = 1/3
          // Actually f goes from -1 at x=0 to alpha at x=1/3 linearly
          // Zero at x where -1 + x*(alpha - (-1))/(1/3 - 0) = 0
          // -1 + x*(alpha+1)*3 = 0 => x = 1/(3*(alpha+1))
          const x0 = 1 / (3 * (1 + alpha));
          zeroLocationEl.textContent = `x ≈ ${x0.toFixed(4)}`;
          zeroLocationEl.className = 'info-value negative';
        } else {
          // Zero is in [2/3, 1]
          // f goes from alpha at x=2/3 to 1 at x=1 linearly
          // alpha + (x - 2/3)*(1 - alpha)/(1/3) = 0
          // alpha + (x - 2/3)*3*(1-alpha) = 0
          // x = 2/3 - alpha/(3*(1-alpha))
          const x0 = 2/3 - alpha / (3 * (1 - alpha));
          zeroLocationEl.textContent = `x ≈ ${x0.toFixed(4)}`;
          zeroLocationEl.className = 'info-value positive';
        }
      }
      
      drawFunction();
      drawFinder();
      drawEpsilon();
    }

    // Preset buttons
    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        const preset = btn.dataset.preset;
        unknownMode = false;
        
        if (preset === 'allzero') {
          sequence = [0, 0, 0, 0, 0, 0, 0, 0];
        } else if (preset === 'positive') {
          sequence = [1, 0, 0, 0, 0, 0, 0, 0];
        } else if (preset === 'negative') {
          sequence = [-1, 0, 0, 0, 0, 0, 0, 0];
        } else if (preset === 'unknown') {
          sequence = [0, 0, 0, 0, 0, 0, 0, 0];
          unknownMode = true;
        }
        
        updateAll();
      });
    });

    // ============================================
    // FUNCTION CANVAS
    // ============================================
    
    const functionCanvas = document.getElementById('functionCanvas');

    function getF(x, alpha) {
      // Piecewise linear: 
      // [0, 1/3]: from -1 to alpha
      // [1/3, 2/3]: constant at alpha
      // [2/3, 1]: from alpha to 1
      if (alpha === null) alpha = 0; // For drawing purposes
      
      if (x <= 1/3) {
        return -1 + x * 3 * (alpha + 1);
      } else if (x <= 2/3) {
        return alpha;
      } else {
        return alpha + (x - 2/3) * 3 * (1 - alpha);
      }
    }

    function drawFunction() {
      const { ctx, width, height } = setupCanvas(functionCanvas);
      const padding = 50;
      const plotWidth = width - 2 * padding;
      const plotHeight = height - 2 * padding;
      const alpha = computeAlpha();

      ctx.fillStyle = '#12121A';
      ctx.fillRect(0, 0, width, height);

      // Grid
      ctx.strokeStyle = 'rgba(107, 114, 128, 0.2)';
      ctx.lineWidth = 1;
      
      // Vertical lines at 0, 1/3, 2/3, 1
      [0, 1/3, 2/3, 1].forEach(t => {
        const x = padding + t * plotWidth;
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      });

      // Horizontal lines at -1, 0, 1
      [-1, 0, 1].forEach(v => {
        const y = padding + plotHeight / 2 - (v * plotHeight / 2.5);
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
      });

      // Zero line (emphasized)
      ctx.strokeStyle = 'rgba(59, 130, 246, 0.5)';
      ctx.lineWidth = 2;
      const zeroY = padding + plotHeight / 2;
      ctx.beginPath();
      ctx.moveTo(padding, zeroY);
      ctx.lineTo(width - padding, zeroY);
      ctx.stroke();

      // Alpha line
      if (alpha !== null && Math.abs(alpha) > 0.001) {
        const alphaY = padding + plotHeight / 2 - (alpha * plotHeight / 2.5);
        ctx.strokeStyle = 'rgba(139, 92, 246, 0.3)';
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(padding, alphaY);
        ctx.lineTo(width - padding, alphaY);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Draw function
      ctx.strokeStyle = unknownMode ? '#E07B39' : '#8B5CF6';
      ctx.lineWidth = 3;
      ctx.beginPath();
      
      for (let i = 0; i <= 100; i++) {
        const t = i / 100;
        const x = padding + t * plotWidth;
        const fVal = getF(t, alpha);
        const y = padding + plotHeight / 2 - (fVal * plotHeight / 2.5);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Mark key points
      ctx.fillStyle = '#DC2626';
      // f(0) = -1
      ctx.beginPath();
      ctx.arc(padding, padding + plotHeight / 2 + plotHeight / 2.5, 5, 0, Math.PI * 2);
      ctx.fill();
      
      // f(1) = 1
      ctx.fillStyle = '#059669';
      ctx.beginPath();
      ctx.arc(width - padding, padding + plotHeight / 2 - plotHeight / 2.5, 5, 0, Math.PI * 2);
      ctx.fill();

      // Middle point
      ctx.fillStyle = unknownMode ? '#E07B39' : '#8B5CF6';
      const midY = padding + plotHeight / 2 - ((alpha || 0) * plotHeight / 2.5);
      ctx.beginPath();
      ctx.arc(padding + plotWidth / 2, midY, 5, 0, Math.PI * 2);
      ctx.fill();

      // Labels
      ctx.fillStyle = '#9CA3AF';
      ctx.font = '11px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillText('0', padding, height - padding + 15);
      ctx.fillText('⅓', padding + plotWidth / 3, height - padding + 15);
      ctx.fillText('⅔', padding + 2 * plotWidth / 3, height - padding + 15);
      ctx.fillText('1', width - padding, height - padding + 15);

      ctx.textAlign = 'right';
      ctx.fillText('-1', padding - 8, padding + plotHeight / 2 + plotHeight / 2.5 + 4);
      ctx.fillText('0', padding - 8, zeroY + 4);
      ctx.fillText('+1', padding - 8, padding + plotHeight / 2 - plotHeight / 2.5 + 4);

      if (unknownMode) {
        ctx.fillStyle = '#E07B39';
        ctx.font = '14px "JetBrains Mono"';
        ctx.textAlign = 'center';
        ctx.fillText('α = ?', padding + plotWidth / 2, midY - 15);
      }
    }

    // ============================================
    // ZERO FINDER (ZOOMING)
    // ============================================
    
    const finderCanvas = document.getElementById('finderCanvas');
    const zoomLevelEl = document.getElementById('zoomLevel');
    const centerInput = document.getElementById('centerInput');
    const finderStatus = document.getElementById('finderStatus');

    let zoomLevel = 1;
    let viewCenter = 0.5;

    function drawFinder() {
      const { ctx, width, height } = setupCanvas(finderCanvas);
      const padding = 40;
      const plotWidth = width - 2 * padding;
      const plotHeight = height - 2 * padding;
      const alpha = computeAlpha();

      ctx.fillStyle = '#0A0A0F';
      ctx.fillRect(0, 0, width, height);

      // Calculate view window
      const viewWidth = 1 / zoomLevel;
      const viewLeft = Math.max(0, viewCenter - viewWidth / 2);
      const viewRight = Math.min(1, viewCenter + viewWidth / 2);
      const actualViewWidth = viewRight - viewLeft;

      // Grid
      ctx.strokeStyle = 'rgba(107, 114, 128, 0.15)';
      ctx.lineWidth = 1;
      
      const gridStep = actualViewWidth / 10;
      for (let i = 0; i <= 10; i++) {
        const x = padding + (i / 10) * plotWidth;
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      }

      // Find y range in view
      let minY = Infinity, maxY = -Infinity;
      for (let i = 0; i <= 100; i++) {
        const t = viewLeft + (i / 100) * actualViewWidth;
        const fVal = getF(t, alpha);
        minY = Math.min(minY, fVal);
        maxY = Math.max(maxY, fVal);
      }
      
      // Add padding to y range
      const yRange = maxY - minY || 0.1;
      minY -= yRange * 0.1;
      maxY += yRange * 0.1;

      // Zero line
      if (minY <= 0 && maxY >= 0) {
        const zeroY = padding + plotHeight * (maxY / (maxY - minY));
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.6)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(padding, zeroY);
        ctx.lineTo(width - padding, zeroY);
        ctx.stroke();
      }

      // Critical lines at x = 1/3 and x = 2/3
      ctx.strokeStyle = 'rgba(224, 123, 57, 0.4)';
      ctx.setLineDash([5, 5]);
      ctx.lineWidth = 1;
      
      [1/3, 2/3].forEach(xCrit => {
        if (xCrit >= viewLeft && xCrit <= viewRight) {
          const screenX = padding + ((xCrit - viewLeft) / actualViewWidth) * plotWidth;
          ctx.beginPath();
          ctx.moveTo(screenX, padding);
          ctx.lineTo(screenX, height - padding);
          ctx.stroke();
        }
      });
      ctx.setLineDash([]);

      // Draw function
      ctx.strokeStyle = unknownMode ? '#E07B39' : '#8B5CF6';
      ctx.lineWidth = 3;
      ctx.beginPath();
      
      for (let i = 0; i <= 200; i++) {
        const t = viewLeft + (i / 200) * actualViewWidth;
        const screenX = padding + (i / 200) * plotWidth;
        const fVal = getF(t, alpha);
        const screenY = padding + plotHeight * ((maxY - fVal) / (maxY - minY));
        if (i === 0) ctx.moveTo(screenX, screenY);
        else ctx.lineTo(screenX, screenY);
      }
      ctx.stroke();

      // Labels
      ctx.fillStyle = '#9CA3AF';
      ctx.font = '10px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillText(viewLeft.toFixed(3), padding, height - padding + 15);
      ctx.fillText(viewRight.toFixed(3), width - padding, height - padding + 15);

      // Update status
      updateFinderStatus();
    }

    function updateFinderStatus() {
      const alpha = computeAlpha();
      const viewWidth = 1 / zoomLevel;
      
      if (unknownMode) {
        finderStatus.innerHTML = `<span class="warning">The sequence is unknown. Finding the exact zero would require knowing α—which depends on the first nonzero term.</span>`;
        return;
      }

      if (zoomLevel < 3) {
        finderStatus.innerHTML = `Current view: [${(viewCenter - viewWidth/2).toFixed(3)}, ${(viewCenter + viewWidth/2).toFixed(3)}]. <span class="highlight">Zoom in to locate the zero more precisely.</span>`;
      } else if (zoomLevel < 10) {
        // Check if we're near the critical region
        const nearMiddle = viewCenter > 0.25 && viewCenter < 0.75;
        if (nearMiddle && Math.abs(alpha) < 0.1) {
          finderStatus.innerHTML = `<span class="warning">The zero lies near x = ½, but whether it's left or right depends on the sign of α = ${alpha.toFixed(4)}.</span>`;
        } else {
          finderStatus.innerHTML = `Narrowing in... The zero appears to be ${alpha > 0 ? 'left of' : 'right of'} x = ½.`;
        }
      } else {
        if (Math.abs(alpha) < 0.01) {
          finderStatus.innerHTML = `<span class="warning">Critical: α ≈ ${alpha.toFixed(6)} is very small. The zero location depends on tiny variations in the sequence—any change could flip its position!</span>`;
        } else {
          const x0 = alpha > 0 ? 1 / (3 * (1 + alpha)) : 2/3 - alpha / (3 * (1 - alpha));
          finderStatus.innerHTML = `Zero located at approximately <span class="highlight">x ≈ ${x0.toFixed(6)}</span>. But this only works because α is known and nonzero.`;
        }
      }
    }

    document.getElementById('zoomIn').addEventListener('click', () => {
      zoomLevel = Math.min(100, zoomLevel * 2);
      zoomLevelEl.textContent = zoomLevel + '×';
      drawFinder();
    });

    document.getElementById('zoomOut').addEventListener('click', () => {
      zoomLevel = Math.max(1, zoomLevel / 2);
      zoomLevelEl.textContent = zoomLevel + '×';
      drawFinder();
    });

    centerInput.addEventListener('input', () => {
      viewCenter = parseFloat(centerInput.value) || 0.5;
      viewCenter = Math.max(0, Math.min(1, viewCenter));
      drawFinder();
    });

    // ============================================
    // EPSILON FINDER (CONSTRUCTIVE ALTERNATIVE)
    // ============================================
    
    const epsilonCanvas = document.getElementById('epsilonCanvas');
    const epsilonSlider = document.getElementById('epsilonSlider');
    const epsilonValueEl = document.getElementById('epsilonValue');
    const epsilonResultEl = document.getElementById('epsilonResult');

    function findApproximateZero(epsilon, alpha) {
      // Bisection method - always works constructively
      let left = 0, right = 1;
      let fLeft = getF(left, alpha);
      
      while (right - left > 0.0001) {
        const mid = (left + right) / 2;
        const fMid = getF(mid, alpha);
        
        if (Math.abs(fMid) < epsilon) {
          return mid;
        }
        
        if (fLeft * fMid < 0) {
          right = mid;
        } else {
          left = mid;
          fLeft = fMid;
        }
      }
      
      return (left + right) / 2;
    }

    function drawEpsilon() {
      const { ctx, width, height } = setupCanvas(epsilonCanvas);
      const padding = 50;
      const plotWidth = width - 2 * padding;
      const plotHeight = height - 2 * padding;
      const alpha = computeAlpha() || 0;
      const epsilon = parseFloat(epsilonSlider.value);

      ctx.fillStyle = '#1A2A22';
      ctx.fillRect(0, 0, width, height);

      // Grid
      ctx.strokeStyle = 'rgba(74, 157, 124, 0.15)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 10; i++) {
        const x = padding + (i / 10) * plotWidth;
        ctx.beginPath();
        ctx.moveTo(x, padding);
        ctx.lineTo(x, height - padding);
        ctx.stroke();
      }

      // Zero line
      const zeroY = padding + plotHeight / 2;
      ctx.strokeStyle = 'rgba(59, 130, 246, 0.4)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, zeroY);
      ctx.lineTo(width - padding, zeroY);
      ctx.stroke();

      // Epsilon band
      const epsilonPixels = (epsilon / 2.5) * plotHeight;
      ctx.fillStyle = 'rgba(74, 157, 124, 0.2)';
      ctx.fillRect(padding, zeroY - epsilonPixels, plotWidth, epsilonPixels * 2);

      ctx.strokeStyle = 'rgba(74, 157, 124, 0.6)';
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(padding, zeroY - epsilonPixels);
      ctx.lineTo(width - padding, zeroY - epsilonPixels);
      ctx.moveTo(padding, zeroY + epsilonPixels);
      ctx.lineTo(width - padding, zeroY + epsilonPixels);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw function
      ctx.strokeStyle = '#4A9D7C';
      ctx.lineWidth = 3;
      ctx.beginPath();
      
      for (let i = 0; i <= 100; i++) {
        const t = i / 100;
        const x = padding + t * plotWidth;
        const fVal = getF(t, alpha);
        const y = zeroY - (fVal * plotHeight / 2.5);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Find and mark approximate zero
      const approxZero = findApproximateZero(epsilon, alpha);
      const approxX = padding + approxZero * plotWidth;
      const approxY = zeroY - (getF(approxZero, alpha) * plotHeight / 2.5);

      ctx.fillStyle = '#4A9D7C';
      ctx.beginPath();
      ctx.arc(approxX, approxY, 8, 0, Math.PI * 2);
      ctx.fill();

      // Vertical line to show x position
      ctx.strokeStyle = 'rgba(74, 157, 124, 0.5)';
      ctx.setLineDash([3, 3]);
      ctx.beginPath();
      ctx.moveTo(approxX, padding);
      ctx.lineTo(approxX, height - padding);
      ctx.stroke();
      ctx.setLineDash([]);

      // Labels
      ctx.fillStyle = '#9CA3AF';
      ctx.font = '10px "JetBrains Mono"';
      ctx.textAlign = 'center';
      ctx.fillText('0', padding, height - padding + 15);
      ctx.fillText('1', width - padding, height - padding + 15);

      ctx.textAlign = 'right';
      ctx.fillText('+ε', padding - 5, zeroY - epsilonPixels + 4);
      ctx.fillText('-ε', padding - 5, zeroY + epsilonPixels + 4);

      // Update result
      const fAtApprox = getF(approxZero, alpha);
      epsilonResultEl.textContent = `x = ${approxZero.toFixed(4)} satisfies |f(x)| = ${Math.abs(fAtApprox).toFixed(4)} < ${epsilon.toFixed(2)}`;
    }

    epsilonSlider.addEventListener('input', () => {
      const epsilon = parseFloat(epsilonSlider.value);
      epsilonValueEl.textContent = epsilon.toFixed(2);
      drawEpsilon();
    });

    // ============================================
    // INITIALIZE
    // ============================================
    
    buildSequenceUI();
    updateAll();

    window.addEventListener('resize', () => {
      drawClassicalIVT();
      drawFunction();
      drawFinder();
      drawEpsilon();
    });
  </script>
</body>
</html>
