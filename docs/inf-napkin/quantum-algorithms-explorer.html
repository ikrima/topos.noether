<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Part VII: Quantum Algorithms - Interactive Explorer</title>
    <style>
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --text-primary: #e8e8f0;
            --text-secondary: #a0a0b0;
            --accent-1: #8b5cf6;
            --accent-2: #06b6d4;
            --accent-3: #f59e0b;
            --accent-4: #10b981;
            --accent-5: #ef4444;
            --border-color: #2a2a3a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.7;
            min-height: 100vh;
        }

        header {
            background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 3rem 2rem;
            border-bottom: 1px solid var(--border-color);
            text-align: center;
        }

        header h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--accent-1), var(--accent-2));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        main {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .intro {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
        }

        .intro h2 {
            color: var(--accent-2);
            margin-bottom: 1rem;
        }

        .key-insight {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(6, 182, 212, 0.1));
            border-left: 4px solid var(--accent-1);
            padding: 1rem 1.5rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        .section {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
        }

        .section h2 {
            color: var(--accent-1);
            margin-bottom: 1.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .section h2::before {
            content: '';
            width: 4px;
            height: 1.5em;
            background: linear-gradient(180deg, var(--accent-1), var(--accent-2));
            border-radius: 2px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        select, button, input {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"] {
            cursor: grab;
            width: 150px;
        }

        select:hover, button:hover {
            border-color: var(--accent-1);
        }

        button {
            background: linear-gradient(135deg, var(--accent-1), #a855f7);
            border: none;
            font-weight: 500;
        }

        button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }

        button.secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
        }

        .visualization-area {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 1.5rem;
            min-height: 300px;
            position: relative;
        }

        canvas {
            display: block;
            margin: 0 auto;
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
        }

        .grid-3 {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
        }

        @media (max-width: 900px) {
            .grid-2, .grid-3 {
                grid-template-columns: 1fr;
            }
        }

        .result-box {
            background: var(--bg-tertiary);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .result-box h4 {
            color: var(--accent-4);
            margin-bottom: 0.5rem;
        }

        .state-display {
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            padding: 1rem;
            background: var(--bg-primary);
            border-radius: 6px;
            text-align: center;
            margin: 0.5rem 0;
        }

        .ket {
            color: var(--accent-2);
        }

        .amplitude {
            color: var(--accent-3);
        }

        .probability-bar {
            height: 30px;
            background: var(--bg-primary);
            border-radius: 4px;
            margin: 0.5rem 0;
            position: relative;
            overflow: hidden;
        }

        .probability-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-1), var(--accent-2));
            transition: width 0.3s ease;
        }

        .probability-label {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .gate-button {
            padding: 0.75rem 1rem;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }

        .circuit-display {
            background: var(--bg-primary);
            border-radius: 8px;
            padding: 1.5rem;
            overflow-x: auto;
        }

        .wire {
            display: flex;
            align-items: center;
            margin: 0.5rem 0;
            min-height: 50px;
        }

        .wire-label {
            width: 60px;
            font-family: 'Courier New', monospace;
            color: var(--accent-2);
        }

        .wire-line {
            flex: 1;
            height: 2px;
            background: var(--text-secondary);
            position: relative;
            display: flex;
            align-items: center;
        }

        .gate-box {
            background: var(--accent-1);
            color: white;
            padding: 0.5rem;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
            z-index: 1;
        }

        .control-dot {
            width: 12px;
            height: 12px;
            background: var(--accent-3);
            border-radius: 50%;
            z-index: 1;
        }

        .measurement {
            width: 40px;
            height: 30px;
            border: 2px solid var(--accent-3);
            border-radius: 4px;
            position: relative;
            z-index: 1;
            background: var(--bg-tertiary);
        }

        .measurement::after {
            content: '';
            position: absolute;
            bottom: 5px;
            left: 50%;
            width: 15px;
            height: 15px;
            border: 2px solid var(--accent-3);
            border-bottom: none;
            border-left: none;
            transform: translateX(-50%) rotate(-45deg);
        }

        .theorem-box {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(239, 68, 68, 0.1));
            border-left: 4px solid var(--accent-3);
            padding: 1rem 1.5rem;
            margin: 1rem 0;
            border-radius: 0 8px 8px 0;
        }

        .theorem-box h4 {
            color: var(--accent-3);
            margin-bottom: 0.5rem;
        }

        .matrix {
            display: inline-grid;
            gap: 2px;
            background: var(--border-color);
            padding: 2px;
            border-radius: 4px;
            margin: 0.5rem;
        }

        .matrix-cell {
            background: var(--bg-tertiary);
            padding: 0.4rem 0.6rem;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
        }

        .bloch-container {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 0 auto;
        }

        .formula {
            font-family: 'Times New Roman', serif;
            font-size: 1.1rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            text-align: center;
            margin: 1rem 0;
        }

        .step-indicator {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .step {
            padding: 0.5rem 1rem;
            background: var(--bg-tertiary);
            border-radius: 20px;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .step.active {
            background: var(--accent-1);
            color: white;
        }

        .step.completed {
            background: var(--accent-4);
            color: white;
        }

        .check-mark {
            color: var(--accent-4);
        }

        .legend {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 0.85rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
        }

        .collapse-animation {
            animation: collapse 0.5s ease-out;
        }

        @keyframes collapse {
            0% { opacity: 0.5; transform: scale(1.1); }
            100% { opacity: 1; transform: scale(1); }
        }

        .entangled {
            animation: entangle 1s ease-in-out infinite alternate;
        }

        @keyframes entangle {
            0% { box-shadow: 0 0 10px rgba(139, 92, 246, 0.5); }
            100% { box-shadow: 0 0 20px rgba(6, 182, 212, 0.5); }
        }
    </style>
</head>
<body>
    <header>
        <h1>Part VII: Quantum Algorithms</h1>
        <p>Chapters 23-25: Quantum States, Circuits, and Shor's Algorithm</p>
    </header>

    <main>
        <div class="intro">
            <h2>The Quantum Computing Revolution</h2>
            <p>
                Quantum computing harnesses the strange properties of quantum mechanics —
                <strong>superposition</strong> and <strong>entanglement</strong> — to perform
                computations that would be impossible for classical computers. Instead of bits
                that are 0 or 1, we have <em>qubits</em> that can be complex linear combinations of both.
            </p>
            <div class="key-insight">
                <strong>Core Idea:</strong> A qubit |ψ⟩ = α|0⟩ + β|1⟩ exists in a superposition
                of states. Upon measurement, it collapses to |0⟩ with probability |α|² or |1⟩
                with probability |β|². Quantum gates are unitary transformations that manipulate
                these superpositions.
            </div>
        </div>

        <!-- Section 1: Qubit States -->
        <div class="section">
            <h2>Qubit States and the Bloch Sphere</h2>
            <p>
                A single qubit lives in a 2D complex vector space. After normalization, its state
                can be visualized as a point on the <strong>Bloch sphere</strong>.
            </p>

            <div class="grid-2">
                <div>
                    <div class="controls">
                        <div class="control-group">
                            <label>θ (polar angle)</label>
                            <input type="range" id="thetaSlider" min="0" max="180" value="90">
                            <span id="thetaValue">90°</span>
                        </div>
                        <div class="control-group">
                            <label>φ (azimuthal angle)</label>
                            <input type="range" id="phiSlider" min="0" max="360" value="0">
                            <span id="phiValue">0°</span>
                        </div>
                    </div>

                    <div class="result-box">
                        <h4>Qubit State |ψ⟩</h4>
                        <div class="state-display" id="qubitState">|ψ⟩ = |+⟩</div>
                        <div class="formula">
                            |ψ⟩ = cos(θ/2)|0⟩ + e<sup>iφ</sup>sin(θ/2)|1⟩
                        </div>
                    </div>

                    <div class="result-box">
                        <h4>Measurement Probabilities (Z-basis)</h4>
                        <div>
                            <span>|0⟩:</span>
                            <div class="probability-bar">
                                <div class="probability-fill" id="prob0Fill" style="width: 50%"></div>
                                <span class="probability-label" id="prob0Label">50%</span>
                            </div>
                        </div>
                        <div>
                            <span>|1⟩:</span>
                            <div class="probability-bar">
                                <div class="probability-fill" id="prob1Fill" style="width: 50%"></div>
                                <span class="probability-label" id="prob1Label">50%</span>
                            </div>
                        </div>
                    </div>

                    <div class="controls" style="margin-top: 1rem;">
                        <button onclick="setQubitState(0, 0)">|0⟩ (North)</button>
                        <button onclick="setQubitState(180, 0)">|1⟩ (South)</button>
                        <button onclick="setQubitState(90, 0)">|+⟩</button>
                        <button onclick="setQubitState(90, 180)">|-⟩</button>
                    </div>
                </div>

                <div class="visualization-area">
                    <canvas id="blochCanvas" width="300" height="300"></canvas>
                    <div class="legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background: #ef4444;"></div>
                            <span>X-axis</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #10b981;"></div>
                            <span>Y-axis</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #3b82f6;"></div>
                            <span>Z-axis</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f59e0b;"></div>
                            <span>State vector</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 2: Quantum Gates -->
        <div class="section">
            <h2>Quantum Gates</h2>
            <p>
                Quantum gates are unitary matrices that transform qubit states. Unlike classical
                gates, they are always reversible.
            </p>

            <div class="grid-2">
                <div>
                    <h4 style="color: var(--accent-2); margin-bottom: 1rem;">Single-Qubit Gates</h4>
                    <div class="controls">
                        <button class="gate-button" onclick="applyGate('H')">H</button>
                        <button class="gate-button" onclick="applyGate('X')">X</button>
                        <button class="gate-button" onclick="applyGate('Y')">Y</button>
                        <button class="gate-button" onclick="applyGate('Z')">Z</button>
                        <button class="gate-button" onclick="applyGate('S')">S</button>
                        <button class="gate-button" onclick="applyGate('T')">T</button>
                        <button class="secondary" onclick="resetGateDemo()">Reset</button>
                    </div>

                    <div class="result-box">
                        <h4>Current State</h4>
                        <div class="state-display" id="gateState">|ψ⟩ = |0⟩</div>
                    </div>

                    <div id="gateMatrixDisplay" class="result-box">
                        <h4>Gate Matrix</h4>
                        <div style="text-align: center;">Select a gate to see its matrix</div>
                    </div>
                </div>

                <div>
                    <h4 style="color: var(--accent-2); margin-bottom: 1rem;">Gate Definitions</h4>
                    <div class="result-box">
                        <p><strong>Hadamard (H):</strong> Creates superposition</p>
                        <div style="text-align: center;">
                            H|0⟩ = |+⟩ = (|0⟩ + |1⟩)/√2
                        </div>
                    </div>
                    <div class="result-box">
                        <p><strong>Pauli-X:</strong> Bit flip (quantum NOT)</p>
                        <div style="text-align: center;">X|0⟩ = |1⟩, X|1⟩ = |0⟩</div>
                    </div>
                    <div class="result-box">
                        <p><strong>Pauli-Z:</strong> Phase flip</p>
                        <div style="text-align: center;">Z|0⟩ = |0⟩, Z|1⟩ = -|1⟩</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 3: Measurement -->
        <div class="section">
            <h2>Quantum Measurement and Collapse</h2>
            <p>
                When we measure a qubit, the superposition collapses to a definite state.
                The measurement destroys information — we can never recover the original amplitudes.
            </p>

            <div class="controls">
                <div class="control-group">
                    <label>Initial State</label>
                    <select id="measureStateSelect">
                        <option value="plus">|+⟩ = (|0⟩ + |1⟩)/√2</option>
                        <option value="minus">|-⟩ = (|0⟩ - |1⟩)/√2</option>
                        <option value="custom">Custom: 0.6|0⟩ + 0.8|1⟩</option>
                        <option value="zero">|0⟩</option>
                        <option value="one">|1⟩</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Measurement Basis</label>
                    <select id="measureBasisSelect">
                        <option value="Z">Z-basis (|0⟩, |1⟩)</option>
                        <option value="X">X-basis (|+⟩, |-⟩)</option>
                    </select>
                </div>
                <button onclick="simulateMeasurement()">Measure!</button>
                <button class="secondary" onclick="runManyMeasurements()">Run 100 times</button>
            </div>

            <div class="grid-2">
                <div class="result-box">
                    <h4>Single Measurement Result</h4>
                    <div class="state-display collapse-animation" id="measureResult">
                        Click "Measure!" to collapse the state
                    </div>
                    <p id="measureExplanation" style="margin-top: 0.5rem; color: var(--text-secondary);"></p>
                </div>

                <div class="result-box">
                    <h4>Statistics (100 measurements)</h4>
                    <div id="measureStats">
                        <div>
                            <span>Outcome 0:</span>
                            <div class="probability-bar">
                                <div class="probability-fill" id="stat0Fill" style="width: 0%"></div>
                                <span class="probability-label" id="stat0Label">—</span>
                            </div>
                        </div>
                        <div>
                            <span>Outcome 1:</span>
                            <div class="probability-bar">
                                <div class="probability-fill" id="stat1Fill" style="width: 0%"></div>
                                <span class="probability-label" id="stat1Label">—</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Section 4: Entanglement -->
        <div class="section">
            <h2>Entanglement: Spooky Action at a Distance</h2>
            <p>
                When qubits interact, they can become <strong>entangled</strong> — their states
                become correlated in ways that cannot be described independently. Measuring one
                qubit instantly affects the other, even at a distance.
            </p>

            <div class="controls">
                <div class="control-group">
                    <label>Bell State</label>
                    <select id="bellStateSelect">
                        <option value="phi_plus">|Φ+⟩ = (|00⟩ + |11⟩)/√2</option>
                        <option value="phi_minus">|Φ-⟩ = (|00⟩ - |11⟩)/√2</option>
                        <option value="psi_plus">|Ψ+⟩ = (|01⟩ + |10⟩)/√2</option>
                        <option value="psi_minus">|Ψ-⟩ = (|01⟩ - |10⟩)/√2 (Singlet)</option>
                    </select>
                </div>
                <button onclick="measureEntangled('A')">Measure Qubit A</button>
                <button onclick="measureEntangled('B')">Measure Qubit B</button>
                <button class="secondary" onclick="resetEntangled()">Reset</button>
            </div>

            <div class="grid-2">
                <div class="result-box entangled" id="qubitABox">
                    <h4>Qubit A</h4>
                    <div class="state-display" id="qubitAState">Entangled</div>
                </div>
                <div class="result-box entangled" id="qubitBBox">
                    <h4>Qubit B</h4>
                    <div class="state-display" id="qubitBState">Entangled</div>
                </div>
            </div>

            <div class="result-box" style="margin-top: 1rem;">
                <h4>Combined State</h4>
                <div class="state-display" id="entangledState">|Φ+⟩ = (|00⟩ + |11⟩)/√2</div>
                <p id="entanglementExplanation" style="margin-top: 0.5rem; color: var(--text-secondary);">
                    The qubits are maximally entangled. Measuring one will instantly determine the other.
                </p>
            </div>

            <div class="theorem-box">
                <h4>No-Cloning Theorem</h4>
                <p>
                    It is impossible to create an exact copy of an arbitrary unknown quantum state.
                    This is fundamentally different from classical bits which can be freely copied.
                </p>
            </div>
        </div>

        <!-- Section 5: Quantum Circuits -->
        <div class="section">
            <h2>Quantum Circuit Simulator</h2>
            <p>
                Build quantum circuits by adding gates. See how the state evolves through
                each operation.
            </p>

            <div class="controls">
                <button onclick="addCircuitGate('H', 0)">H on q0</button>
                <button onclick="addCircuitGate('X', 0)">X on q0</button>
                <button onclick="addCircuitGate('H', 1)">H on q1</button>
                <button onclick="addCircuitGate('X', 1)">X on q1</button>
                <button onclick="addCircuitGate('CNOT', 0)">CNOT (q0 ctrl)</button>
                <button class="secondary" onclick="resetCircuit()">Clear Circuit</button>
                <button onclick="runCircuit()">Run Circuit</button>
            </div>

            <div class="circuit-display" id="circuitDisplay">
                <div class="wire">
                    <span class="wire-label">|0⟩ q0</span>
                    <div class="wire-line" id="wire0"></div>
                </div>
                <div class="wire">
                    <span class="wire-label">|0⟩ q1</span>
                    <div class="wire-line" id="wire1"></div>
                </div>
            </div>

            <div class="result-box" style="margin-top: 1rem;">
                <h4>Output State</h4>
                <div class="state-display" id="circuitOutput">|00⟩</div>
            </div>

            <div class="theorem-box">
                <h4>Universal Gate Sets</h4>
                <p>
                    The set {H, T, CNOT} is universal — any quantum computation can be approximated
                    to arbitrary precision using only these gates. This is analogous to how
                    {AND, OR, NOT} is universal for classical computation.
                </p>
            </div>
        </div>

        <!-- Section 6: Deutsch-Jozsa -->
        <div class="section">
            <h2>Deutsch-Jozsa Algorithm</h2>
            <p>
                The first quantum algorithm to demonstrate exponential speedup over classical computation.
                Given a black-box function f: {0,1} → {0,1}, determine if f is constant or balanced
                in just <strong>one query</strong> (classically requires 2 queries in the worst case).
            </p>

            <div class="controls">
                <div class="control-group">
                    <label>Function f</label>
                    <select id="djFunctionSelect">
                        <option value="const0">Constant: f(x) = 0</option>
                        <option value="const1">Constant: f(x) = 1</option>
                        <option value="identity">Balanced: f(x) = x</option>
                        <option value="not">Balanced: f(x) = NOT x</option>
                    </select>
                </div>
                <button onclick="runDeutschJozsa()">Run Algorithm</button>
            </div>

            <div class="step-indicator" id="djSteps">
                <div class="step" data-step="1">1. Initialize</div>
                <div class="step" data-step="2">2. Hadamard</div>
                <div class="step" data-step="3">3. Oracle Uf</div>
                <div class="step" data-step="4">4. Hadamard</div>
                <div class="step" data-step="5">5. Measure</div>
            </div>

            <div class="result-box">
                <h4>Circuit State Evolution</h4>
                <div class="state-display" id="djState">|0⟩ ⊗ |1⟩</div>
            </div>

            <div class="result-box" style="margin-top: 1rem;">
                <h4>Result</h4>
                <div id="djResult" style="font-size: 1.2rem;">
                    Click "Run Algorithm" to determine if f is constant or balanced
                </div>
            </div>
        </div>

        <!-- Section 7: Quantum Fourier Transform -->
        <div class="section">
            <h2>Quantum Fourier Transform</h2>
            <p>
                The QFT transforms the amplitudes of a quantum state according to the discrete
                Fourier transform. It's the key ingredient in Shor's algorithm, running in
                O(n²) gates instead of O(N log N) classical operations.
            </p>

            <div class="controls">
                <div class="control-group">
                    <label>Input State (3 qubits)</label>
                    <select id="qftInputSelect">
                        <option value="0">|000⟩</option>
                        <option value="1">|001⟩</option>
                        <option value="2">|010⟩</option>
                        <option value="3">|011⟩</option>
                        <option value="4">|100⟩</option>
                        <option value="5">|101⟩</option>
                        <option value="6">|110⟩</option>
                        <option value="7">|111⟩</option>
                    </select>
                </div>
                <button onclick="runQFT()">Apply QFT</button>
            </div>

            <div class="grid-2">
                <div class="result-box">
                    <h4>Input State</h4>
                    <div class="state-display" id="qftInput">|000⟩</div>
                </div>
                <div class="result-box">
                    <h4>Output State (QFT)</h4>
                    <div class="state-display" id="qftOutput">—</div>
                </div>
            </div>

            <div class="formula" style="margin-top: 1rem;">
                QFT|x⟩ = (1/√N) Σ<sub>k</sub> ω<sub>N</sub><sup>xk</sup> |k⟩ where ω<sub>N</sub> = e<sup>2πi/N</sup>
            </div>

            <div class="result-box" style="margin-top: 1rem;">
                <h4>Output Amplitudes</h4>
                <div id="qftAmplitudes"></div>
            </div>
        </div>

        <!-- Section 8: Shor's Algorithm -->
        <div class="section">
            <h2>Shor's Algorithm: Factoring Integers</h2>
            <p>
                Shor's algorithm factors an integer N = pq in polynomial time O((log N)²),
                threatening RSA encryption which relies on factoring being hard.
            </p>

            <div class="controls">
                <div class="control-group">
                    <label>Number to Factor</label>
                    <select id="shorNumberSelect">
                        <option value="15">15 = 3 × 5</option>
                        <option value="21">21 = 3 × 7</option>
                        <option value="35">35 = 5 × 7</option>
                        <option value="77">77 = 7 × 11</option>
                    </select>
                </div>
                <button onclick="runShorDemo()">Run Shor's Algorithm</button>
            </div>

            <div class="step-indicator" id="shorSteps">
                <div class="step" data-step="1">1. Pick random x</div>
                <div class="step" data-step="2">2. Compute order r</div>
                <div class="step" data-step="3">3. Check conditions</div>
                <div class="step" data-step="4">4. Compute GCD</div>
            </div>

            <div class="result-box">
                <h4>Algorithm Progress</h4>
                <div id="shorProgress"></div>
            </div>

            <div class="result-box" style="margin-top: 1rem;">
                <h4>Factorization Result</h4>
                <div class="state-display" id="shorResult">
                    Click "Run" to factor the number
                </div>
            </div>

            <div class="theorem-box">
                <h4>Key Insight</h4>
                <p>
                    Shor's algorithm converts factoring into period-finding: find the order r of
                    a random x mod N, then use gcd(x<sup>r/2</sup> - 1, N) to extract factors.
                    The quantum speedup comes from the QFT detecting periodicity.
                </p>
            </div>
        </div>
    </main>

    <script>
        // ============================================
        // BLOCH SPHERE VISUALIZATION
        // ============================================

        let theta = 90, phi = 0;

        function initBlochSphere() {
            const thetaSlider = document.getElementById('thetaSlider');
            const phiSlider = document.getElementById('phiSlider');

            thetaSlider.addEventListener('input', () => {
                theta = parseFloat(thetaSlider.value);
                document.getElementById('thetaValue').textContent = theta + '°';
                updateBlochSphere();
            });

            phiSlider.addEventListener('input', () => {
                phi = parseFloat(phiSlider.value);
                document.getElementById('phiValue').textContent = phi + '°';
                updateBlochSphere();
            });

            updateBlochSphere();
        }

        function setQubitState(t, p) {
            theta = t;
            phi = p;
            document.getElementById('thetaSlider').value = t;
            document.getElementById('phiSlider').value = p;
            document.getElementById('thetaValue').textContent = t + '°';
            document.getElementById('phiValue').textContent = p + '°';
            updateBlochSphere();
        }

        function updateBlochSphere() {
            const canvas = document.getElementById('blochCanvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const cx = w / 2, cy = h / 2;
            const r = 100;

            ctx.clearRect(0, 0, w, h);

            // Draw sphere outline
            ctx.strokeStyle = '#4a4a5a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cx, cy, r, 0, 2 * Math.PI);
            ctx.stroke();

            // Draw equator
            ctx.beginPath();
            ctx.ellipse(cx, cy, r, r * 0.3, 0, 0, 2 * Math.PI);
            ctx.stroke();

            // Draw axes
            const axisLen = r * 1.2;

            // Z-axis (blue)
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx, cy + r);
            ctx.lineTo(cx, cy - r);
            ctx.stroke();
            ctx.fillStyle = '#3b82f6';
            ctx.font = '12px sans-serif';
            ctx.fillText('|0⟩', cx + 5, cy - r - 5);
            ctx.fillText('|1⟩', cx + 5, cy + r + 15);

            // X-axis (red)
            ctx.strokeStyle = '#ef4444';
            ctx.beginPath();
            ctx.moveTo(cx - r, cy);
            ctx.lineTo(cx + r, cy);
            ctx.stroke();
            ctx.fillStyle = '#ef4444';
            ctx.fillText('|+⟩', cx + r + 5, cy);
            ctx.fillText('|-⟩', cx - r - 20, cy);

            // Y-axis (green, going into screen)
            ctx.strokeStyle = '#10b981';
            ctx.setLineDash([3, 3]);
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx + r * 0.3, cy + r * 0.3);
            ctx.stroke();
            ctx.setLineDash([]);

            // Calculate state vector position
            const thetaRad = theta * Math.PI / 180;
            const phiRad = phi * Math.PI / 180;

            const x = Math.sin(thetaRad) * Math.cos(phiRad);
            const y = Math.sin(thetaRad) * Math.sin(phiRad);
            const z = Math.cos(thetaRad);

            // Project to 2D (simple orthographic)
            const px = cx + r * x;
            const py = cy - r * z;

            // Draw state vector
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(cx, cy);
            ctx.lineTo(px, py);
            ctx.stroke();

            // Draw point
            ctx.fillStyle = '#f59e0b';
            ctx.beginPath();
            ctx.arc(px, py, 8, 0, 2 * Math.PI);
            ctx.fill();

            // Update state display
            updateQubitStateDisplay();
        }

        function updateQubitStateDisplay() {
            const thetaRad = theta * Math.PI / 180;
            const phiRad = phi * Math.PI / 180;

            const alpha = Math.cos(thetaRad / 2);
            const betaReal = Math.sin(thetaRad / 2) * Math.cos(phiRad);
            const betaImag = Math.sin(thetaRad / 2) * Math.sin(phiRad);

            let stateStr = '';
            if (Math.abs(alpha) > 0.001) {
                stateStr += `${alpha.toFixed(2)}|0⟩`;
            }
            if (Math.abs(betaReal) > 0.001 || Math.abs(betaImag) > 0.001) {
                if (stateStr && betaReal >= 0) stateStr += ' + ';
                else if (stateStr) stateStr += ' ';

                if (Math.abs(betaImag) < 0.001) {
                    stateStr += `${betaReal.toFixed(2)}|1⟩`;
                } else if (Math.abs(betaReal) < 0.001) {
                    stateStr += `${betaImag.toFixed(2)}i|1⟩`;
                } else {
                    stateStr += `(${betaReal.toFixed(2)}+${betaImag.toFixed(2)}i)|1⟩`;
                }
            }

            // Named states
            if (theta === 0) stateStr = '|0⟩';
            else if (theta === 180) stateStr = '|1⟩';
            else if (theta === 90 && phi === 0) stateStr = '|+⟩ = (|0⟩ + |1⟩)/√2';
            else if (theta === 90 && phi === 180) stateStr = '|-⟩ = (|0⟩ - |1⟩)/√2';

            document.getElementById('qubitState').textContent = '|ψ⟩ = ' + stateStr;

            // Update probabilities
            const prob0 = Math.cos(thetaRad / 2) ** 2;
            const prob1 = Math.sin(thetaRad / 2) ** 2;

            document.getElementById('prob0Fill').style.width = (prob0 * 100) + '%';
            document.getElementById('prob1Fill').style.width = (prob1 * 100) + '%';
            document.getElementById('prob0Label').textContent = (prob0 * 100).toFixed(1) + '%';
            document.getElementById('prob1Label').textContent = (prob1 * 100).toFixed(1) + '%';
        }

        // ============================================
        // QUANTUM GATES
        // ============================================

        let gateState = { alpha: 1, beta: 0 }; // Start at |0⟩

        const gates = {
            H: {
                name: 'Hadamard',
                matrix: [[1/Math.sqrt(2), 1/Math.sqrt(2)], [1/Math.sqrt(2), -1/Math.sqrt(2)]],
                apply: (a, b) => [(a + b) / Math.sqrt(2), (a - b) / Math.sqrt(2)]
            },
            X: {
                name: 'Pauli-X',
                matrix: [[0, 1], [1, 0]],
                apply: (a, b) => [b, a]
            },
            Y: {
                name: 'Pauli-Y',
                matrix: [[0, {re: 0, im: -1}], [{re: 0, im: 1}, 0]],
                apply: (a, b) => [{re: 0, im: -1} * b, {re: 0, im: 1} * a]
            },
            Z: {
                name: 'Pauli-Z',
                matrix: [[1, 0], [0, -1]],
                apply: (a, b) => [a, -b]
            },
            S: {
                name: 'S (√Z)',
                matrix: [[1, 0], [0, 'i']],
                apply: (a, b) => [a, {re: 0, im: 1}]
            },
            T: {
                name: 'T (π/8)',
                matrix: [[1, 0], [0, 'e^(iπ/4)']],
                apply: (a, b) => [a, b * Math.exp(Math.PI / 4)]
            }
        };

        function applyGate(gateName) {
            const gate = gates[gateName];
            if (!gate) return;

            // Simplified: just cycle through named states for demo
            const a = gateState.alpha;
            const b = gateState.beta;

            if (gateName === 'H') {
                gateState.alpha = (a + b) / Math.sqrt(2);
                gateState.beta = (a - b) / Math.sqrt(2);
            } else if (gateName === 'X') {
                gateState.alpha = b;
                gateState.beta = a;
            } else if (gateName === 'Z') {
                gateState.beta = -gateState.beta;
            }

            updateGateDisplay(gateName);
        }

        function updateGateDisplay(gateName) {
            const a = gateState.alpha;
            const b = gateState.beta;

            let stateStr = '';
            if (Math.abs(a) > 0.001) stateStr += `${a.toFixed(3)}|0⟩`;
            if (Math.abs(b) > 0.001) {
                if (stateStr && b > 0) stateStr += ' + ';
                stateStr += `${b.toFixed(3)}|1⟩`;
            }
            if (!stateStr) stateStr = '0';

            // Simplify common states
            if (Math.abs(a - 1) < 0.01 && Math.abs(b) < 0.01) stateStr = '|0⟩';
            else if (Math.abs(a) < 0.01 && Math.abs(b - 1) < 0.01) stateStr = '|1⟩';
            else if (Math.abs(a - 1/Math.sqrt(2)) < 0.01 && Math.abs(b - 1/Math.sqrt(2)) < 0.01)
                stateStr = '|+⟩';
            else if (Math.abs(a - 1/Math.sqrt(2)) < 0.01 && Math.abs(b + 1/Math.sqrt(2)) < 0.01)
                stateStr = '|-⟩';

            document.getElementById('gateState').textContent = '|ψ⟩ = ' + stateStr;

            // Show matrix
            if (gateName && gates[gateName]) {
                const m = gates[gateName].matrix;
                document.getElementById('gateMatrixDisplay').innerHTML = `
                    <h4>${gates[gateName].name} Gate</h4>
                    <div class="matrix" style="grid-template-columns: repeat(2, 1fr);">
                        <div class="matrix-cell">${formatMatrixEntry(m[0][0])}</div>
                        <div class="matrix-cell">${formatMatrixEntry(m[0][1])}</div>
                        <div class="matrix-cell">${formatMatrixEntry(m[1][0])}</div>
                        <div class="matrix-cell">${formatMatrixEntry(m[1][1])}</div>
                    </div>
                `;
            }
        }

        function formatMatrixEntry(v) {
            if (typeof v === 'number') {
                if (Math.abs(v) < 0.001) return '0';
                if (Math.abs(v - 1) < 0.001) return '1';
                if (Math.abs(v + 1) < 0.001) return '-1';
                if (Math.abs(v - 1/Math.sqrt(2)) < 0.001) return '1/√2';
                if (Math.abs(v + 1/Math.sqrt(2)) < 0.001) return '-1/√2';
                return v.toFixed(2);
            }
            return v;
        }

        function resetGateDemo() {
            gateState = { alpha: 1, beta: 0 };
            document.getElementById('gateState').textContent = '|ψ⟩ = |0⟩';
            document.getElementById('gateMatrixDisplay').innerHTML = `
                <h4>Gate Matrix</h4>
                <div style="text-align: center;">Select a gate to see its matrix</div>
            `;
        }

        // ============================================
        // MEASUREMENT
        // ============================================

        function simulateMeasurement() {
            const stateType = document.getElementById('measureStateSelect').value;
            const basis = document.getElementById('measureBasisSelect').value;

            let prob0 = 0.5;

            if (stateType === 'plus') prob0 = basis === 'Z' ? 0.5 : 1;
            else if (stateType === 'minus') prob0 = basis === 'Z' ? 0.5 : 0;
            else if (stateType === 'custom') prob0 = basis === 'Z' ? 0.36 : 0.5;
            else if (stateType === 'zero') prob0 = basis === 'Z' ? 1 : 0.5;
            else if (stateType === 'one') prob0 = basis === 'Z' ? 0 : 0.5;

            const result = Math.random() < prob0 ? 0 : 1;

            const resultDiv = document.getElementById('measureResult');
            resultDiv.classList.remove('collapse-animation');
            void resultDiv.offsetWidth; // Trigger reflow
            resultDiv.classList.add('collapse-animation');

            if (basis === 'Z') {
                resultDiv.textContent = result === 0 ? 'Collapsed to |0⟩' : 'Collapsed to |1⟩';
            } else {
                resultDiv.textContent = result === 0 ? 'Collapsed to |+⟩' : 'Collapsed to |-⟩';
            }

            document.getElementById('measureExplanation').textContent =
                `Measured with probability ${(result === 0 ? prob0 : 1 - prob0) * 100}%`;
        }

        function runManyMeasurements() {
            const stateType = document.getElementById('measureStateSelect').value;
            const basis = document.getElementById('measureBasisSelect').value;

            let prob0 = 0.5;
            if (stateType === 'plus') prob0 = basis === 'Z' ? 0.5 : 1;
            else if (stateType === 'minus') prob0 = basis === 'Z' ? 0.5 : 0;
            else if (stateType === 'custom') prob0 = basis === 'Z' ? 0.36 : 0.5;
            else if (stateType === 'zero') prob0 = basis === 'Z' ? 1 : 0.5;
            else if (stateType === 'one') prob0 = basis === 'Z' ? 0 : 0.5;

            let count0 = 0;
            for (let i = 0; i < 100; i++) {
                if (Math.random() < prob0) count0++;
            }

            document.getElementById('stat0Fill').style.width = count0 + '%';
            document.getElementById('stat1Fill').style.width = (100 - count0) + '%';
            document.getElementById('stat0Label').textContent = count0 + '/100';
            document.getElementById('stat1Label').textContent = (100 - count0) + '/100';
        }

        // ============================================
        // ENTANGLEMENT
        // ============================================

        let entangledState = { type: 'phi_plus', measured: null };

        function resetEntangled() {
            entangledState = { type: document.getElementById('bellStateSelect').value, measured: null };

            const states = {
                'phi_plus': '|Φ+⟩ = (|00⟩ + |11⟩)/√2',
                'phi_minus': '|Φ-⟩ = (|00⟩ - |11⟩)/√2',
                'psi_plus': '|Ψ+⟩ = (|01⟩ + |10⟩)/√2',
                'psi_minus': '|Ψ-⟩ = (|01⟩ - |10⟩)/√2'
            };

            document.getElementById('entangledState').textContent = states[entangledState.type];
            document.getElementById('qubitAState').textContent = 'Entangled';
            document.getElementById('qubitBState').textContent = 'Entangled';
            document.getElementById('qubitABox').classList.add('entangled');
            document.getElementById('qubitBBox').classList.add('entangled');
            document.getElementById('entanglementExplanation').textContent =
                'The qubits are maximally entangled. Measuring one will instantly determine the other.';
        }

        function measureEntangled(qubit) {
            if (entangledState.measured) {
                document.getElementById('entanglementExplanation').textContent =
                    'State already collapsed. Click Reset to try again.';
                return;
            }

            const type = entangledState.type;
            const result = Math.random() < 0.5 ? 0 : 1;

            let aResult, bResult;

            if (type === 'phi_plus' || type === 'phi_minus') {
                aResult = result;
                bResult = result; // Same outcome
            } else {
                aResult = result;
                bResult = 1 - result; // Opposite outcome
            }

            document.getElementById('qubitAState').textContent = `|${aResult}⟩`;
            document.getElementById('qubitBState').textContent = `|${bResult}⟩`;
            document.getElementById('qubitABox').classList.remove('entangled');
            document.getElementById('qubitBBox').classList.remove('entangled');

            const measuredStr = qubit === 'A' ? 'A' : 'B';
            const otherStr = qubit === 'A' ? 'B' : 'A';

            document.getElementById('entanglementExplanation').innerHTML =
                `<span style="color: var(--accent-4);">Measured ${measuredStr} → instantly determined ${otherStr}!</span><br>
                This is "spooky action at a distance" — but it cannot transmit information faster than light.`;

            entangledState.measured = true;
        }

        document.getElementById('bellStateSelect').addEventListener('change', resetEntangled);

        // ============================================
        // CIRCUIT SIMULATOR
        // ============================================

        let circuit = [];

        function addCircuitGate(gate, qubit) {
            circuit.push({ gate, qubit });
            renderCircuit();
        }

        function resetCircuit() {
            circuit = [];
            renderCircuit();
            document.getElementById('circuitOutput').textContent = '|00⟩';
        }

        function renderCircuit() {
            const wire0 = document.getElementById('wire0');
            const wire1 = document.getElementById('wire1');

            wire0.innerHTML = '';
            wire1.innerHTML = '';

            circuit.forEach((g, i) => {
                if (g.gate === 'CNOT') {
                    // Control on qubit 0, target on qubit 1
                    const ctrl = document.createElement('div');
                    ctrl.className = 'control-dot';
                    ctrl.style.marginLeft = (i * 60 + 20) + 'px';
                    ctrl.style.position = 'absolute';
                    wire0.appendChild(ctrl);

                    const target = document.createElement('div');
                    target.className = 'gate-box';
                    target.textContent = '⊕';
                    target.style.marginLeft = (i * 60 + 14) + 'px';
                    target.style.position = 'absolute';
                    wire1.appendChild(target);
                } else {
                    const gateEl = document.createElement('div');
                    gateEl.className = 'gate-box';
                    gateEl.textContent = g.gate;
                    gateEl.style.marginLeft = (i * 60 + 10) + 'px';
                    gateEl.style.position = 'absolute';

                    if (g.qubit === 0) wire0.appendChild(gateEl);
                    else wire1.appendChild(gateEl);
                }
            });
        }

        function runCircuit() {
            // Simplified 2-qubit simulation
            // State: [|00⟩, |01⟩, |10⟩, |11⟩]
            let state = [1, 0, 0, 0]; // Start with |00⟩

            circuit.forEach(g => {
                if (g.gate === 'H') {
                    state = applyH(state, g.qubit);
                } else if (g.gate === 'X') {
                    state = applyX(state, g.qubit);
                } else if (g.gate === 'CNOT') {
                    state = applyCNOT(state);
                }
            });

            // Format output
            let output = '';
            const labels = ['|00⟩', '|01⟩', '|10⟩', '|11⟩'];
            state.forEach((amp, i) => {
                if (Math.abs(amp) > 0.001) {
                    if (output && amp > 0) output += ' + ';
                    if (Math.abs(amp - 1) < 0.01) output += labels[i];
                    else if (Math.abs(amp + 1) < 0.01) output += '-' + labels[i];
                    else if (Math.abs(amp - 1/Math.sqrt(2)) < 0.01) output += '(1/√2)' + labels[i];
                    else if (Math.abs(amp + 1/Math.sqrt(2)) < 0.01) output += '(-1/√2)' + labels[i];
                    else output += amp.toFixed(2) + labels[i];
                }
            });

            document.getElementById('circuitOutput').textContent = output || '0';
        }

        function applyH(state, qubit) {
            const s = 1 / Math.sqrt(2);
            const result = [0, 0, 0, 0];

            if (qubit === 0) {
                // H on first qubit
                result[0] = s * (state[0] + state[2]);
                result[1] = s * (state[1] + state[3]);
                result[2] = s * (state[0] - state[2]);
                result[3] = s * (state[1] - state[3]);
            } else {
                // H on second qubit
                result[0] = s * (state[0] + state[1]);
                result[1] = s * (state[0] - state[1]);
                result[2] = s * (state[2] + state[3]);
                result[3] = s * (state[2] - state[3]);
            }

            return result;
        }

        function applyX(state, qubit) {
            if (qubit === 0) {
                return [state[2], state[3], state[0], state[1]];
            } else {
                return [state[1], state[0], state[3], state[2]];
            }
        }

        function applyCNOT(state) {
            // Control on qubit 0, target on qubit 1
            // |00⟩→|00⟩, |01⟩→|01⟩, |10⟩→|11⟩, |11⟩→|10⟩
            return [state[0], state[1], state[3], state[2]];
        }

        // ============================================
        // DEUTSCH-JOZSA
        // ============================================

        async function runDeutschJozsa() {
            const funcType = document.getElementById('djFunctionSelect').value;
            const steps = document.querySelectorAll('#djSteps .step');

            // Reset steps
            steps.forEach(s => {
                s.classList.remove('active', 'completed');
            });

            // Step 1: Initialize
            steps[0].classList.add('active');
            document.getElementById('djState').textContent = '|0⟩ ⊗ |1⟩';
            await sleep(500);
            steps[0].classList.remove('active');
            steps[0].classList.add('completed');

            // Step 2: Hadamard
            steps[1].classList.add('active');
            document.getElementById('djState').textContent = '|+⟩ ⊗ |-⟩ = (1/2)(|0⟩+|1⟩) ⊗ (|0⟩-|1⟩)';
            await sleep(500);
            steps[1].classList.remove('active');
            steps[1].classList.add('completed');

            // Step 3: Oracle
            steps[2].classList.add('active');
            let afterOracle = '';
            if (funcType === 'const0') {
                afterOracle = '|+⟩ ⊗ |-⟩ (unchanged)';
            } else if (funcType === 'const1') {
                afterOracle = '-|+⟩ ⊗ |-⟩ (global phase)';
            } else if (funcType === 'identity') {
                afterOracle = '|-⟩ ⊗ |-⟩';
            } else {
                afterOracle = '-|-⟩ ⊗ |-⟩';
            }
            document.getElementById('djState').textContent = afterOracle;
            await sleep(500);
            steps[2].classList.remove('active');
            steps[2].classList.add('completed');

            // Step 4: Hadamard on first qubit
            steps[3].classList.add('active');
            let afterH = '';
            if (funcType === 'const0' || funcType === 'const1') {
                afterH = '|0⟩ ⊗ |-⟩';
            } else {
                afterH = '|1⟩ ⊗ |-⟩';
            }
            document.getElementById('djState').textContent = afterH;
            await sleep(500);
            steps[3].classList.remove('active');
            steps[3].classList.add('completed');

            // Step 5: Measure
            steps[4].classList.add('active');
            const isConstant = funcType === 'const0' || funcType === 'const1';
            const measurement = isConstant ? '0' : '1';
            document.getElementById('djState').textContent = `Measured: |${measurement}⟩`;
            await sleep(300);
            steps[4].classList.remove('active');
            steps[4].classList.add('completed');

            // Result
            const resultDiv = document.getElementById('djResult');
            if (isConstant) {
                resultDiv.innerHTML = '<span style="color: var(--accent-4);">✓ f is CONSTANT</span><br>' +
                    'We measured |0⟩, meaning f(0) = f(1)';
            } else {
                resultDiv.innerHTML = '<span style="color: var(--accent-2);">✓ f is BALANCED</span><br>' +
                    'We measured |1⟩, meaning f(0) ≠ f(1)';
            }
        }

        // ============================================
        // QFT
        // ============================================

        function runQFT() {
            const input = parseInt(document.getElementById('qftInputSelect').value);
            const n = 3;
            const N = 8;

            document.getElementById('qftInput').textContent = `|${input.toString(2).padStart(3, '0')}⟩`;

            // QFT: |x⟩ → (1/√N) Σ_k ω^(xk) |k⟩
            const omega = (k) => Math.exp(2 * Math.PI * 1i * input * k / N);

            let outputStr = '(1/√8)[';
            let amplitudes = '<div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; margin-top: 0.5rem;">';

            for (let k = 0; k < N; k++) {
                const angle = (2 * Math.PI * input * k / N) % (2 * Math.PI);
                const re = Math.cos(angle);
                const im = Math.sin(angle);

                let coeff = '';
                if (Math.abs(im) < 0.01) {
                    coeff = re.toFixed(2);
                } else if (Math.abs(re) < 0.01) {
                    coeff = im.toFixed(2) + 'i';
                } else {
                    coeff = `(${re.toFixed(1)}+${im.toFixed(1)}i)`;
                }

                if (k > 0) outputStr += ' + ';
                if (Math.abs(re - 1) < 0.01 && Math.abs(im) < 0.01) {
                    outputStr += `|${k.toString(2).padStart(3, '0')}⟩`;
                } else {
                    outputStr += `ω^${input * k % N}|${k.toString(2).padStart(3, '0')}⟩`;
                }

                amplitudes += `<div style="background: var(--bg-primary); padding: 0.5rem; border-radius: 4px; text-align: center;">
                    <div style="color: var(--accent-2);">|${k.toString(2).padStart(3, '0')}⟩</div>
                    <div style="font-family: monospace;">${coeff}</div>
                </div>`;
            }

            outputStr += ']';
            amplitudes += '</div>';

            document.getElementById('qftOutput').textContent = 'Equal superposition with phases';
            document.getElementById('qftAmplitudes').innerHTML = amplitudes;
        }

        // ============================================
        // SHOR'S ALGORITHM
        // ============================================

        async function runShorDemo() {
            const M = parseInt(document.getElementById('shorNumberSelect').value);
            const steps = document.querySelectorAll('#shorSteps .step');
            const progress = document.getElementById('shorProgress');

            steps.forEach(s => s.classList.remove('active', 'completed'));

            // Step 1: Pick random x
            steps[0].classList.add('active');
            const x = pickRandomCoprime(M);
            progress.innerHTML = `<p>Randomly chose x = ${x} (coprime to ${M})</p>`;
            await sleep(800);
            steps[0].classList.remove('active');
            steps[0].classList.add('completed');

            // Step 2: Find order r
            steps[1].classList.add('active');
            const r = findOrder(x, M);
            progress.innerHTML += `<p>Using QFT, found order r = ${r} (x^r ≡ 1 mod ${M})</p>`;
            await sleep(800);
            steps[1].classList.remove('active');
            steps[1].classList.add('completed');

            // Step 3: Check conditions
            steps[2].classList.add('active');
            const isEven = r % 2 === 0;
            const xHalf = Math.pow(x, r / 2) % M;
            const notTrivial = xHalf !== M - 1;

            progress.innerHTML += `<p>r = ${r} is ${isEven ? 'even ✓' : 'odd ✗'}</p>`;
            if (isEven) {
                progress.innerHTML += `<p>x^(r/2) = ${x}^${r/2} ≡ ${xHalf} (mod ${M})</p>`;
                progress.innerHTML += `<p>x^(r/2) + 1 ≢ 0 (mod ${M})? ${notTrivial ? '✓' : '✗'}</p>`;
            }
            await sleep(800);
            steps[2].classList.remove('active');
            steps[2].classList.add('completed');

            // Step 4: Compute GCD
            steps[3].classList.add('active');
            if (isEven && notTrivial) {
                const factor1 = gcd(xHalf - 1, M);
                const factor2 = gcd(xHalf + 1, M);

                progress.innerHTML += `<p>gcd(${xHalf} - 1, ${M}) = gcd(${xHalf - 1}, ${M}) = ${factor1}</p>`;
                progress.innerHTML += `<p>gcd(${xHalf} + 1, ${M}) = gcd(${xHalf + 1}, ${M}) = ${factor2}</p>`;

                await sleep(500);
                steps[3].classList.remove('active');
                steps[3].classList.add('completed');

                document.getElementById('shorResult').innerHTML =
                    `<span style="color: var(--accent-4);">${M} = ${factor1} × ${factor2}</span>`;
            } else {
                progress.innerHTML += `<p style="color: var(--accent-5);">Bad choice of x, would retry...</p>`;
                steps[3].classList.remove('active');

                // Find working example
                const factors = factorize(M);
                document.getElementById('shorResult').innerHTML =
                    `<span style="color: var(--accent-3);">${M} = ${factors.join(' × ')}</span> (found on retry)`;
            }
        }

        function pickRandomCoprime(n) {
            // Pick a "random" x coprime to n (deterministic for demo)
            for (let x = 2; x < n; x++) {
                if (gcd(x, n) === 1) return x;
            }
            return 2;
        }

        function findOrder(x, n) {
            let r = 1;
            let power = x % n;
            while (power !== 1 && r < n) {
                power = (power * x) % n;
                r++;
            }
            return r;
        }

        function gcd(a, b) {
            while (b !== 0) {
                [a, b] = [b, a % b];
            }
            return a;
        }

        function factorize(n) {
            const factors = [];
            for (let d = 2; d * d <= n; d++) {
                while (n % d === 0) {
                    factors.push(d);
                    n = n / d;
                }
            }
            if (n > 1) factors.push(n);
            return factors;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        document.addEventListener('DOMContentLoaded', () => {
            initBlochSphere();
            resetGateDemo();
            resetEntangled();
            resetCircuit();
        });
    </script>
</body>
</html>
