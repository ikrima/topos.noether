<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parts XIV-XV: Algebraic Number Theory ‚Äî An Infinitely Large Napkin</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,600;1,400&family=DM+Sans:wght@400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">

  <!-- KaTeX -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

  <!-- Libraries -->
  <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/ScrollTrigger.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

  <style>
    :root {
      --color-integer: #3b82f6;
      --color-prime: #ef4444;
      --color-unit: #10b981;
      --color-ideal: #f59e0b;
      --color-split: #8b5cf6;
      --color-inert: #06b6d4;
      --color-ramify: #ec4899;
      --color-galois: #84cc16;
      --bg-primary: #08080f;
      --bg-secondary: #0d0d18;
      --bg-tertiary: #141425;
      --bg-card: #1a1a30;
      --text-primary: #f1f5f9;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --border-color: #252545;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: 'DM Sans', sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      line-height: 1.7;
      font-size: 17px;
      overflow-x: hidden;
    }

    h1, h2, h3, h4 {
      font-family: 'Crimson Pro', Georgia, serif;
      font-weight: 400;
      line-height: 1.3;
    }

    h1 {
      font-size: clamp(2.5rem, 6vw, 4rem);
      font-weight: 300;
      letter-spacing: -0.02em;
    }

    h2 {
      font-size: clamp(1.8rem, 4vw, 2.5rem);
      margin-bottom: 1rem;
    }

    h3 {
      font-size: 1.4rem;
      color: var(--text-secondary);
      margin-bottom: 0.75rem;
    }

    p {
      margin-bottom: 1.5rem;
      color: var(--text-secondary);
    }

    .math-display {
      font-family: 'JetBrains Mono', monospace;
      background: var(--bg-tertiary);
      padding: 1.5rem;
      border-radius: 12px;
      margin: 1.5rem 0;
      overflow-x: auto;
      border-left: 3px solid var(--color-integer);
    }

    /* Progress bar */
    .progress-bar {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 3px;
      background: var(--bg-tertiary);
      z-index: 1000;

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, var(--color-integer), var(--color-ideal), var(--color-galois));
        width: 0%;
        transition: width 0.1s ease-out;
      }
    }

    /* Navigation */
    .nav {
      position: fixed;
      right: 2rem;
      top: 50%;
      transform: translateY(-50%);
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;

      @media (max-width: 1200px) {
        display: none;
      }

      a {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        background: var(--bg-tertiary);
        border: 2px solid var(--border-color);
        transition: all 0.3s ease;

        &:hover, &.active {
          background: var(--color-integer);
          border-color: var(--color-integer);
          transform: scale(1.3);
        }
      }
    }

    section {
      min-height: 100vh;
      padding: 6rem 2rem;
      max-width: 1400px;
      margin: 0 auto;
    }

    .hero {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      min-height: 100vh;
      position: relative;

      .subtitle {
        font-size: 1.1rem;
        color: var(--color-integer);
        margin-bottom: 1rem;
        font-weight: 500;
        letter-spacing: 0.1em;
        text-transform: uppercase;
      }

      .description {
        max-width: 700px;
        margin: 2rem auto;
        font-size: 1.1rem;
      }

      .hero-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        opacity: 0.5;
      }
    }

    .interactive-container {
      background: var(--bg-secondary);
      border-radius: 20px;
      padding: 2rem;
      margin: 2rem 0;
      border: 1px solid var(--border-color);
    }

    .visualization {
      background: var(--bg-tertiary);
      border-radius: 12px;
      min-height: 400px;
      position: relative;
      overflow: hidden;
    }

    .svg-container {
      width: 100%;
      height: 450px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
      margin-bottom: 1.5rem;
      align-items: center;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;

      label {
        font-size: 0.85rem;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
    }

    input[type="range"] {
      width: 180px;
      height: 6px;
      -webkit-appearance: none;
      background: var(--bg-tertiary);
      border-radius: 3px;

      &::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: var(--color-integer);
        cursor: pointer;
      }
    }

    button {
      font-family: 'DM Sans', sans-serif;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      border: none;
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;

      &.primary {
        background: var(--color-integer);
        color: white;

        &:hover {
          filter: brightness(1.1);
          transform: translateY(-2px);
        }
      }

      &.secondary {
        background: var(--bg-tertiary);
        color: var(--text-primary);
        border: 1px solid var(--border-color);

        &:hover {
          border-color: var(--color-integer);
        }
      }
    }

    .tabs {
      display: flex;
      gap: 0.5rem;

      button {
        padding: 0.5rem 1rem;
        background: transparent;
        color: var(--text-muted);
        border: 1px solid transparent;

        &.active {
          color: var(--color-integer);
          background: var(--bg-tertiary);
          border-color: var(--color-integer);
          border-radius: 6px;
        }
      }
    }

    .two-column {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 3rem;
      align-items: start;

      @media (max-width: 1000px) {
        grid-template-columns: 1fr;
      }
    }

    .definition {
      background: linear-gradient(135deg, var(--bg-secondary), var(--bg-tertiary));
      border-left: 4px solid var(--color-integer);
      padding: 1.5rem;
      border-radius: 0 12px 12px 0;
      margin: 1.5rem 0;

      .def-title {
        font-family: 'Crimson Pro', serif;
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--color-integer);
        margin-bottom: 0.5rem;
      }
    }

    .theorem {
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.1), rgba(245, 158, 11, 0.05));
      border-left: 4px solid var(--color-ideal);
      padding: 1.5rem;
      border-radius: 0 12px 12px 0;
      margin: 1.5rem 0;

      .thm-title {
        font-family: 'Crimson Pro', serif;
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--color-ideal);
        margin-bottom: 0.5rem;
      }
    }

    .chapter-header {
      margin-bottom: 3rem;

      .chapter-number {
        font-size: 0.9rem;
        color: var(--color-integer);
        text-transform: uppercase;
        letter-spacing: 0.15em;
        margin-bottom: 0.5rem;
      }
    }

    .part-divider {
      text-align: center;
      padding: 4rem 2rem;
      background: linear-gradient(180deg, var(--bg-primary), var(--bg-secondary));

      .part-number {
        font-size: 1rem;
        color: var(--color-galois);
        text-transform: uppercase;
        letter-spacing: 0.2em;
        margin-bottom: 0.5rem;
      }

      h2 {
        font-size: 2rem;
        margin-bottom: 1rem;
      }
    }

    .annotation {
      font-size: 0.85rem;
      color: var(--text-muted);
      font-style: italic;
      margin-top: 1rem;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .stat {
      background: var(--bg-tertiary);
      padding: 1rem;
      border-radius: 10px;
      text-align: center;

      .stat-value {
        font-size: 1.2rem;
        font-weight: 600;
        font-family: 'JetBrains Mono', monospace;
      }

      .stat-label {
        font-size: 0.7rem;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-top: 0.25rem;
      }

      &.integer .stat-value { color: var(--color-integer); }
      &.prime .stat-value { color: var(--color-prime); }
      &.unit .stat-value { color: var(--color-unit); }
      &.ideal .stat-value { color: var(--color-ideal); }
      &.split .stat-value { color: var(--color-split); }
      &.galois .stat-value { color: var(--color-galois); }
    }

    .factorization-display {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      justify-content: center;
      align-items: center;
      padding: 1.5rem;
      background: var(--bg-tertiary);
      border-radius: 12px;
      margin: 1rem 0;
      font-family: 'JetBrains Mono', monospace;
      font-size: 1.1rem;

      .factor {
        padding: 0.5rem 1rem;
        border-radius: 8px;
        background: var(--bg-card);

        &.irreducible { border: 2px solid var(--color-prime); }
        &.ideal { border: 2px solid var(--color-ideal); }
      }

      .operator {
        color: var(--text-muted);
      }
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
      margin-top: 1rem;
      font-size: 0.85rem;

      .legend-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;

        .dot {
          width: 12px;
          height: 12px;
          border-radius: 50%;
        }
      }
    }

    .splitting-diagram {
      display: flex;
      justify-content: space-around;
      align-items: flex-start;
      padding: 2rem;
      gap: 2rem;
      flex-wrap: wrap;

      .split-type {
        text-align: center;
        padding: 1.5rem;
        background: var(--bg-tertiary);
        border-radius: 12px;
        min-width: 200px;

        h4 {
          margin-bottom: 1rem;
          font-size: 1rem;
        }

        .diagram {
          height: 150px;
          position: relative;
        }
      }
    }

    footer {
      padding: 4rem 2rem;
      text-align: center;
      border-top: 1px solid var(--border-color);

      p {
        color: var(--text-muted);
        font-size: 0.9rem;
      }

      a {
        color: var(--color-integer);
        text-decoration: none;

        &:hover { text-decoration: underline; }
      }
    }

    .reveal {
      opacity: 0;
      transform: translateY(30px);
    }

    .instruction {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: var(--bg-tertiary);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 1rem;
    }

    .prose {
      max-width: 65ch;
    }
  </style>
</head>
<body x-data="algebraicNTExplorer()" x-init="init()">

  <!-- Progress Bar -->
  <div class="progress-bar">
    <div class="progress-fill" :style="{ width: scrollProgress + '%' }"></div>
  </div>

  <!-- Navigation -->
  <nav class="nav">
    <a href="#hero" :class="{ active: currentSection === 'hero' }"></a>
    <a href="#algebraic-integers" :class="{ active: currentSection === 'algebraic-integers' }"></a>
    <a href="#gaussian" :class="{ active: currentSection === 'gaussian' }"></a>
    <a href="#ufd-failure" :class="{ active: currentSection === 'ufd-failure' }"></a>
    <a href="#ideals" :class="{ active: currentSection === 'ideals' }"></a>
    <a href="#class-group" :class="{ active: currentSection === 'class-group' }"></a>
    <a href="#galois" :class="{ active: currentSection === 'galois' }"></a>
    <a href="#ramification" :class="{ active: currentSection === 'ramification' }"></a>
    <a href="#frobenius" :class="{ active: currentSection === 'frobenius' }"></a>
  </nav>

  <!-- Hero -->
  <section class="hero" id="hero">
    <svg id="hero-lattice" class="hero-canvas"></svg>
    <div class="subtitle">Parts XIV & XV</div>
    <h1>Algebraic Number Theory</h1>
    <p class="description">
      Where number theory meets abstract algebra. We'll discover how unique factorization
      fails in rings of integers‚Äîand how Dedekind's ideals restore order. Then Galois theory
      reveals the arithmetic hidden in field extensions.
    </p>
  </section>

  <!-- Chapter 53: Algebraic Integers -->
  <section id="algebraic-integers">
    <div class="chapter-header reveal">
      <div class="chapter-number">Chapter 53</div>
      <h2>Algebraic Integers</h2>
    </div>

    <div class="two-column">
      <div class="prose reveal">
        <p>
          What does it mean to be an "integer" in a number field? The answer: be a root of
          a <strong>monic</strong> polynomial with integer coefficients.
        </p>

        <div class="definition">
          <div class="def-title">Definition: Algebraic Integer</div>
          <p style="margin-bottom: 0;">
            $\alpha \in \mathbb{C}$ is an <em>algebraic integer</em> if it's a root of some monic polynomial
            $x^n + a_{n-1}x^{n-1} + \cdots + a_1 x + a_0$ with $a_i \in \mathbb{Z}$.
          </p>
        </div>

        <p>
          Examples:
          <br>‚Ä¢ $i = \sqrt{-1}$ is an algebraic integer: root of $x^2 + 1$
          <br>‚Ä¢ $\sqrt{2}$ is an algebraic integer: root of $x^2 - 2$
          <br>‚Ä¢ $\frac{1 + \sqrt{5}}{2}$ (golden ratio) is: root of $x^2 - x - 1$
          <br>‚Ä¢ $\frac{1}{2}$ is <em>not</em>: its minimal polynomial is $2x - 1$ (not monic!)
        </p>

        <p>
          The algebraic integers form a ring! Addition and multiplication of algebraic integers
          give algebraic integers. But they're hard to work with globally‚Äîwe focus on one
          number field at a time.
        </p>
      </div>

      <div class="interactive-container reveal">
        <h3>Is it an Algebraic Integer?</h3>

        <div class="controls">
          <div class="control-group">
            <label>Test number</label>
            <div class="tabs">
              <button @click="testNumber = 'sqrt2'" :class="{ active: testNumber === 'sqrt2' }">$\sqrt{2}$</button>
              <button @click="testNumber = 'sqrt5'" :class="{ active: testNumber === 'sqrt5' }">$\frac{1+\sqrt{5}}{2}$</button>
              <button @click="testNumber = 'cbrt2'" :class="{ active: testNumber === 'cbrt2' }">$\sqrt[3]{2}$</button>
              <button @click="testNumber = 'half'" :class="{ active: testNumber === 'half' }">$\frac{1}{2}$</button>
            </div>
          </div>
        </div>

        <div class="svg-container" id="min-poly-viz"></div>

        <div class="stats">
          <div class="stat integer">
            <div class="stat-value" x-text="minPolyData.isInteger ? 'Yes' : 'No'"></div>
            <div class="stat-label">Alg. Integer?</div>
          </div>
          <div class="stat prime">
            <div class="stat-value" x-text="minPolyData.degree"></div>
            <div class="stat-label">Degree</div>
          </div>
          <div class="stat ideal">
            <div class="stat-value" x-text="minPolyData.polynomial"></div>
            <div class="stat-label">Min. Poly</div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Gaussian and Eisenstein Integers -->
  <section id="gaussian">
    <div class="chapter-header reveal">
      <div class="chapter-number">Chapter 54</div>
      <h2>Rings of Integers: Gaussian & Eisenstein</h2>
    </div>

    <div class="prose reveal" style="max-width: 800px; margin: 0 auto 3rem;">
      <p>
        For a number field $K = \mathbb{Q}(\alpha)$, the <strong>ring of integers</strong> $\mathcal{O}_K$
        consists of all algebraic integers in $K$. These are the "good" elements to study.
      </p>

      <div class="definition">
        <div class="def-title">Key Examples</div>
        <p style="margin-bottom: 0;">
          ‚Ä¢ $K = \mathbb{Q}(i)$: $\mathcal{O}_K = \mathbb{Z}[i] = \{a + bi : a, b \in \mathbb{Z}\}$ (Gaussian integers)
          <br>‚Ä¢ $K = \mathbb{Q}(\omega)$ where $\omega = e^{2\pi i/3}$: $\mathcal{O}_K = \mathbb{Z}[\omega]$ (Eisenstein integers)
          <br>‚Ä¢ $K = \mathbb{Q}(\sqrt{d})$: $\mathcal{O}_K = \mathbb{Z}[\frac{1+\sqrt{d}}{2}]$ if $d \equiv 1 \pmod 4$, else $\mathbb{Z}[\sqrt{d}]$
        </p>
      </div>
    </div>

    <div class="two-column">
      <div class="interactive-container reveal">
        <h3>Gaussian Integers $\mathbb{Z}[i]$</h3>
        <p class="instruction">Click to highlight divisibility. Primes shown in red.</p>

        <div class="controls">
          <div class="control-group">
            <label>Show</label>
            <div class="tabs">
              <button @click="gaussianShow = 'all'" :class="{ active: gaussianShow === 'all' }">All</button>
              <button @click="gaussianShow = 'primes'" :class="{ active: gaussianShow === 'primes' }">Primes</button>
              <button @click="gaussianShow = 'units'" :class="{ active: gaussianShow === 'units' }">Units</button>
            </div>
          </div>
        </div>

        <div class="svg-container" id="gaussian-lattice"></div>

        <div class="legend">
          <div class="legend-item">
            <div class="dot" style="background: var(--color-integer);"></div>
            <span>Composite</span>
          </div>
          <div class="legend-item">
            <div class="dot" style="background: var(--color-prime);"></div>
            <span>Prime</span>
          </div>
          <div class="legend-item">
            <div class="dot" style="background: var(--color-unit);"></div>
            <span>Unit</span>
          </div>
        </div>

        <div class="stats">
          <div class="stat unit">
            <div class="stat-value">4</div>
            <div class="stat-label">Units</div>
          </div>
          <div class="stat integer">
            <div class="stat-value">UFD</div>
            <div class="stat-label">Factorization</div>
          </div>
        </div>
      </div>

      <div class="interactive-container reveal">
        <h3>Eisenstein Integers $\mathbb{Z}[\omega]$</h3>
        <p class="instruction">Hexagonal symmetry from $\omega = e^{2\pi i/3}$</p>

        <div class="controls">
          <div class="control-group">
            <label>Show</label>
            <div class="tabs">
              <button @click="eisensteinShow = 'all'" :class="{ active: eisensteinShow === 'all' }">All</button>
              <button @click="eisensteinShow = 'primes'" :class="{ active: eisensteinShow === 'primes' }">Primes</button>
              <button @click="eisensteinShow = 'units'" :class="{ active: eisensteinShow === 'units' }">Units</button>
            </div>
          </div>
        </div>

        <div class="svg-container" id="eisenstein-lattice"></div>

        <div class="legend">
          <div class="legend-item">
            <div class="dot" style="background: var(--color-integer);"></div>
            <span>Composite</span>
          </div>
          <div class="legend-item">
            <div class="dot" style="background: var(--color-prime);"></div>
            <span>Prime</span>
          </div>
          <div class="legend-item">
            <div class="dot" style="background: var(--color-unit);"></div>
            <span>Unit</span>
          </div>
        </div>

        <div class="stats">
          <div class="stat unit">
            <div class="stat-value">6</div>
            <div class="stat-label">Units</div>
          </div>
          <div class="stat integer">
            <div class="stat-value">UFD</div>
            <div class="stat-label">Factorization</div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- UFD Failure -->
  <section id="ufd-failure">
    <div class="chapter-header reveal">
      <div class="chapter-number">Chapter 55</div>
      <h2>The Failure of Unique Factorization</h2>
    </div>

    <div class="two-column">
      <div class="prose reveal">
        <p>
          Here's the crisis that launched algebraic number theory. In $\mathbb{Z}[\sqrt{-5}]$,
          the number 6 has <em>two different</em> factorizations into irreducibles:
        </p>

        <div class="math-display">
          $$6 = 2 \times 3 = (1 + \sqrt{-5})(1 - \sqrt{-5})$$
        </div>

        <p>
          All four factors are irreducible in $\mathbb{Z}[\sqrt{-5}]$! This is not a unit issue‚Äîthese
          factorizations are genuinely different. Unique factorization fails.
        </p>

        <p>
          Why does this happen? The norm $N(a + b\sqrt{-5}) = a^2 + 5b^2$ helps us check:
          <br>‚Ä¢ $N(2) = 4$, $N(3) = 9$, $N(1 \pm \sqrt{-5}) = 6$
          <br>‚Ä¢ If $2 = \alpha\beta$, then $N(\alpha)N(\beta) = 4$
          <br>‚Ä¢ But there's no element with norm 2! So 2 is irreducible.
        </p>

        <p>
          The same argument shows all four factors are irreducible. But they're not
          associates (no units connect them), so UFD fails catastrophically.
        </p>
      </div>

      <div class="interactive-container reveal">
        <h3>Two Factorizations of 6</h3>
        <p class="instruction">Watch the two incompatible factorizations</p>

        <div class="factorization-display">
          <span class="factor irreducible">2</span>
          <span class="operator">√ó</span>
          <span class="factor irreducible">3</span>
          <span class="operator">=</span>
          <span style="font-size: 1.5rem; color: var(--color-ideal);">6</span>
          <span class="operator">=</span>
          <span class="factor irreducible">(1+‚àö-5)</span>
          <span class="operator">√ó</span>
          <span class="factor irreducible">(1-‚àö-5)</span>
        </div>

        <div class="svg-container" id="ufd-failure-viz"></div>

        <div class="stats">
          <div class="stat prime">
            <div class="stat-value">4</div>
            <div class="stat-label">Irreducibles</div>
          </div>
          <div class="stat unit">
            <div class="stat-value">2</div>
            <div class="stat-label">Units (¬±1)</div>
          </div>
          <div class="stat ideal">
            <div class="stat-value">2</div>
            <div class="stat-label">Class Number</div>
          </div>
        </div>

        <p class="annotation">
          The class number h = 2 means there are 2 "types" of ideals. Non-trivial class number ‚ü∫ UFD fails.
        </p>
      </div>
    </div>
  </section>

  <!-- Ideal Factorization -->
  <section id="ideals">
    <div class="chapter-header reveal">
      <h2>Ideals Save the Day</h2>
    </div>

    <div class="prose reveal" style="max-width: 800px; margin: 0 auto 3rem;">
      <p>
        Dedekind's brilliant insight: even when elements don't factor uniquely, <strong>ideals</strong> do!
        Every nonzero ideal in $\mathcal{O}_K$ factors uniquely into prime ideals.
      </p>

      <div class="theorem">
        <div class="thm-title">Unique Factorization of Ideals</div>
        <p style="margin-bottom: 0;">
          In the ring of integers $\mathcal{O}_K$ of a number field, every nonzero ideal $I$
          factors uniquely (up to order) as:
          $$I = \mathfrak{p}_1^{e_1} \mathfrak{p}_2^{e_2} \cdots \mathfrak{p}_r^{e_r}$$
          where each $\mathfrak{p}_i$ is a prime ideal.
        </p>
      </div>

      <p>
        Back to $\mathbb{Z}[\sqrt{-5}]$: the element 2 isn't prime, but the <em>ideal</em> (2) factors:
      </p>

      <div class="math-display">
        $$(2) = (2, 1+\sqrt{-5})^2 = \mathfrak{p}^2$$
      </div>

      <p>
        Similarly $(3) = \mathfrak{q}\bar{\mathfrak{q}}$ and $(1 \pm \sqrt{-5}) = \mathfrak{p}\mathfrak{q}$ or $\mathfrak{p}\bar{\mathfrak{q}}$.
        Now $(6) = (2)(3) = \mathfrak{p}^2 \mathfrak{q}\bar{\mathfrak{q}}$‚Äîunique!
      </p>
    </div>

    <div class="interactive-container reveal">
      <h3>Ideal Factorization Fixes Everything</h3>

      <div class="controls">
        <div class="control-group">
          <label>Factor the ideal</label>
          <div class="tabs">
            <button @click="idealFactor = '2'" :class="{ active: idealFactor === '2' }">(2)</button>
            <button @click="idealFactor = '3'" :class="{ active: idealFactor === '3' }">(3)</button>
            <button @click="idealFactor = '6'" :class="{ active: idealFactor === '6' }">(6)</button>
            <button @click="idealFactor = '1+sqrt'" :class="{ active: idealFactor === '1+sqrt' }">(1+‚àö-5)</button>
          </div>
        </div>
      </div>

      <div class="svg-container" id="ideal-factor-viz" style="height: 350px;"></div>

      <div class="factorization-display">
        <template x-if="idealFactor === '2'">
          <div>
            <span class="factor ideal">(2)</span>
            <span class="operator">=</span>
            <span class="factor ideal">ùî≠¬≤</span>
          </div>
        </template>
        <template x-if="idealFactor === '3'">
          <div>
            <span class="factor ideal">(3)</span>
            <span class="operator">=</span>
            <span class="factor ideal">ùîÆ</span>
            <span class="operator">¬∑</span>
            <span class="factor ideal">ùîÆÃÑ</span>
          </div>
        </template>
        <template x-if="idealFactor === '6'">
          <div>
            <span class="factor ideal">(6)</span>
            <span class="operator">=</span>
            <span class="factor ideal">ùî≠¬≤</span>
            <span class="operator">¬∑</span>
            <span class="factor ideal">ùîÆ</span>
            <span class="operator">¬∑</span>
            <span class="factor ideal">ùîÆÃÑ</span>
          </div>
        </template>
        <template x-if="idealFactor === '1+sqrt'">
          <div>
            <span class="factor ideal">(1+‚àö-5)</span>
            <span class="operator">=</span>
            <span class="factor ideal">ùî≠</span>
            <span class="operator">¬∑</span>
            <span class="factor ideal">ùîÆ</span>
          </div>
        </template>
      </div>

      <p class="annotation">
        The prime ideals ùî≠ = (2, 1+‚àö-5), ùîÆ = (3, 1+‚àö-5), ùîÆÃÑ = (3, 1-‚àö-5) are the building blocks.
      </p>
    </div>
  </section>

  <!-- Class Groups and Minkowski -->
  <section id="class-group">
    <div class="chapter-header reveal">
      <div class="chapter-number">Chapter 56</div>
      <h2>Class Groups & Minkowski's Bound</h2>
    </div>

    <div class="two-column">
      <div class="prose reveal">
        <p>
          The <strong>class group</strong> $\text{Cl}(\mathcal{O}_K)$ measures how badly unique
          factorization fails. It's the group of fractional ideals modulo principal ideals.
        </p>

        <div class="definition">
          <div class="def-title">Class Group</div>
          <p style="margin-bottom: 0;">
            $$\text{Cl}(\mathcal{O}_K) = \frac{\{\text{fractional ideals}\}}{\{\text{principal ideals}\}}$$
            The <em>class number</em> $h_K = |\text{Cl}(\mathcal{O}_K)|$ is finite!
            <br>$h_K = 1$ ‚ü∫ every ideal is principal ‚ü∫ $\mathcal{O}_K$ is a UFD.
          </p>
        </div>

        <p>
          How do we compute $h_K$? Minkowski gives us a bound: every ideal class contains
          an ideal of norm at most the <strong>Minkowski bound</strong>:
        </p>

        <div class="math-display">
          $$M_K = \frac{n!}{n^n}\left(\frac{4}{\pi}\right)^{r_2}\sqrt{|\Delta_K|}$$
        </div>

        <p>
          Here $n = [K:\mathbb{Q}]$, $r_2$ is the number of complex embeddings, and $\Delta_K$ is the discriminant.
          We only need to check finitely many primes!
        </p>
      </div>

      <div class="interactive-container reveal">
        <h3>Class Numbers of $\mathbb{Q}(\sqrt{d})$</h3>

        <div class="controls">
          <div class="control-group">
            <label>d value: <span x-text="classGroupD"></span></label>
            <input type="range" x-model="classGroupD" min="-20" max="-1" step="1" @input="updateClassGroup()">
          </div>
        </div>

        <div class="svg-container" id="class-group-viz" style="height: 350px;"></div>

        <div class="stats">
          <div class="stat integer">
            <div class="stat-value" x-text="classGroupData.discriminant"></div>
            <div class="stat-label">Discriminant Œî</div>
          </div>
          <div class="stat ideal">
            <div class="stat-value" x-text="classGroupData.minkowski.toFixed(2)"></div>
            <div class="stat-label">Minkowski Bound</div>
          </div>
          <div class="stat prime">
            <div class="stat-value" x-text="classGroupData.classNumber"></div>
            <div class="stat-label">Class Number h</div>
          </div>
          <div class="stat unit">
            <div class="stat-value" x-text="classGroupData.isUFD ? 'Yes' : 'No'"></div>
            <div class="stat-label">UFD?</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Minkowski's Theorem Visualization -->
    <div class="interactive-container reveal" style="margin-top: 3rem;">
      <h3>Minkowski's Convex Body Theorem</h3>

      <div class="prose" style="margin-bottom: 1.5rem;">
        <p>
          The geometric heart of the bound: a convex body symmetric about the origin with
          volume greater than $2^n \cdot \text{vol}(\text{fundamental domain})$ must contain a nonzero lattice point.
        </p>
      </div>

      <div class="svg-container" id="minkowski-viz"></div>

      <p class="annotation">
        The lattice (blue dots) and a convex region. When the region is large enough relative to
        the fundamental parallelogram, it must capture a lattice point.
      </p>
    </div>
  </section>

  <!-- Part XV Divider -->
  <div class="part-divider">
    <div class="part-number">Part XV</div>
    <h2>Galois & Ramification Theory</h2>
    <p style="color: var(--text-secondary); max-width: 600px; margin: 0 auto;">
      Now we bring Galois theory into arithmetic. How do primes of ‚Ñ§ behave in extensions?
      The Frobenius element encodes the answer.
    </p>
  </div>

  <!-- Galois Theory -->
  <section id="galois">
    <div class="chapter-header reveal">
      <div class="chapter-number">Chapter 59</div>
      <h2>Galois Theory Refresher</h2>
    </div>

    <div class="two-column">
      <div class="prose reveal">
        <p>
          For a Galois extension $L/K$, the <strong>Galois group</strong> $\text{Gal}(L/K)$ consists
          of field automorphisms of $L$ fixing $K$. This group acts on roots of polynomials,
          on ideals, and on prime ideals lying over a given prime.
        </p>

        <div class="definition">
          <div class="def-title">Galois Correspondence</div>
          <p style="margin-bottom: 0;">
            For $L/K$ Galois with group $G$:
            <br>‚Ä¢ Subgroups $H \leq G$ ‚Üî Intermediate fields $K \subseteq E \subseteq L$
            <br>‚Ä¢ $H = \text{Gal}(L/E)$ and $[L:E] = |H|$
            <br>‚Ä¢ Normal subgroups ‚Üî Galois subextensions
          </p>
        </div>

        <p>
          Example: $\mathbb{Q}(\sqrt{2}, \sqrt{3})/\mathbb{Q}$ has Galois group $\mathbb{Z}/2 \times \mathbb{Z}/2$
          generated by $\sigma: \sqrt{2} \mapsto -\sqrt{2}$ and $\tau: \sqrt{3} \mapsto -\sqrt{3}$.
        </p>
      </div>

      <div class="interactive-container reveal">
        <h3>Galois Group Acting on Roots</h3>
        <p class="instruction">See how automorphisms permute roots</p>

        <div class="controls">
          <div class="control-group">
            <label>Polynomial</label>
            <div class="tabs">
              <button @click="galoisPoly = 'x4-2'" :class="{ active: galoisPoly === 'x4-2' }">$x^4 - 2$</button>
              <button @click="galoisPoly = 'x3-2'" :class="{ active: galoisPoly === 'x3-2' }">$x^3 - 2$</button>
              <button @click="galoisPoly = 'cyclotomic'" :class="{ active: galoisPoly === 'cyclotomic' }">$\Phi_5(x)$</button>
            </div>
          </div>
        </div>

        <div class="svg-container" id="galois-roots-viz"></div>

        <div class="stats">
          <div class="stat galois">
            <div class="stat-value" x-text="galoisData.groupName"></div>
            <div class="stat-label">Gal(L/‚Ñö)</div>
          </div>
          <div class="stat integer">
            <div class="stat-value" x-text="galoisData.order"></div>
            <div class="stat-label">|G|</div>
          </div>
          <div class="stat prime">
            <div class="stat-value" x-text="galoisData.numRoots"></div>
            <div class="stat-label">Roots</div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Ramification -->
  <section id="ramification">
    <div class="chapter-header reveal">
      <div class="chapter-number">Chapter 61</div>
      <h2>Ramification Theory</h2>
    </div>

    <div class="prose reveal" style="max-width: 800px; margin: 0 auto 3rem;">
      <p>
        When we extend from $\mathbb{Z}$ to $\mathcal{O}_K$, what happens to a prime $p$?
        The ideal $(p)$ factors in $\mathcal{O}_K$‚Äîbut how?
      </p>

      <div class="definition">
        <div class="def-title">Prime Splitting Types</div>
        <p style="margin-bottom: 0;">
          For a prime $p \in \mathbb{Z}$ and extension $K/\mathbb{Q}$ of degree $n$:
          $$(p) = \mathfrak{P}_1^{e_1} \cdots \mathfrak{P}_g^{e_g}$$
          where each $\mathfrak{P}_i$ has <em>inertia degree</em> $f_i = [\mathcal{O}_K/\mathfrak{P}_i : \mathbb{Z}/p]$.
          <br><br>
          Key relation: $\sum_{i=1}^g e_i f_i = n$
          <br><br>
          ‚Ä¢ <strong>Split</strong>: $g = n$, all $e_i = f_i = 1$ (p factors completely)
          <br>‚Ä¢ <strong>Inert</strong>: $g = 1$, $e_1 = 1$, $f_1 = n$ (p stays prime)
          <br>‚Ä¢ <strong>Ramified</strong>: some $e_i > 1$ (prime power appears)
        </p>
      </div>
    </div>

    <div class="interactive-container reveal">
      <h3>How Primes Split in $\mathbb{Q}(\sqrt{d})$</h3>

      <div class="controls">
        <div class="control-group">
          <label>d = <span x-text="ramifyD"></span></label>
          <input type="range" x-model="ramifyD" min="-10" max="10" step="1" @input="updateRamification()">
        </div>
        <div class="control-group">
          <label>Prime p = <span x-text="ramifyP"></span></label>
          <input type="range" x-model="ramifyP" min="2" max="19" step="1" @input="updateRamification()">
        </div>
      </div>

      <div class="splitting-diagram" id="splitting-diagram">
        <div class="split-type" id="split-viz">
          <h4 style="color: var(--color-split);">Split</h4>
          <div class="diagram"></div>
          <p style="font-size: 0.8rem; color: var(--text-muted);">(p) = ùîì‚ÇÅùîì‚ÇÇ</p>
        </div>
        <div class="split-type" id="inert-viz">
          <h4 style="color: var(--color-inert);">Inert</h4>
          <div class="diagram"></div>
          <p style="font-size: 0.8rem; color: var(--text-muted);">(p) = ùîì</p>
        </div>
        <div class="split-type" id="ramify-viz">
          <h4 style="color: var(--color-ramify);">Ramified</h4>
          <div class="diagram"></div>
          <p style="font-size: 0.8rem; color: var(--text-muted);">(p) = ùîì¬≤</p>
        </div>
      </div>

      <div class="stats">
        <div class="stat" :class="ramificationResult.type">
          <div class="stat-value" x-text="ramificationResult.type.charAt(0).toUpperCase() + ramificationResult.type.slice(1)"></div>
          <div class="stat-label">Type for p=<span x-text="ramifyP"></span></div>
        </div>
        <div class="stat integer">
          <div class="stat-value" x-text="ramificationResult.factorization"></div>
          <div class="stat-label">Factorization</div>
        </div>
        <div class="stat ideal">
          <div class="stat-value" x-text="ramificationResult.criterion"></div>
          <div class="stat-label">Criterion</div>
        </div>
      </div>

      <p class="annotation">
        For quadratic fields: p ramifies iff p | Œî; p splits iff (Œî/p) = 1; p is inert iff (Œî/p) = -1.
      </p>
    </div>
  </section>

  <!-- Frobenius Element -->
  <section id="frobenius">
    <div class="chapter-header reveal">
      <div class="chapter-number">Chapter 62</div>
      <h2>The Frobenius Element</h2>
    </div>

    <div class="two-column">
      <div class="prose reveal">
        <p>
          For an unramified prime $\mathfrak{P}$ over $p$ in a Galois extension $L/K$, there's
          a special element $\text{Frob}_\mathfrak{P} \in \text{Gal}(L/K)$ that captures
          the arithmetic of $p$.
        </p>

        <div class="definition">
          <div class="def-title">The Frobenius Element</div>
          <p style="margin-bottom: 0;">
            $\text{Frob}_\mathfrak{P}$ is the unique $\sigma \in \text{Gal}(L/K)$ such that:
            $$\sigma(x) \equiv x^{N(\mathfrak{p})} \pmod{\mathfrak{P}}$$
            for all $x \in \mathcal{O}_L$, where $\mathfrak{p} = \mathfrak{P} \cap \mathcal{O}_K$.
          </p>
        </div>

        <p>
          The Frobenius "is" the $p$-th power map, lifted to characteristic 0. Its order equals
          the inertia degree $f$. The conjugacy class of $\text{Frob}_\mathfrak{P}$ depends only on $p$!
        </p>

        <p>
          This is the key to understanding how primes split: the splitting type of $p$ is
          determined by the cycle type of $\text{Frob}_p$ acting on roots.
        </p>
      </div>

      <div class="interactive-container reveal">
        <h3>Frobenius in Finite Fields</h3>
        <p class="instruction">See the Frobenius automorphism x ‚Ü¶ x·µñ in action</p>

        <div class="controls">
          <div class="control-group">
            <label>Field $\mathbb{F}_{p^n}$: p = <span x-text="frobP"></span></label>
            <input type="range" x-model="frobP" min="2" max="7" step="1" @input="updateFrobenius()">
          </div>
          <div class="control-group">
            <label>n = <span x-text="frobN"></span></label>
            <input type="range" x-model="frobN" min="1" max="4" step="1" @input="updateFrobenius()">
          </div>
        </div>

        <div class="svg-container" id="frobenius-viz"></div>

        <div class="stats">
          <div class="stat galois">
            <div class="stat-value" x-text="'‚Ñ§/' + frobN + '‚Ñ§'"></div>
            <div class="stat-label">Gal(ùîΩ‚Çö‚Åø/ùîΩ‚Çö)</div>
          </div>
          <div class="stat integer">
            <div class="stat-value" x-text="Math.pow(frobP, frobN)"></div>
            <div class="stat-label">|ùîΩ‚Çö‚Åø|</div>
          </div>
          <div class="stat prime">
            <div class="stat-value" x-text="frobN"></div>
            <div class="stat-label">ord(Frob)</div>
          </div>
        </div>

        <p class="annotation">
          The Frobenius generates Gal(ùîΩ‚Çö‚Åø/ùîΩ‚Çö) ‚âÖ ‚Ñ§/n‚Ñ§. Each orbit under x ‚Ü¶ x·µñ has size dividing n.
        </p>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer>
    <p>
      Parts XIV & XV of <em>An Infinitely Large Napkin</em> by Evan Chen<br>
      Interactive exploration of algebraic number theory<br>
      <a href="https://venhance.github.io/napkin/" target="_blank">Original source ‚Üí</a>
    </p>
  </footer>

  <script>
    // Initialize KaTeX
    document.addEventListener('DOMContentLoaded', () => {
      renderMathInElement(document.body, {
        delimiters: [
          {left: '$$', right: '$$', display: true},
          {left: '$', right: '$', display: false}
        ],
        throwOnError: false
      });
    });

    // Number theory helpers
    const NT = {
      gcd: (a, b) => b === 0 ? Math.abs(a) : NT.gcd(b, a % b),
      isPrime: n => {
        if (n < 2) return false;
        if (n === 2) return true;
        if (n % 2 === 0) return false;
        for (let i = 3; i * i <= n; i += 2) {
          if (n % i === 0) return false;
        }
        return true;
      },
      legendre: (a, p) => {
        if (p === 2) return 1;
        a = ((a % p) + p) % p;
        if (a === 0) return 0;
        let result = 1;
        while (a !== 0) {
          while (a % 2 === 0) {
            a /= 2;
            if (p % 8 === 3 || p % 8 === 5) result = -result;
          }
          [a, p] = [p, a];
          if (a % 4 === 3 && p % 4 === 3) result = -result;
          a = a % p;
        }
        return p === 1 ? result : 0;
      },
      norm: (a, b, d) => a * a - d * b * b,
      gaussianNorm: (a, b) => a * a + b * b,
      isGaussianPrime: (a, b) => {
        const n = NT.gaussianNorm(a, b);
        if (n === 0) return false;
        if (a === 0) return Math.abs(b) % 4 === 3 && NT.isPrime(Math.abs(b));
        if (b === 0) return Math.abs(a) % 4 === 3 && NT.isPrime(Math.abs(a));
        return NT.isPrime(n);
      },
      isGaussianUnit: (a, b) => NT.gaussianNorm(a, b) === 1
    };

    // Complex number for Eisenstein
    const omega = { re: -0.5, im: Math.sqrt(3) / 2 };

    function algebraicNTExplorer() {
      return {
        scrollProgress: 0,
        currentSection: 'hero',

        // Minimal polynomial test
        testNumber: 'sqrt2',
        minPolyData: { isInteger: true, degree: 2, polynomial: 'x¬≤ - 2' },

        // Lattice displays
        gaussianShow: 'all',
        eisensteinShow: 'all',

        // Ideal factorization
        idealFactor: '6',

        // Class group
        classGroupD: -5,
        classGroupData: { discriminant: -20, minkowski: 2.85, classNumber: 2, isUFD: false },

        // Galois
        galoisPoly: 'x4-2',
        galoisData: { groupName: 'D‚ÇÑ', order: 8, numRoots: 4 },

        // Ramification
        ramifyD: -5,
        ramifyP: 2,
        ramificationResult: { type: 'ramify', factorization: 'ùîì¬≤', criterion: 'p | Œî' },

        // Frobenius
        frobP: 2,
        frobN: 3,

        init() {
          gsap.registerPlugin(ScrollTrigger);

          ScrollTrigger.create({
            trigger: 'body',
            start: 'top top',
            end: 'bottom bottom',
            onUpdate: self => this.scrollProgress = self.progress * 100
          });

          const sections = ['hero', 'algebraic-integers', 'gaussian', 'ufd-failure', 'ideals', 'class-group', 'galois', 'ramification', 'frobenius'];
          sections.forEach(id => {
            ScrollTrigger.create({
              trigger: `#${id}`,
              start: 'top center',
              end: 'bottom center',
              onEnter: () => this.currentSection = id,
              onEnterBack: () => this.currentSection = id
            });
          });

          gsap.utils.toArray('.reveal').forEach(el => {
            gsap.from(el, {
              y: 50,
              opacity: 0,
              duration: 0.8,
              ease: 'power3.out',
              scrollTrigger: {
                trigger: el,
                start: 'top 85%',
                toggleActions: 'play none none reverse'
              }
            });
          });

          // Initialize visualizations
          setTimeout(() => {
            this.initHeroLattice();
            this.updateMinPoly();
            this.initGaussianLattice();
            this.initEisensteinLattice();
            this.initUFDFailure();
            this.updateIdealFactor();
            this.updateClassGroup();
            this.initMinkowskiViz();
            this.updateGaloisRoots();
            this.initSplittingDiagrams();
            this.updateRamification();
            this.updateFrobenius();
          }, 100);

          // Watchers
          this.$watch('testNumber', () => this.updateMinPoly());
          this.$watch('gaussianShow', () => this.initGaussianLattice());
          this.$watch('eisensteinShow', () => this.initEisensteinLattice());
          this.$watch('idealFactor', () => this.updateIdealFactor());
          this.$watch('galoisPoly', () => this.updateGaloisRoots());
        },

        initHeroLattice() {
          const container = document.getElementById('hero-lattice');
          if (!container) return;

          const width = window.innerWidth;
          const height = window.innerHeight;

          const svg = d3.select(container)
            .attr('width', width)
            .attr('height', height);

          // Draw Gaussian integer lattice
          const scale = 30;
          const cx = width / 2;
          const cy = height / 2;

          for (let a = -Math.ceil(width / scale / 2); a <= Math.ceil(width / scale / 2); a++) {
            for (let b = -Math.ceil(height / scale / 2); b <= Math.ceil(height / scale / 2); b++) {
              const x = cx + a * scale;
              const y = cy - b * scale;

              svg.append('circle')
                .attr('cx', x)
                .attr('cy', y)
                .attr('r', 2)
                .attr('fill', '#3b82f6')
                .attr('opacity', 0.3);
            }
          }
        },

        updateMinPoly() {
          const data = {
            'sqrt2': { isInteger: true, degree: 2, polynomial: 'x¬≤ - 2', value: Math.sqrt(2) },
            'sqrt5': { isInteger: true, degree: 2, polynomial: 'x¬≤ - x - 1', value: (1 + Math.sqrt(5)) / 2 },
            'cbrt2': { isInteger: true, degree: 3, polynomial: 'x¬≥ - 2', value: Math.cbrt(2) },
            'half': { isInteger: false, degree: 1, polynomial: '2x - 1', value: 0.5 }
          };

          this.minPolyData = data[this.testNumber];

          // Visualize
          const container = document.getElementById('min-poly-viz');
          if (!container) return;

          container.innerHTML = '';

          const width = container.clientWidth;
          const height = 400;

          const svg = d3.select(container)
            .append('svg')
            .attr('viewBox', `0 0 ${width} ${height}`)
            .attr('width', '100%');

          const cx = width / 2;
          const cy = height / 2;

          // Draw number line / complex plane
          svg.append('line')
            .attr('x1', 50).attr('y1', cy)
            .attr('x2', width - 50).attr('y2', cy)
            .attr('stroke', '#64748b').attr('stroke-width', 1);

          // Tick marks
          const scale = 80;
          for (let i = -3; i <= 3; i++) {
            svg.append('line')
              .attr('x1', cx + i * scale).attr('y1', cy - 5)
              .attr('x2', cx + i * scale).attr('y2', cy + 5)
              .attr('stroke', '#64748b');

            svg.append('text')
              .attr('x', cx + i * scale)
              .attr('y', cy + 20)
              .attr('fill', '#64748b')
              .attr('text-anchor', 'middle')
              .attr('font-size', '12px')
              .text(i);
          }

          // Mark the number
          const val = this.minPolyData.value;
          svg.append('circle')
            .attr('cx', cx + val * scale)
            .attr('cy', cy)
            .attr('r', 10)
            .attr('fill', this.minPolyData.isInteger ? '#10b981' : '#ef4444');

          svg.append('text')
            .attr('x', cx + val * scale)
            .attr('y', cy - 25)
            .attr('fill', this.minPolyData.isInteger ? '#10b981' : '#ef4444')
            .attr('text-anchor', 'middle')
            .attr('font-size', '14px')
            .text(val.toFixed(3));

          // Label
          svg.append('text')
            .attr('x', cx)
            .attr('y', 50)
            .attr('fill', '#f1f5f9')
            .attr('text-anchor', 'middle')
            .attr('font-size', '16px')
            .text(this.minPolyData.isInteger ? 'Algebraic Integer' : 'NOT an Algebraic Integer');
        },

        initGaussianLattice() {
          const container = document.getElementById('gaussian-lattice');
          if (!container) return;

          container.innerHTML = '';

          const width = container.clientWidth;
          const height = 420;

          const svg = d3.select(container)
            .append('svg')
            .attr('viewBox', `0 0 ${width} ${height}`)
            .attr('width', '100%');

          const cx = width / 2;
          const cy = height / 2;
          const scale = 35;
          const range = 5;

          // Grid
          svg.append('line')
            .attr('x1', 0).attr('y1', cy)
            .attr('x2', width).attr('y2', cy)
            .attr('stroke', '#333').attr('stroke-width', 1);

          svg.append('line')
            .attr('x1', cx).attr('y1', 0)
            .attr('x2', cx).attr('y2', height)
            .attr('stroke', '#333').attr('stroke-width', 1);

          // Lattice points
          for (let a = -range; a <= range; a++) {
            for (let b = -range; b <= range; b++) {
              if (a === 0 && b === 0) continue;

              const isUnit = NT.isGaussianUnit(a, b);
              const isPrime = NT.isGaussianPrime(a, b);

              let show = true;
              let color = '#3b82f6';
              let radius = 5;

              if (isUnit) {
                color = '#10b981';
                radius = 8;
                if (this.gaussianShow === 'primes') show = false;
              } else if (isPrime) {
                color = '#ef4444';
                radius = 7;
                if (this.gaussianShow === 'units') show = false;
              } else {
                if (this.gaussianShow !== 'all') show = false;
              }

              if (show) {
                svg.append('circle')
                  .attr('cx', cx + a * scale)
                  .attr('cy', cy - b * scale)
                  .attr('r', radius)
                  .attr('fill', color)
                  .attr('opacity', 0.8);
              }
            }
          }

          // Origin
          svg.append('circle')
            .attr('cx', cx)
            .attr('cy', cy)
            .attr('r', 3)
            .attr('fill', '#64748b');

          // Labels
          svg.append('text')
            .attr('x', cx + scale)
            .attr('y', cy + 15)
            .attr('fill', '#64748b')
            .attr('font-size', '12px')
            .text('1');

          svg.append('text')
            .attr('x', cx + 8)
            .attr('y', cy - scale)
            .attr('fill', '#64748b')
            .attr('font-size', '12px')
            .text('i');
        },

        initEisensteinLattice() {
          const container = document.getElementById('eisenstein-lattice');
          if (!container) return;

          container.innerHTML = '';

          const width = container.clientWidth;
          const height = 420;

          const svg = d3.select(container)
            .append('svg')
            .attr('viewBox', `0 0 ${width} ${height}`)
            .attr('width', '100%');

          const cx = width / 2;
          const cy = height / 2;
          const scale = 35;
          const range = 6;

          // Axes
          svg.append('line')
            .attr('x1', 0).attr('y1', cy)
            .attr('x2', width).attr('y2', cy)
            .attr('stroke', '#333').attr('stroke-width', 1);

          // Eisenstein lattice: points a + b*omega where omega = e^{2pi i/3}
          for (let a = -range; a <= range; a++) {
            for (let b = -range; b <= range; b++) {
              if (a === 0 && b === 0) continue;

              // z = a + b*omega
              const x = a + b * omega.re;
              const y = b * omega.im;

              const norm = a * a - a * b + b * b;  // Eisenstein norm
              const isUnit = norm === 1;
              const isPrime = norm > 1 && NT.isPrime(norm);

              let show = true;
              let color = '#3b82f6';
              let radius = 5;

              if (isUnit) {
                color = '#10b981';
                radius = 8;
                if (this.eisensteinShow === 'primes') show = false;
              } else if (isPrime) {
                color = '#ef4444';
                radius = 7;
                if (this.eisensteinShow === 'units') show = false;
              } else {
                if (this.eisensteinShow !== 'all') show = false;
              }

              const px = cx + x * scale;
              const py = cy - y * scale;

              if (px > 0 && px < width && py > 0 && py < height && show) {
                svg.append('circle')
                  .attr('cx', px)
                  .attr('cy', py)
                  .attr('r', radius)
                  .attr('fill', color)
                  .attr('opacity', 0.8);
              }
            }
          }

          // Origin
          svg.append('circle')
            .attr('cx', cx)
            .attr('cy', cy)
            .attr('r', 3)
            .attr('fill', '#64748b');

          // Label omega
          svg.append('text')
            .attr('x', cx + omega.re * scale + 10)
            .attr('y', cy - omega.im * scale)
            .attr('fill', '#64748b')
            .attr('font-size', '12px')
            .text('œâ');
        },

        initUFDFailure() {
          const container = document.getElementById('ufd-failure-viz');
          if (!container) return;

          container.innerHTML = '';

          const width = container.clientWidth;
          const height = 400;

          const svg = d3.select(container)
            .append('svg')
            .attr('viewBox', `0 0 ${width} ${height}`)
            .attr('width', '100%');

          const cx = width / 2;
          const cy = height / 2;
          const scale = 40;

          // Draw the lattice Z[sqrt(-5)]
          for (let a = -5; a <= 5; a++) {
            for (let b = -3; b <= 3; b++) {
              const x = cx + a * scale;
              const y = cy - b * scale * 2.2;  // sqrt(5) ‚âà 2.236

              // Calculate norm
              const norm = a * a + 5 * b * b;

              let color = '#3b82f6';
              let radius = 4;

              // Highlight key elements
              if ((a === 2 && b === 0) || (a === 3 && b === 0)) {
                color = '#ef4444';
                radius = 10;
              } else if ((a === 1 && Math.abs(b) === 1) || (a === -1 && Math.abs(b) === 1)) {
                color = '#f59e0b';
                radius = 10;
              } else if (norm === 6) {
                color = '#8b5cf6';
                radius = 6;
              }

              if (x > 30 && x < width - 30 && y > 30 && y < height - 30) {
                svg.append('circle')
                  .attr('cx', x)
                  .attr('cy', y)
                  .attr('r', radius)
                  .attr('fill', color)
                  .attr('opacity', 0.7);
              }
            }
          }

          // Axes
          svg.append('line')
            .attr('x1', 30).attr('y1', cy)
            .attr('x2', width - 30).attr('y2', cy)
            .attr('stroke', '#444');

          svg.append('line')
            .attr('x1', cx).attr('y1', 30)
            .attr('x2', cx).attr('y2', height - 30)
            .attr('stroke', '#444');

          // Labels for the irreducibles
          svg.append('text')
            .attr('x', cx + 2 * scale)
            .attr('y', cy + 25)
            .attr('fill', '#ef4444')
            .attr('text-anchor', 'middle')
            .attr('font-size', '14px')
            .text('2');

          svg.append('text')
            .attr('x', cx + 3 * scale)
            .attr('y', cy + 25)
            .attr('fill', '#ef4444')
            .attr('text-anchor', 'middle')
            .attr('font-size', '14px')
            .text('3');

          svg.append('text')
            .attr('x', cx + scale + 15)
            .attr('y', cy - scale * 2.2 - 10)
            .attr('fill', '#f59e0b')
            .attr('font-size', '12px')
            .text('1+‚àö-5');

          svg.append('text')
            .attr('x', cx + scale + 15)
            .attr('y', cy + scale * 2.2 + 15)
            .attr('fill', '#f59e0b')
            .attr('font-size', '12px')
            .text('1-‚àö-5');

          // Axis label
          svg.append('text')
            .attr('x', cx + 10)
            .attr('y', 50)
            .attr('fill', '#64748b')
            .attr('font-size', '12px')
            .text('‚àö-5 axis');
        },

        updateIdealFactor() {
          const container = document.getElementById('ideal-factor-viz');
          if (!container) return;

          container.innerHTML = '';

          const width = container.clientWidth;
          const height = 330;

          const svg = d3.select(container)
            .append('svg')
            .attr('viewBox', `0 0 ${width} ${height}`)
            .attr('width', '100%');

          const data = {
            '2': { primes: ['ùî≠', 'ùî≠'], label: '(2) = ùî≠¬≤' },
            '3': { primes: ['ùîÆ', 'ùîÆÃÑ'], label: '(3) = ùîÆùîÆÃÑ' },
            '6': { primes: ['ùî≠', 'ùî≠', 'ùîÆ', 'ùîÆÃÑ'], label: '(6) = ùî≠¬≤ùîÆùîÆÃÑ' },
            '1+sqrt': { primes: ['ùî≠', 'ùîÆ'], label: '(1+‚àö-5) = ùî≠ùîÆ' }
          };

          const d = data[this.idealFactor];
          const colors = { 'ùî≠': '#ef4444', 'ùîÆ': '#3b82f6', 'ùîÆÃÑ': '#10b981' };

          // Draw factor tree
          const startY = 60;
          const endY = 250;
          const cx = width / 2;

          // Top node (the ideal)
          svg.append('circle')
            .attr('cx', cx)
            .attr('cy', startY)
            .attr('r', 25)
            .attr('fill', '#f59e0b');

          svg.append('text')
            .attr('x', cx)
            .attr('y', startY + 5)
            .attr('fill', '#000')
            .attr('text-anchor', 'middle')
            .attr('font-size', '14px')
            .attr('font-weight', 'bold')
            .text(this.idealFactor === '1+sqrt' ? '1+‚àö-5' : this.idealFactor);

          // Prime factors
          const n = d.primes.length;
          const spacing = Math.min(80, (width - 100) / n);
          const startX = cx - (n - 1) * spacing / 2;

          d.primes.forEach((p, i) => {
            const x = startX + i * spacing;

            // Line from top
            svg.append('line')
              .attr('x1', cx)
              .attr('y1', startY + 25)
              .attr('x2', x)
              .attr('y2', endY - 20)
              .attr('stroke', colors[p] || '#888')
              .attr('stroke-width', 2);

            // Prime ideal node
            svg.append('circle')
              .attr('cx', x)
              .attr('cy', endY)
              .attr('r', 20)
              .attr('fill', colors[p] || '#888');

            svg.append('text')
              .attr('x', x)
              .attr('y', endY + 5)
              .attr('fill', '#fff')
              .attr('text-anchor', 'middle')
              .attr('font-size', '16px')
              .text(p);
          });

          // Label
          svg.append('text')
            .attr('x', cx)
            .attr('y', height - 20)
            .attr('fill', '#94a3b8')
            .attr('text-anchor', 'middle')
            .attr('font-size', '14px')
            .text(d.label);
        },

        updateClassGroup() {
          const d = parseInt(this.classGroupD);

          // Discriminant
          let disc;
          if (d % 4 === 1) {
            disc = d;
          } else {
            disc = 4 * d;
          }

          // Minkowski bound approximation
          const minkowski = Math.sqrt(Math.abs(disc)) / Math.PI;

          // Known class numbers for small imaginary quadratic fields
          const classNumbers = {
            '-1': 1, '-2': 1, '-3': 1, '-4': 1, '-5': 2, '-6': 2, '-7': 1,
            '-8': 1, '-9': 1, '-10': 2, '-11': 1, '-12': 1, '-13': 2,
            '-14': 4, '-15': 2, '-16': 1, '-17': 4, '-18': 2, '-19': 1, '-20': 2
          };

          const h = classNumbers[d.toString()] || '?';

          this.classGroupData = {
            discriminant: disc,
            minkowski: minkowski,
            classNumber: h,
            isUFD: h === 1
          };

          // Visualize
          const container = document.getElementById('class-group-viz');
          if (!container) return;

          container.innerHTML = '';

          const width = container.clientWidth;
          const height = 330;

          const svg = d3.select(container)
            .append('svg')
            .attr('viewBox', `0 0 ${width} ${height}`)
            .attr('width', '100%');

          // Bar chart of class numbers
          const dValues = [-1, -2, -3, -5, -6, -7, -10, -11, -13, -14, -15];
          const hValues = dValues.map(v => classNumbers[v.toString()] || 1);

          const barWidth = (width - 100) / dValues.length;
          const maxH = Math.max(...hValues);
          const barScale = (height - 100) / maxH;

          dValues.forEach((dv, i) => {
            const hv = hValues[i];
            const x = 50 + i * barWidth;
            const barH = hv * barScale;

            const isSelected = dv === d;

            svg.append('rect')
              .attr('x', x + 5)
              .attr('y', height - 50 - barH)
              .attr('width', barWidth - 10)
              .attr('height', barH)
              .attr('fill', isSelected ? '#f59e0b' : (hv === 1 ? '#10b981' : '#ef4444'))
              .attr('opacity', isSelected ? 1 : 0.6)
              .attr('rx', 4);

            svg.append('text')
              .attr('x', x + barWidth / 2)
              .attr('y', height - 30)
              .attr('fill', '#94a3b8')
              .attr('text-anchor', 'middle')
              .attr('font-size', '10px')
              .text(dv);

            svg.append('text')
              .attr('x', x + barWidth / 2)
              .attr('y', height - 55 - barH)
              .attr('fill', '#f1f5f9')
              .attr('text-anchor', 'middle')
              .attr('font-size', '12px')
              .text('h=' + hv);
          });

          // Title
          svg.append('text')
            .attr('x', width / 2)
            .attr('y', 30)
            .attr('fill', '#f1f5f9')
            .attr('text-anchor', 'middle')
            .attr('font-size', '14px')
            .text('Class Numbers of ‚Ñö(‚àöd)');
        },

        initMinkowskiViz() {
          const container = document.getElementById('minkowski-viz');
          if (!container) return;

          container.innerHTML = '';

          const width = container.clientWidth;
          const height = 420;

          const svg = d3.select(container)
            .append('svg')
            .attr('viewBox', `0 0 ${width} ${height}`)
            .attr('width', '100%');

          const cx = width / 2;
          const cy = height / 2;
          const scale = 40;

          // Lattice
          for (let a = -5; a <= 5; a++) {
            for (let b = -4; b <= 4; b++) {
              svg.append('circle')
                .attr('cx', cx + a * scale)
                .attr('cy', cy - b * scale)
                .attr('r', 4)
                .attr('fill', '#3b82f6')
                .attr('opacity', 0.6);
            }
          }

          // Fundamental domain
          svg.append('rect')
            .attr('x', cx)
            .attr('y', cy - scale)
            .attr('width', scale)
            .attr('height', scale)
            .attr('fill', '#f59e0b')
            .attr('opacity', 0.2)
            .attr('stroke', '#f59e0b')
            .attr('stroke-width', 2);

          // Convex body (ellipse)
          svg.append('ellipse')
            .attr('cx', cx)
            .attr('cy', cy)
            .attr('rx', scale * 2.5)
            .attr('ry', scale * 1.8)
            .attr('fill', '#8b5cf6')
            .attr('opacity', 0.2)
            .attr('stroke', '#8b5cf6')
            .attr('stroke-width', 2);

          // Highlight captured lattice points
          for (let a = -2; a <= 2; a++) {
            for (let b = -1; b <= 1; b++) {
              const x = a * scale;
              const y = b * scale;
              if ((x / (scale * 2.5)) ** 2 + (y / (scale * 1.8)) ** 2 <= 1) {
                if (a !== 0 || b !== 0) {
                  svg.append('circle')
                    .attr('cx', cx + x)
                    .attr('cy', cy - y)
                    .attr('r', 8)
                    .attr('fill', '#10b981');
                }
              }
            }
          }

          // Origin
          svg.append('circle')
            .attr('cx', cx)
            .attr('cy', cy)
            .attr('r', 6)
            .attr('fill', '#ef4444');
        },

        updateGaloisRoots() {
          const container = document.getElementById('galois-roots-viz');
          if (!container) return;

          container.innerHTML = '';

          const width = container.clientWidth;
          const height = 420;

          const svg = d3.select(container)
            .append('svg')
            .attr('viewBox', `0 0 ${width} ${height}`)
            .attr('width', '100%');

          const cx = width / 2;
          const cy = height / 2;
          const radius = 120;

          // Unit circle
          svg.append('circle')
            .attr('cx', cx)
            .attr('cy', cy)
            .attr('r', radius)
            .attr('fill', 'none')
            .attr('stroke', '#333')
            .attr('stroke-width', 1);

          // Axes
          svg.append('line')
            .attr('x1', cx - radius - 30).attr('y1', cy)
            .attr('x2', cx + radius + 30).attr('y2', cy)
            .attr('stroke', '#444');

          svg.append('line')
            .attr('x1', cx).attr('y1', cy - radius - 30)
            .attr('x2', cx).attr('y2', cy + radius + 30)
            .attr('stroke', '#444');

          let roots, groupName, order;

          if (this.galoisPoly === 'x4-2') {
            // Fourth roots of 2: 2^{1/4}, i*2^{1/4}, -2^{1/4}, -i*2^{1/4}
            const r = Math.pow(2, 0.25);
            roots = [
              { re: r, im: 0, label: '‚Å¥‚àö2' },
              { re: 0, im: r, label: 'i‚Å¥‚àö2' },
              { re: -r, im: 0, label: '-‚Å¥‚àö2' },
              { re: 0, im: -r, label: '-i‚Å¥‚àö2' }
            ];
            groupName = 'D‚ÇÑ';
            order = 8;
          } else if (this.galoisPoly === 'x3-2') {
            // Cube roots of 2
            const r = Math.cbrt(2);
            roots = [
              { re: r, im: 0, label: '¬≥‚àö2' },
              { re: r * Math.cos(2 * Math.PI / 3), im: r * Math.sin(2 * Math.PI / 3), label: 'œâ¬≥‚àö2' },
              { re: r * Math.cos(4 * Math.PI / 3), im: r * Math.sin(4 * Math.PI / 3), label: 'œâ¬≤¬≥‚àö2' }
            ];
            groupName = 'S‚ÇÉ';
            order = 6;
          } else {
            // Cyclotomic: 5th roots of unity (primitive)
            roots = [];
            for (let k = 1; k < 5; k++) {
              const theta = 2 * Math.PI * k / 5;
              roots.push({
                re: Math.cos(theta),
                im: Math.sin(theta),
                label: 'Œ∂‚ÇÖ^' + k
              });
            }
            groupName = '(‚Ñ§/5)√ó';
            order = 4;
          }

          this.galoisData = { groupName, order, numRoots: roots.length };

          // Scale factor for display
          const displayScale = radius / Math.max(...roots.map(r => Math.sqrt(r.re ** 2 + r.im ** 2)));

          // Draw roots
          const colors = ['#ef4444', '#f59e0b', '#10b981', '#3b82f6'];
          roots.forEach((root, i) => {
            const x = cx + root.re * displayScale;
            const y = cy - root.im * displayScale;

            svg.append('circle')
              .attr('cx', x)
              .attr('cy', y)
              .attr('r', 12)
              .attr('fill', colors[i % colors.length]);

            svg.append('text')
              .attr('x', x + 15)
              .attr('y', y - 10)
              .attr('fill', colors[i % colors.length])
              .attr('font-size', '12px')
              .text(root.label);
          });

          // Draw arrows showing Galois action
          if (roots.length >= 2) {
            const arrowPath = d3.line().curve(d3.curveBasis);

            for (let i = 0; i < Math.min(roots.length, 4); i++) {
              const j = (i + 1) % roots.length;
              const r1 = roots[i], r2 = roots[j];

              const x1 = cx + r1.re * displayScale;
              const y1 = cy - r1.im * displayScale;
              const x2 = cx + r2.re * displayScale;
              const y2 = cy - r2.im * displayScale;

              // Curved arrow
              const midX = (x1 + x2) / 2 + (y2 - y1) * 0.2;
              const midY = (y1 + y2) / 2 + (x1 - x2) * 0.2;

              svg.append('path')
                .attr('d', arrowPath([[x1, y1], [midX, midY], [x2, y2]]))
                .attr('fill', 'none')
                .attr('stroke', '#84cc16')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '5,3')
                .attr('marker-end', 'url(#arrow)');
            }
          }

          // Arrow marker
          svg.append('defs').append('marker')
            .attr('id', 'arrow')
            .attr('markerWidth', 10)
            .attr('markerHeight', 7)
            .attr('refX', 9)
            .attr('refY', 3.5)
            .attr('orient', 'auto')
            .append('polygon')
            .attr('points', '0 0, 10 3.5, 0 7')
            .attr('fill', '#84cc16');
        },

        initSplittingDiagrams() {
          // Simple static diagrams for the three types
          ['split', 'inert', 'ramify'].forEach(type => {
            const container = document.querySelector(`#${type}-viz .diagram`);
            if (!container) return;

            const svg = d3.select(container)
              .append('svg')
              .attr('viewBox', '0 0 200 150')
              .attr('width', '100%')
              .attr('height', '100%');

            // Top node (p)
            svg.append('circle')
              .attr('cx', 100)
              .attr('cy', 30)
              .attr('r', 20)
              .attr('fill', '#64748b');

            svg.append('text')
              .attr('x', 100)
              .attr('y', 35)
              .attr('fill', '#fff')
              .attr('text-anchor', 'middle')
              .attr('font-size', '14px')
              .text('p');

            if (type === 'split') {
              // Two children
              svg.append('line').attr('x1', 100).attr('y1', 50).attr('x2', 60).attr('y2', 100).attr('stroke', '#8b5cf6').attr('stroke-width', 2);
              svg.append('line').attr('x1', 100).attr('y1', 50).attr('x2', 140).attr('y2', 100).attr('stroke', '#8b5cf6').attr('stroke-width', 2);

              svg.append('circle').attr('cx', 60).attr('cy', 120).attr('r', 18).attr('fill', '#8b5cf6');
              svg.append('circle').attr('cx', 140).attr('cy', 120).attr('r', 18).attr('fill', '#8b5cf6');

              svg.append('text').attr('x', 60).attr('y', 125).attr('fill', '#fff').attr('text-anchor', 'middle').attr('font-size', '12px').text('ùîì‚ÇÅ');
              svg.append('text').attr('x', 140).attr('y', 125).attr('fill', '#fff').attr('text-anchor', 'middle').attr('font-size', '12px').text('ùîì‚ÇÇ');
            } else if (type === 'inert') {
              // One child
              svg.append('line').attr('x1', 100).attr('y1', 50).attr('x2', 100).attr('y2', 100).attr('stroke', '#06b6d4').attr('stroke-width', 2);

              svg.append('circle').attr('cx', 100).attr('cy', 120).attr('r', 18).attr('fill', '#06b6d4');
              svg.append('text').attr('x', 100).attr('y', 125).attr('fill', '#fff').attr('text-anchor', 'middle').attr('font-size', '12px').text('ùîì');
            } else {
              // One child with exponent
              svg.append('line').attr('x1', 100).attr('y1', 50).attr('x2', 100).attr('y2', 100).attr('stroke', '#ec4899').attr('stroke-width', 3);

              svg.append('circle').attr('cx', 100).attr('cy', 120).attr('r', 18).attr('fill', '#ec4899');
              svg.append('text').attr('x', 100).attr('y', 125).attr('fill', '#fff').attr('text-anchor', 'middle').attr('font-size', '12px').text('ùîì¬≤');
            }
          });
        },

        updateRamification() {
          const d = parseInt(this.ramifyD);
          const p = parseInt(this.ramifyP);

          if (d === 0 || d === 1) {
            this.ramificationResult = { type: 'split', factorization: 'N/A', criterion: 'd invalid' };
            return;
          }

          // Discriminant
          let disc;
          if (d % 4 === 1) {
            disc = d;
          } else {
            disc = 4 * d;
          }

          let type, factorization, criterion;

          if (disc % p === 0) {
            type = 'ramify';
            factorization = 'ùîì¬≤';
            criterion = 'p | Œî';
          } else {
            const leg = NT.legendre(disc, p);
            if (leg === 1) {
              type = 'split';
              factorization = 'ùîì‚ÇÅùîì‚ÇÇ';
              criterion = '(Œî/p) = 1';
            } else {
              type = 'inert';
              factorization = 'ùîì';
              criterion = '(Œî/p) = -1';
            }
          }

          this.ramificationResult = { type, factorization, criterion };
        },

        updateFrobenius() {
          const container = document.getElementById('frobenius-viz');
          if (!container) return;

          container.innerHTML = '';

          const width = container.clientWidth;
          const height = 420;
          const p = parseInt(this.frobP);
          const n = parseInt(this.frobN);

          const svg = d3.select(container)
            .append('svg')
            .attr('viewBox', `0 0 ${width} ${height}`)
            .attr('width', '100%');

          const cx = width / 2;
          const cy = height / 2;
          const radius = 140;

          // Circle for F_{p^n}^*
          svg.append('circle')
            .attr('cx', cx)
            .attr('cy', cy)
            .attr('r', radius)
            .attr('fill', 'none')
            .attr('stroke', '#333')
            .attr('stroke-width', 1);

          // Elements of F_{p^n} (represented on circle)
          const order = Math.pow(p, n) - 1;  // |F_{p^n}^*|
          const numToShow = Math.min(order, 24);

          const elements = [];
          for (let i = 0; i < numToShow; i++) {
            const angle = (2 * Math.PI * i) / numToShow - Math.PI / 2;
            elements.push({
              index: i,
              x: cx + radius * Math.cos(angle),
              y: cy + radius * Math.sin(angle),
              angle: angle
            });
          }

          // Draw elements
          elements.forEach((el, i) => {
            svg.append('circle')
              .attr('cx', el.x)
              .attr('cy', el.y)
              .attr('r', 8)
              .attr('fill', '#3b82f6');

            if (numToShow <= 12) {
              svg.append('text')
                .attr('x', el.x + 15 * Math.cos(el.angle))
                .attr('y', el.y + 15 * Math.sin(el.angle))
                .attr('fill', '#94a3b8')
                .attr('text-anchor', 'middle')
                .attr('font-size', '10px')
                .text(i);
            }
          });

          // Draw Frobenius orbits (x -> x^p)
          // In F_{p^n}^*, raising to p-th power cycles through elements
          const colors = ['#ef4444', '#f59e0b', '#10b981', '#8b5cf6', '#ec4899', '#06b6d4'];
          let colorIdx = 0;

          const visited = new Set();

          for (let start = 0; start < numToShow; start++) {
            if (visited.has(start)) continue;

            // Follow the orbit
            let current = start;
            const orbit = [current];
            visited.add(current);

            for (let step = 0; step < n; step++) {
              // x -> x^p in the multiplicative group is multiplication by p mod (p^n - 1)
              const next = (current * p) % numToShow;
              if (next === start) break;
              orbit.push(next);
              visited.add(next);
              current = next;
            }

            // Draw orbit arrows
            if (orbit.length > 1) {
              const color = colors[colorIdx % colors.length];
              colorIdx++;

              for (let i = 0; i < orbit.length; i++) {
                const from = elements[orbit[i]];
                const to = elements[orbit[(i + 1) % orbit.length]];

                // Curved arrow inside the circle
                const midAngle = (from.angle + to.angle) / 2;
                const midRadius = radius * 0.7;
                const midX = cx + midRadius * Math.cos(midAngle);
                const midY = cy + midRadius * Math.sin(midAngle);

                const path = d3.line().curve(d3.curveBasis);
                svg.append('path')
                  .attr('d', path([[from.x, from.y], [midX, midY], [to.x, to.y]]))
                  .attr('fill', 'none')
                  .attr('stroke', color)
                  .attr('stroke-width', 2)
                  .attr('opacity', 0.6);
              }

              // Highlight orbit elements
              orbit.forEach(idx => {
                svg.append('circle')
                  .attr('cx', elements[idx].x)
                  .attr('cy', elements[idx].y)
                  .attr('r', 10)
                  .attr('fill', 'none')
                  .attr('stroke', color)
                  .attr('stroke-width', 2);
              });
            }
          }

          // Center label
          svg.append('text')
            .attr('x', cx)
            .attr('y', cy)
            .attr('fill', '#f1f5f9')
            .attr('text-anchor', 'middle')
            .attr('font-size', '16px')
            .text(`ùîΩ_{${p}^${n}}`);

          svg.append('text')
            .attr('x', cx)
            .attr('y', cy + 20)
            .attr('fill', '#94a3b8')
            .attr('text-anchor', 'middle')
            .attr('font-size', '12px')
            .text(`x ‚Ü¶ x^${p}`);
        }
      };
    }
  </script>
</body>
</html>
