<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Groups: An Interactive Exploration</title>
    <style>
        :root {
            --bg: #fafafa;
            --text: #1a1a2e;
            --accent: #e63946;
            --accent2: #457b9d;
            --accent3: #2a9d8f;
            --muted: #6c757d;
            --border: #dee2e6;
            --card-bg: #ffffff;
            --shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, Georgia, serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.8;
            font-size: 18px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            padding: 4rem 2rem;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            margin-bottom: 3rem;
        }

        header h1 {
            font-size: 3.5rem;
            font-weight: 300;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
        }

        header .subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            font-style: italic;
        }

        h2 {
            font-size: 2rem;
            font-weight: 400;
            margin: 3rem 0 1.5rem;
            color: var(--accent);
            border-bottom: 2px solid var(--accent);
            padding-bottom: 0.5rem;
        }

        h3 {
            font-size: 1.4rem;
            font-weight: 600;
            margin: 2rem 0 1rem;
            color: var(--accent2);
        }

        p {
            margin-bottom: 1.5rem;
            text-align: justify;
        }

        .lead {
            font-size: 1.25rem;
            color: var(--muted);
            font-style: italic;
            margin-bottom: 2rem;
        }

        .interactive-container {
            background: var(--card-bg);
            border-radius: 12px;
            box-shadow: var(--shadow);
            padding: 2rem;
            margin: 2rem 0;
            border: 1px solid var(--border);
        }

        .interactive-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent2);
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .interactive-title::before {
            content: "▶";
            font-size: 0.8rem;
            color: var(--accent);
        }

        canvas {
            display: block;
            margin: 0 auto;
            cursor: pointer;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1.5rem;
            justify-content: center;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        label {
            font-size: 0.9rem;
            color: var(--muted);
        }

        select, input[type="range"] {
            padding: 0.5rem;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 0.9rem;
            background: white;
        }

        button {
            padding: 0.6rem 1.2rem;
            background: var(--accent2);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        button:hover {
            background: #3a6a87;
            transform: translateY(-1px);
        }

        button.secondary {
            background: var(--muted);
        }

        button.accent {
            background: var(--accent);
        }

        .math {
            font-family: 'Times New Roman', Times, serif;
            font-style: italic;
        }

        .definition {
            background: #f8f9fa;
            border-left: 4px solid var(--accent2);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }

        .definition-title {
            font-weight: 600;
            color: var(--accent2);
            margin-bottom: 0.5rem;
        }

        .example {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }

        .insight {
            background: #d4edda;
            border-left: 4px solid var(--accent3);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }

        .cayley-table {
            display: inline-block;
            margin: 1rem auto;
            border-collapse: collapse;
        }

        .cayley-table td, .cayley-table th {
            width: 40px;
            height: 40px;
            text-align: center;
            border: 1px solid var(--border);
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .cayley-table th {
            background: #f8f9fa;
            font-weight: 600;
        }

        .cayley-table td.highlight-row {
            background: rgba(69, 123, 157, 0.2);
        }

        .cayley-table td.highlight-col {
            background: rgba(230, 57, 70, 0.2);
        }

        .cayley-table td.highlight-result {
            background: rgba(42, 157, 143, 0.4);
            font-weight: bold;
        }

        .status-display {
            text-align: center;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            margin-top: 1rem;
            font-family: monospace;
            font-size: 1.1rem;
        }

        .element-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
            margin: 1rem 0;
        }

        .element-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .element-btn.selected {
            transform: scale(1.15);
            box-shadow: 0 0 0 3px var(--accent);
        }

        .permutation-display {
            display: flex;
            justify-content: center;
            gap: 0.25rem;
            margin: 1rem 0;
        }

        .perm-box {
            width: 40px;
            height: 70px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 5px;
            background: white;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-weight: 600;
        }

        .perm-arrow {
            color: var(--accent);
        }

        .nav-toc {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: var(--card-bg);
            padding: 1rem;
            border-radius: 8px;
            box-shadow: var(--shadow);
            font-size: 0.85rem;
            max-width: 200px;
            z-index: 100;
        }

        .nav-toc a {
            display: block;
            color: var(--muted);
            text-decoration: none;
            padding: 0.3rem 0;
            transition: color 0.2s;
        }

        .nav-toc a:hover {
            color: var(--accent);
        }

        @media (max-width: 1200px) {
            .nav-toc {
                display: none;
            }
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            align-items: start;
        }

        @media (max-width: 768px) {
            .two-column {
                grid-template-columns: 1fr;
            }
        }

        .footnote {
            font-size: 0.85rem;
            color: var(--muted);
            border-top: 1px solid var(--border);
            margin-top: 3rem;
            padding-top: 1rem;
        }

        .group-card {
            background: white;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .group-card:hover {
            border-color: var(--accent2);
            box-shadow: var(--shadow);
        }

        .group-card.active {
            border-color: var(--accent);
            background: rgba(230, 57, 70, 0.05);
        }

        .group-name {
            font-weight: 600;
            font-size: 1.2rem;
            margin-bottom: 0.25rem;
        }

        .group-order {
            font-size: 0.85rem;
            color: var(--muted);
        }

        .orbit-visualization {
            position: relative;
            width: 100%;
            height: 300px;
        }

        .coset-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
        }

        .coset-box {
            background: white;
            border: 2px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            min-width: 120px;
            text-align: center;
        }

        .coset-box.subgroup {
            border-color: var(--accent);
            background: rgba(230, 57, 70, 0.1);
        }

        .coset-label {
            font-size: 0.8rem;
            color: var(--muted);
            margin-bottom: 0.5rem;
        }

        .coset-elements {
            font-weight: 600;
        }

        .slider-value {
            background: var(--accent2);
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.85rem;
            min-width: 30px;
            text-align: center;
        }

        .composition-display {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            font-size: 1.5rem;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
            margin: 1rem 0;
        }

        .composition-display .op {
            color: var(--accent);
            font-weight: bold;
        }

        .composition-display .result {
            color: var(--accent3);
            font-weight: bold;
        }

        .animation-canvas {
            border: 1px solid var(--border);
            border-radius: 8px;
        }
    </style>
</head>
<body>
    <nav class="nav-toc">
        <strong>Contents</strong>
        <a href="#intro">Introduction</a>
        <a href="#definition">What is a Group?</a>
        <a href="#cyclic">Cyclic Groups</a>
        <a href="#dihedral">Dihedral Groups</a>
        <a href="#symmetric">Symmetric Groups</a>
        <a href="#isomorphisms">Isomorphisms</a>
        <a href="#subgroups">Subgroups</a>
        <a href="#lagrange">Lagrange's Theorem</a>
        <a href="#catalog">Group Catalog</a>
    </nav>

    <header>
        <h1>Groups</h1>
        <p class="subtitle">An Interactive Exploration of Symmetry and Structure</p>
    </header>

    <div class="container">
        <section id="intro">
            <p class="lead">
                A group is one of the most fundamental structures in mathematics.
                It captures the essence of symmetry, the algebra of transformations,
                and the arithmetic of combining operations. In this exploration,
                we'll make these abstract ideas concrete through direct manipulation.
            </p>

            <p>
                When you rotate a square by 90°, you perform an operation. Rotate again,
                and you've composed two operations. Eventually, four rotations bring you
                back to where you started. This simple observation—that operations can
                be combined and undone—is the heart of group theory.
            </p>
        </section>

        <section id="definition">
            <h2>What is a Group?</h2>

            <div class="definition">
                <div class="definition-title">Definition: Group</div>
                <p>
                    A <strong>group</strong> is a pair (<span class="math">G</span>, ⋆) consisting of
                    a set <span class="math">G</span> and a binary operation ⋆ satisfying:
                </p>
                <ul style="margin-left: 2rem; margin-top: 0.5rem;">
                    <li><strong>Identity:</strong> There exists an element <span class="math">e</span> such that <span class="math">e</span> ⋆ <span class="math">g</span> = <span class="math">g</span> ⋆ <span class="math">e</span> = <span class="math">g</span> for all <span class="math">g</span></li>
                    <li><strong>Associativity:</strong> (<span class="math">a</span> ⋆ <span class="math">b</span>) ⋆ <span class="math">c</span> = <span class="math">a</span> ⋆ (<span class="math">b</span> ⋆ <span class="math">c</span>)</li>
                    <li><strong>Inverses:</strong> For each <span class="math">g</span>, there exists <span class="math">g</span><sup>−1</sup> such that <span class="math">g</span> ⋆ <span class="math">g</span><sup>−1</sup> = <span class="math">e</span></li>
                </ul>
            </div>

            <p>
                The integers under addition form a group: 0 is the identity,
                addition is associative, and every integer <span class="math">n</span> has an inverse −<span class="math">n</span>.
                But let's start with something we can visualize completely:
                <strong>finite groups</strong>.
            </p>

            <h3>The Cayley Table</h3>
            <p>
                For a finite group, we can write down all possible products in a
                multiplication table called a <strong>Cayley table</strong>.
                Click any cell to see which elements multiply to give that result:
            </p>

            <div class="interactive-container">
                <div class="interactive-title">Interactive Cayley Table Explorer</div>

                <div class="controls">
                    <div class="control-group">
                        <label>Group:</label>
                        <select id="cayley-group-select">
                            <option value="z4">ℤ/4ℤ (Cyclic, order 4)</option>
                            <option value="z5">ℤ/5ℤ (Cyclic, order 5)</option>
                            <option value="z6">ℤ/6ℤ (Cyclic, order 6)</option>
                            <option value="klein">Klein Four Group V₄</option>
                            <option value="s3">S₃ (Symmetric on 3)</option>
                        </select>
                    </div>
                </div>

                <div style="overflow-x: auto; text-align: center; margin-top: 1rem;">
                    <table class="cayley-table" id="cayley-table"></table>
                </div>

                <div class="status-display" id="cayley-status">
                    Hover over cells to explore the group operation
                </div>

                <div class="insight" style="margin-top: 1rem;">
                    <strong>Notice:</strong> Each row and column contains every element exactly once.
                    This is because left-multiplication by any element is a bijection—a key property of groups!
                </div>
            </div>
        </section>

        <section id="cyclic">
            <h2>Cyclic Groups: The Clock Arithmetic</h2>

            <p>
                The simplest infinite family of groups are the <strong>cyclic groups</strong>
                ℤ/<span class="math">n</span>ℤ. Think of a clock: when you add hours,
                you eventually wrap around. 12 o'clock plus 3 hours is 3 o'clock, not 15 o'clock.
            </p>

            <p>
                A cyclic group has a single <strong>generator</strong>—an element whose
                repeated application produces every element of the group.
                On a clock, adding 1 hour repeatedly generates all 12 positions.
            </p>

            <div class="interactive-container">
                <div class="interactive-title">Cyclic Group Visualizer</div>

                <canvas id="cyclic-canvas" width="400" height="400" class="animation-canvas"></canvas>

                <div class="controls">
                    <div class="control-group">
                        <label>Order n:</label>
                        <input type="range" id="cyclic-n" min="3" max="12" value="6">
                        <span class="slider-value" id="cyclic-n-val">6</span>
                    </div>
                    <button id="cyclic-add" class="accent">+1 (Add Generator)</button>
                    <button id="cyclic-sub" class="secondary">−1 (Subtract)</button>
                    <button id="cyclic-reset">Reset to 0</button>
                </div>

                <div class="status-display" id="cyclic-status">
                    Current position: <strong>0</strong> in ℤ/6ℤ
                </div>

                <div class="composition-display" id="cyclic-composition" style="display: none;">
                    <span id="cyclic-a">0</span>
                    <span class="op">+</span>
                    <span id="cyclic-b">1</span>
                    <span class="op">=</span>
                    <span class="result" id="cyclic-result">1</span>
                    <span style="color: var(--muted); font-size: 0.9rem;">(mod <span id="cyclic-mod">6</span>)</span>
                </div>
            </div>

            <h3>Order of an Element</h3>
            <p>
                The <strong>order</strong> of an element <span class="math">g</span> is the smallest
                positive integer <span class="math">n</span> such that <span class="math">g</span><sup><span class="math">n</span></sup> = <span class="math">e</span>
                (the identity). In a cyclic group ℤ/<span class="math">n</span>ℤ, what is the order of each element?
            </p>

            <div class="interactive-container">
                <div class="interactive-title">Element Orders in ℤ/nℤ</div>

                <div class="controls">
                    <div class="control-group">
                        <label>n =</label>
                        <input type="range" id="order-n" min="2" max="12" value="6">
                        <span class="slider-value" id="order-n-val">6</span>
                    </div>
                </div>

                <div id="order-display" style="margin-top: 1rem;"></div>

                <div class="insight" style="margin-top: 1rem;">
                    <strong>Pattern:</strong> The order of element <span class="math">k</span> in ℤ/<span class="math">n</span>ℤ
                    is <span class="math">n</span>/gcd(<span class="math">k</span>, <span class="math">n</span>).
                    Elements with order equal to <span class="math">n</span> are called <strong>generators</strong>.
                </div>
            </div>
        </section>

        <section id="dihedral">
            <h2>Dihedral Groups: Symmetries of Polygons</h2>

            <p>
                What are all the ways you can pick up a regular polygon and put it back down
                so it looks the same? These symmetries form the <strong>dihedral group</strong>
                D<sub>2<span class="math">n</span></sub>, which has 2<span class="math">n</span> elements:
                <span class="math">n</span> rotations and <span class="math">n</span> reflections.
            </p>

            <div class="interactive-container">
                <div class="interactive-title">Dihedral Group Explorer</div>

                <canvas id="dihedral-canvas" width="500" height="350" class="animation-canvas"></canvas>

                <div class="controls">
                    <div class="control-group">
                        <label>Polygon:</label>
                        <select id="dihedral-n">
                            <option value="3">Triangle (D₆)</option>
                            <option value="4">Square (D₈)</option>
                            <option value="5" selected>Pentagon (D₁₀)</option>
                            <option value="6">Hexagon (D₁₂)</option>
                        </select>
                    </div>
                    <button id="dihedral-rotate" class="accent">Rotate (r)</button>
                    <button id="dihedral-reflect">Reflect (s)</button>
                    <button id="dihedral-reset" class="secondary">Reset to Identity</button>
                </div>

                <div class="status-display" id="dihedral-status">
                    Current transformation: <strong>e</strong> (identity)
                </div>

                <div class="example" style="margin-top: 1rem;">
                    <strong>Key Relations:</strong> In D<sub>2n</sub>, we have
                    <span class="math">r</span><sup><span class="math">n</span></sup> = <span class="math">e</span>,
                    <span class="math">s</span><sup>2</sup> = <span class="math">e</span>, and
                    <span class="math">srs</span> = <span class="math">r</span><sup>−1</sup>.
                    The last relation says: "reflect, rotate, reflect = rotate backwards."
                </div>
            </div>

            <p>
                Dihedral groups are <strong>non-abelian</strong> for <span class="math">n</span> ≥ 3:
                the order of operations matters! Rotating then reflecting gives a different result
                than reflecting then rotating.
            </p>

            <div class="interactive-container">
                <div class="interactive-title">Non-Commutativity Demonstration</div>

                <div class="two-column">
                    <div>
                        <canvas id="noncommute-left" width="200" height="200" class="animation-canvas"></canvas>
                        <div style="text-align: center; margin-top: 0.5rem;">
                            <strong>rs</strong> = rotate then reflect
                        </div>
                    </div>
                    <div>
                        <canvas id="noncommute-right" width="200" height="200" class="animation-canvas"></canvas>
                        <div style="text-align: center; margin-top: 0.5rem;">
                            <strong>sr</strong> = reflect then rotate
                        </div>
                    </div>
                </div>

                <div class="controls">
                    <button id="noncommute-play" class="accent">▶ Play Both</button>
                    <button id="noncommute-reset" class="secondary">Reset</button>
                </div>

                <div class="status-display" id="noncommute-status">
                    Click "Play Both" to see why rs ≠ sr
                </div>
            </div>
        </section>

        <section id="symmetric">
            <h2>Symmetric Groups: All Permutations</h2>

            <p>
                The <strong>symmetric group</strong> S<sub><span class="math">n</span></sub> consists of
                all possible ways to rearrange <span class="math">n</span> objects. It has
                <span class="math">n</span>! elements—growing very quickly!
            </p>

            <p>
                S<sub>3</sub> has 6 elements, S<sub>4</sub> has 24, and S<sub>5</sub> has 120.
                These groups are fundamental: in fact, every finite group can be embedded
                into some symmetric group (Cayley's theorem).
            </p>

            <div class="interactive-container">
                <div class="interactive-title">Permutation Composer</div>

                <div class="controls" style="margin-bottom: 1rem;">
                    <div class="control-group">
                        <label>n =</label>
                        <select id="perm-n">
                            <option value="3">3 elements</option>
                            <option value="4" selected>4 elements</option>
                            <option value="5">5 elements</option>
                        </select>
                    </div>
                </div>

                <div style="text-align: center;">
                    <div style="margin-bottom: 1rem;">
                        <strong>Permutation σ:</strong>
                        <div class="permutation-display" id="perm-sigma"></div>
                    </div>

                    <div style="margin-bottom: 1rem;">
                        <strong>Permutation τ:</strong>
                        <div class="permutation-display" id="perm-tau"></div>
                    </div>

                    <div style="margin-bottom: 1rem; padding: 1rem; background: #f8f9fa; border-radius: 8px;">
                        <strong>Composition σ ∘ τ:</strong> (apply τ first, then σ)
                        <div class="permutation-display" id="perm-result"></div>
                    </div>
                </div>

                <div class="controls">
                    <button id="perm-random-sigma">Random σ</button>
                    <button id="perm-random-tau">Random τ</button>
                    <button id="perm-swap" class="accent">Swap σ ↔ τ</button>
                </div>

                <div class="status-display" id="perm-status">
                    Click the boxes to modify permutations. Drag to rearrange.
                </div>

                <div class="insight" style="margin-top: 1rem;">
                    <strong>Observe:</strong> The composition σ ∘ τ is usually different from τ ∘ σ.
                    Symmetric groups are non-abelian for n ≥ 3!
                </div>
            </div>

            <h3>Cycle Notation</h3>
            <p>
                Instead of writing where each element goes, we can describe permutations
                using <strong>cycles</strong>. The cycle (1 3 2) means: 1→3, 3→2, 2→1.
            </p>

            <div class="interactive-container">
                <div class="interactive-title">Cycle Notation Visualizer</div>

                <canvas id="cycle-canvas" width="400" height="300" class="animation-canvas"></canvas>

                <div class="controls">
                    <button id="cycle-gen" class="accent">Generate Random Permutation</button>
                </div>

                <div class="status-display" id="cycle-status">
                    Cycle notation: (1)
                </div>
            </div>
        </section>

        <section id="isomorphisms">
            <h2>Isomorphisms: When Groups Are "The Same"</h2>

            <p>
                Two groups are <strong>isomorphic</strong> if there's a bijection between them
                that preserves the group operation. Isomorphic groups have the same
                structure—they're the same group wearing different masks.
            </p>

            <div class="definition">
                <div class="definition-title">Definition: Isomorphism</div>
                <p>
                    A bijection φ: <span class="math">G</span> → <span class="math">H</span> is an
                    <strong>isomorphism</strong> if φ(<span class="math">g</span><sub>1</sub> ⋆ <span class="math">g</span><sub>2</sub>) =
                    φ(<span class="math">g</span><sub>1</sub>) ∗ φ(<span class="math">g</span><sub>2</sub>) for all
                    <span class="math">g</span><sub>1</sub>, <span class="math">g</span><sub>2</sub> ∈ <span class="math">G</span>.
                </p>
            </div>

            <div class="interactive-container">
                <div class="interactive-title">Isomorphism Visualizer: ℤ/6ℤ ≅ ℤ/2ℤ × ℤ/3ℤ</div>

                <canvas id="iso-canvas" width="600" height="300" class="animation-canvas"></canvas>

                <div class="controls">
                    <button id="iso-highlight" class="accent">Highlight Correspondence</button>
                    <button id="iso-verify">Verify Operation</button>
                </div>

                <div class="status-display" id="iso-status">
                    The Chinese Remainder Theorem gives us: ℤ/6ℤ ≅ ℤ/2ℤ × ℤ/3ℤ
                </div>

                <div class="example" style="margin-top: 1rem;">
                    <strong>The isomorphism:</strong> φ(k) = (k mod 2, k mod 3).
                    For instance: φ(5) = (1, 2), because 5 ≡ 1 (mod 2) and 5 ≡ 2 (mod 3).
                </div>
            </div>
        </section>

        <section id="subgroups">
            <h2>Subgroups: Groups Within Groups</h2>

            <p>
                A <strong>subgroup</strong> is a subset of a group that is itself a group
                under the same operation. Every group has at least two "trivial" subgroups:
                the identity element alone, and the entire group.
            </p>

            <div class="interactive-container">
                <div class="interactive-title">Subgroup Lattice Explorer</div>

                <div class="controls" style="margin-bottom: 1rem;">
                    <div class="control-group">
                        <label>Group:</label>
                        <select id="subgroup-select">
                            <option value="z6">ℤ/6ℤ</option>
                            <option value="z12">ℤ/12ℤ</option>
                            <option value="klein">Klein Four V₄</option>
                            <option value="s3">S₃</option>
                        </select>
                    </div>
                </div>

                <canvas id="subgroup-canvas" width="500" height="400" class="animation-canvas"></canvas>

                <div class="status-display" id="subgroup-status">
                    Click on a subgroup to see its elements
                </div>

                <div class="insight" style="margin-top: 1rem;">
                    <strong>Key fact:</strong> In ℤ/<span class="math">n</span>ℤ, there is exactly one
                    subgroup of order <span class="math">d</span> for each divisor <span class="math">d</span> of
                    <span class="math">n</span>. The subgroup of order <span class="math">d</span> is
                    generated by <span class="math">n</span>/<span class="math">d</span>.
                </div>
            </div>
        </section>

        <section id="lagrange">
            <h2>Lagrange's Theorem: The Fundamental Counting Result</h2>

            <p>
                One of the most important theorems in group theory states that the
                order of any subgroup must divide the order of the group. Even more:
                the group partitions into <strong>cosets</strong> of equal size.
            </p>

            <div class="definition">
                <div class="definition-title">Theorem (Lagrange)</div>
                <p>
                    Let <span class="math">H</span> be a subgroup of a finite group <span class="math">G</span>.
                    Then |<span class="math">H</span>| divides |<span class="math">G</span>|.
                </p>
                <p style="margin-top: 0.5rem;">
                    Moreover, for any <span class="math">g</span> ∈ <span class="math">G</span>,
                    the element <span class="math">g</span><sup>|<span class="math">G</span>|</sup> = <span class="math">e</span>.
                </p>
            </div>

            <div class="interactive-container">
                <div class="interactive-title">Coset Partition Visualizer</div>

                <div class="controls" style="margin-bottom: 1rem;">
                    <div class="control-group">
                        <label>Group:</label>
                        <select id="coset-group">
                            <option value="z6">ℤ/6ℤ</option>
                            <option value="z8">ℤ/8ℤ</option>
                            <option value="z12">ℤ/12ℤ</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Subgroup H:</label>
                        <select id="coset-subgroup"></select>
                    </div>
                </div>

                <div class="coset-container" id="coset-display"></div>

                <div class="status-display" id="coset-status">
                    Select a subgroup to see how it partitions the group into cosets
                </div>
            </div>

            <div class="example">
                <strong>Fermat's Little Theorem as a Corollary:</strong>
                For prime <span class="math">p</span> and <span class="math">a</span> not divisible by
                <span class="math">p</span>, we have <span class="math">a</span><sup><span class="math">p</span>−1</sup> ≡ 1 (mod <span class="math">p</span>).
                This follows from Lagrange's theorem applied to the multiplicative group (ℤ/<span class="math">p</span>ℤ)<sup>×</sup>,
                which has order <span class="math">p</span>−1.
            </div>
        </section>

        <section id="catalog">
            <h2>Catalog: Groups of Small Order</h2>

            <p>
                How many groups are there of each order? Here are all groups up to order 10
                (up to isomorphism). Click on each to explore its structure.
            </p>

            <div class="interactive-container">
                <div class="interactive-title">Group Explorer</div>

                <div id="catalog-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;"></div>

                <div id="catalog-detail" style="display: none;">
                    <h4 id="catalog-name" style="text-align: center; margin-bottom: 1rem;"></h4>
                    <div class="two-column">
                        <div>
                            <strong>Cayley Table:</strong>
                            <div style="overflow-x: auto; margin-top: 0.5rem;">
                                <table class="cayley-table" id="catalog-cayley"></table>
                            </div>
                        </div>
                        <div>
                            <strong>Properties:</strong>
                            <ul id="catalog-props" style="margin-left: 1.5rem; margin-top: 0.5rem;"></ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <div class="footnote">
            <p>
                <strong>Based on:</strong> Chapter 1 of <em>An Infinitely Large Napkin</em> by Evan Chen.
                This interactive exploration was created to make abstract group theory concepts
                tangible through direct manipulation and visualization.
            </p>
            <p style="margin-top: 0.5rem;">
                <strong>Further reading:</strong> The full book covers homomorphisms, quotient groups,
                rings, representation theory, and much more at
                <a href="https://venhance.github.io/napkin/" target="_blank">venhance.github.io/napkin</a>.
            </p>
        </div>
    </div>

    <script>
        // ========================================
        // UTILITY FUNCTIONS
        // ========================================

        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }

        function mod(n, m) {
            return ((n % m) + m) % m;
        }

        function factorial(n) {
            return n <= 1 ? 1 : n * factorial(n - 1);
        }

        function shuffle(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // ========================================
        // GROUP DEFINITIONS
        // ========================================

        const Groups = {
            cyclic(n) {
                const elements = Array.from({length: n}, (_, i) => i);
                const op = (a, b) => mod(a + b, n);
                const identity = 0;
                const inverse = (a) => mod(-a, n);
                const labels = elements.map(e => e.toString());
                return { elements, op, identity, inverse, labels, name: `ℤ/${n}ℤ`, order: n, abelian: true };
            },

            klein() {
                const elements = [0, 1, 2, 3];
                const table = [
                    [0, 1, 2, 3],
                    [1, 0, 3, 2],
                    [2, 3, 0, 1],
                    [3, 2, 1, 0]
                ];
                const op = (a, b) => table[a][b];
                const labels = ['e', 'a', 'b', 'c'];
                return { elements, op, identity: 0, inverse: (a) => a, labels, name: 'V₄ (Klein Four)', order: 4, abelian: true };
            },

            s3() {
                // S3 elements: e, (12), (13), (23), (123), (132)
                // Represented as permutations of [0,1,2]
                const perms = [
                    [0, 1, 2], // e
                    [1, 0, 2], // (01)
                    [2, 1, 0], // (02)
                    [0, 2, 1], // (12)
                    [1, 2, 0], // (012)
                    [2, 0, 1]  // (021)
                ];
                const compose = (p, q) => p.map(i => q[i]);
                const findPerm = (p) => perms.findIndex(q => q.every((v, i) => v === p[i]));
                const elements = [0, 1, 2, 3, 4, 5];
                const op = (a, b) => findPerm(compose(perms[a], perms[b]));
                const labels = ['e', '(01)', '(02)', '(12)', '(012)', '(021)'];
                const inverseMap = [0, 1, 2, 3, 5, 4];
                return { elements, op, identity: 0, inverse: (a) => inverseMap[a], labels, name: 'S₃', order: 6, abelian: false, perms };
            },

            dihedral(n) {
                // Elements: r^0, r^1, ..., r^(n-1), s, sr, sr^2, ..., sr^(n-1)
                const elements = Array.from({length: 2*n}, (_, i) => i);
                const op = (a, b) => {
                    const aRot = a < n ? a : a - n;
                    const aRef = a >= n;
                    const bRot = b < n ? b : b - n;
                    const bRef = b >= n;

                    if (!aRef && !bRef) {
                        return mod(aRot + bRot, n);
                    } else if (!aRef && bRef) {
                        return n + mod(aRot + bRot, n);
                    } else if (aRef && !bRef) {
                        return n + mod(aRot - bRot, n);
                    } else {
                        return mod(aRot - bRot, n);
                    }
                };
                const labels = [];
                for (let i = 0; i < n; i++) {
                    labels.push(i === 0 ? 'e' : (i === 1 ? 'r' : `r${superscript(i)}`));
                }
                for (let i = 0; i < n; i++) {
                    labels.push(i === 0 ? 's' : (i === 1 ? 'sr' : `sr${superscript(i)}`));
                }
                const inverse = (a) => {
                    if (a < n) return mod(-a, n);
                    return a; // reflections are self-inverse
                };
                return { elements, op, identity: 0, inverse, labels, name: `D${2*n}`, order: 2*n, abelian: n <= 2, n };
            }
        };

        function superscript(n) {
            const sups = '⁰¹²³⁴⁵⁶⁷⁸⁹';
            return n.toString().split('').map(d => sups[parseInt(d)]).join('');
        }

        // ========================================
        // CAYLEY TABLE
        // ========================================

        function buildCayleyTable(group, tableEl, onHover) {
            tableEl.innerHTML = '';
            const n = group.elements.length;

            // Header row
            const headerRow = document.createElement('tr');
            headerRow.innerHTML = '<th>⋆</th>';
            group.elements.forEach(e => {
                const th = document.createElement('th');
                th.textContent = group.labels[e];
                headerRow.appendChild(th);
            });
            tableEl.appendChild(headerRow);

            // Data rows
            group.elements.forEach(a => {
                const row = document.createElement('tr');
                const rowHeader = document.createElement('th');
                rowHeader.textContent = group.labels[a];
                row.appendChild(rowHeader);

                group.elements.forEach(b => {
                    const td = document.createElement('td');
                    const result = group.op(a, b);
                    td.textContent = group.labels[result];
                    td.dataset.a = a;
                    td.dataset.b = b;
                    td.dataset.result = result;

                    td.addEventListener('mouseenter', () => {
                        if (onHover) onHover(a, b, result);
                        highlightCayleyCell(tableEl, a, b);
                    });
                    td.addEventListener('mouseleave', () => {
                        clearCayleyHighlight(tableEl);
                    });

                    row.appendChild(td);
                });
                tableEl.appendChild(row);
            });
        }

        function highlightCayleyCell(tableEl, a, b) {
            const rows = tableEl.querySelectorAll('tr');
            rows.forEach((row, i) => {
                if (i === 0) return;
                const cells = row.querySelectorAll('td');
                cells.forEach((cell, j) => {
                    cell.classList.remove('highlight-row', 'highlight-col', 'highlight-result');
                    if (i - 1 === a) cell.classList.add('highlight-row');
                    if (j === b) cell.classList.add('highlight-col');
                    if (i - 1 === a && j === b) cell.classList.add('highlight-result');
                });
            });
        }

        function clearCayleyHighlight(tableEl) {
            tableEl.querySelectorAll('td').forEach(td => {
                td.classList.remove('highlight-row', 'highlight-col', 'highlight-result');
            });
        }

        // Initialize Cayley Table section
        const cayleySelect = document.getElementById('cayley-group-select');
        const cayleyTable = document.getElementById('cayley-table');
        const cayleyStatus = document.getElementById('cayley-status');

        function updateCayleyTable() {
            const val = cayleySelect.value;
            let group;
            switch(val) {
                case 'z4': group = Groups.cyclic(4); break;
                case 'z5': group = Groups.cyclic(5); break;
                case 'z6': group = Groups.cyclic(6); break;
                case 'klein': group = Groups.klein(); break;
                case 's3': group = Groups.s3(); break;
            }
            buildCayleyTable(group, cayleyTable, (a, b, r) => {
                cayleyStatus.innerHTML = `${group.labels[a]} ⋆ ${group.labels[b]} = <strong>${group.labels[r]}</strong>`;
            });
        }

        cayleySelect.addEventListener('change', updateCayleyTable);
        updateCayleyTable();

        // ========================================
        // CYCLIC GROUP VISUALIZER
        // ========================================

        const cyclicCanvas = document.getElementById('cyclic-canvas');
        const cyclicCtx = cyclicCanvas.getContext('2d');
        const cyclicNSlider = document.getElementById('cyclic-n');
        const cyclicNVal = document.getElementById('cyclic-n-val');
        const cyclicStatus = document.getElementById('cyclic-status');
        const cyclicComposition = document.getElementById('cyclic-composition');

        let cyclicState = { n: 6, current: 0, animating: false, targetAngle: 0, currentAngle: 0 };

        function drawCyclicGroup() {
            const { n, current } = cyclicState;
            const w = cyclicCanvas.width;
            const h = cyclicCanvas.height;
            const cx = w / 2;
            const cy = h / 2;
            const radius = Math.min(w, h) * 0.35;

            cyclicCtx.clearRect(0, 0, w, h);

            // Draw circle
            cyclicCtx.beginPath();
            cyclicCtx.arc(cx, cy, radius, 0, Math.PI * 2);
            cyclicCtx.strokeStyle = '#dee2e6';
            cyclicCtx.lineWidth = 2;
            cyclicCtx.stroke();

            // Draw points
            for (let i = 0; i < n; i++) {
                const angle = -Math.PI / 2 + (2 * Math.PI * i) / n;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);

                // Point
                cyclicCtx.beginPath();
                cyclicCtx.arc(x, y, i === current ? 18 : 14, 0, Math.PI * 2);
                cyclicCtx.fillStyle = i === current ? '#e63946' : (i === 0 ? '#457b9d' : '#f8f9fa');
                cyclicCtx.fill();
                cyclicCtx.strokeStyle = i === current ? '#e63946' : '#6c757d';
                cyclicCtx.lineWidth = 2;
                cyclicCtx.stroke();

                // Label
                cyclicCtx.fillStyle = i === current ? 'white' : '#1a1a2e';
                cyclicCtx.font = 'bold 14px sans-serif';
                cyclicCtx.textAlign = 'center';
                cyclicCtx.textBaseline = 'middle';
                cyclicCtx.fillText(i.toString(), x, y);
            }

            // Draw arrow showing direction
            const arrowAngle = -Math.PI / 2 + (2 * Math.PI * current) / n + cyclicState.currentAngle;
            const arrowRadius = radius * 0.6;
            const arrowX = cx + arrowRadius * Math.cos(arrowAngle);
            const arrowY = cy + arrowRadius * Math.sin(arrowAngle);

            cyclicCtx.beginPath();
            cyclicCtx.moveTo(cx, cy);
            cyclicCtx.lineTo(arrowX, arrowY);
            cyclicCtx.strokeStyle = '#e63946';
            cyclicCtx.lineWidth = 3;
            cyclicCtx.stroke();

            // Arrowhead
            const headLen = 12;
            const headAngle = Math.PI / 6;
            cyclicCtx.beginPath();
            cyclicCtx.moveTo(arrowX, arrowY);
            cyclicCtx.lineTo(
                arrowX - headLen * Math.cos(arrowAngle - headAngle),
                arrowY - headLen * Math.sin(arrowAngle - headAngle)
            );
            cyclicCtx.moveTo(arrowX, arrowY);
            cyclicCtx.lineTo(
                arrowX - headLen * Math.cos(arrowAngle + headAngle),
                arrowY - headLen * Math.sin(arrowAngle + headAngle)
            );
            cyclicCtx.stroke();

            // Center label
            cyclicCtx.fillStyle = '#6c757d';
            cyclicCtx.font = '12px sans-serif';
            cyclicCtx.fillText(`ℤ/${n}ℤ`, cx, cy + radius + 30);
        }

        function animateCyclic(delta) {
            const targetAngle = (2 * Math.PI * delta) / cyclicState.n;
            cyclicState.animating = true;
            const startAngle = 0;
            const startTime = performance.now();
            const duration = 300;

            function step(time) {
                const progress = Math.min((time - startTime) / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                cyclicState.currentAngle = startAngle + (targetAngle - startAngle) * eased;
                drawCyclicGroup();

                if (progress < 1) {
                    requestAnimationFrame(step);
                } else {
                    cyclicState.current = mod(cyclicState.current + delta, cyclicState.n);
                    cyclicState.currentAngle = 0;
                    cyclicState.animating = false;
                    updateCyclicStatus();
                    drawCyclicGroup();
                }
            }
            requestAnimationFrame(step);
        }

        function updateCyclicStatus() {
            cyclicStatus.innerHTML = `Current position: <strong>${cyclicState.current}</strong> in ℤ/${cyclicState.n}ℤ`;
        }

        cyclicNSlider.addEventListener('input', () => {
            cyclicState.n = parseInt(cyclicNSlider.value);
            cyclicNVal.textContent = cyclicState.n;
            cyclicState.current = mod(cyclicState.current, cyclicState.n);
            updateCyclicStatus();
            drawCyclicGroup();
        });

        document.getElementById('cyclic-add').addEventListener('click', () => {
            if (!cyclicState.animating) {
                cyclicComposition.style.display = 'flex';
                document.getElementById('cyclic-a').textContent = cyclicState.current;
                document.getElementById('cyclic-b').textContent = '1';
                document.getElementById('cyclic-result').textContent = mod(cyclicState.current + 1, cyclicState.n);
                document.getElementById('cyclic-mod').textContent = cyclicState.n;
                animateCyclic(1);
            }
        });

        document.getElementById('cyclic-sub').addEventListener('click', () => {
            if (!cyclicState.animating) {
                cyclicComposition.style.display = 'flex';
                document.getElementById('cyclic-a').textContent = cyclicState.current;
                document.getElementById('cyclic-b').textContent = '-1';
                document.getElementById('cyclic-result').textContent = mod(cyclicState.current - 1, cyclicState.n);
                document.getElementById('cyclic-mod').textContent = cyclicState.n;
                animateCyclic(-1);
            }
        });

        document.getElementById('cyclic-reset').addEventListener('click', () => {
            cyclicState.current = 0;
            cyclicComposition.style.display = 'none';
            updateCyclicStatus();
            drawCyclicGroup();
        });

        drawCyclicGroup();
        updateCyclicStatus();

        // ========================================
        // ELEMENT ORDERS
        // ========================================

        const orderNSlider = document.getElementById('order-n');
        const orderNVal = document.getElementById('order-n-val');
        const orderDisplay = document.getElementById('order-display');

        function updateOrderDisplay() {
            const n = parseInt(orderNSlider.value);
            orderNVal.textContent = n;

            let html = '<div class="element-buttons">';
            for (let k = 0; k < n; k++) {
                const order = n / gcd(k, n);
                const isGenerator = order === n;
                const color = isGenerator ? '#e63946' : (order === 1 ? '#6c757d' : '#457b9d');
                html += `<div class="element-btn" style="background: ${color}; color: white;" title="Order of ${k} is ${order}">
                    <div style="font-size: 0.7rem;">ord</div>
                    <div>${k}</div>
                    <div style="font-size: 0.8rem;">= ${order}</div>
                </div>`;
            }
            html += '</div>';

            const generators = [];
            for (let k = 0; k < n; k++) {
                if (gcd(k, n) === 1 && k > 0) generators.push(k);
            }

            html += `<p style="text-align: center; margin-top: 1rem; color: var(--muted);">
                <strong style="color: #e63946;">Generators:</strong> ${generators.length > 0 ? generators.join(', ') : 'none (trivial group)'}
                (φ(${n}) = ${generators.length} elements of order ${n})
            </p>`;

            orderDisplay.innerHTML = html;
        }

        orderNSlider.addEventListener('input', updateOrderDisplay);
        updateOrderDisplay();

        // ========================================
        // DIHEDRAL GROUP
        // ========================================

        const dihedralCanvas = document.getElementById('dihedral-canvas');
        const dihedralCtx = dihedralCanvas.getContext('2d');
        const dihedralNSelect = document.getElementById('dihedral-n');
        const dihedralStatus = document.getElementById('dihedral-status');

        let dihedralState = { n: 5, rotation: 0, reflected: false, animating: false };

        function drawPolygon(ctx, cx, cy, radius, n, rotation, reflected, labelVertices = true) {
            const vertices = [];
            for (let i = 0; i < n; i++) {
                let angle = -Math.PI / 2 + (2 * Math.PI * i) / n + rotation;
                let x = cx + radius * Math.cos(angle);
                let y = cy + radius * Math.sin(angle);
                if (reflected) {
                    x = 2 * cx - x;
                }
                vertices.push({ x, y });
            }

            // Fill polygon
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < n; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(69, 123, 157, 0.2)';
            ctx.fill();
            ctx.strokeStyle = '#457b9d';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Draw vertices with labels
            if (labelVertices) {
                vertices.forEach((v, i) => {
                    ctx.beginPath();
                    ctx.arc(v.x, v.y, 16, 0, Math.PI * 2);
                    ctx.fillStyle = i === 0 ? '#e63946' : 'white';
                    ctx.fill();
                    ctx.strokeStyle = '#1a1a2e';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = i === 0 ? 'white' : '#1a1a2e';
                    ctx.font = 'bold 12px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText((i + 1).toString(), v.x, v.y);
                });
            }

            return vertices;
        }

        function drawDihedralGroup() {
            const { n, rotation, reflected } = dihedralState;
            const w = dihedralCanvas.width;
            const h = dihedralCanvas.height;
            const cx = w / 2;
            const cy = h / 2;
            const radius = Math.min(w, h) * 0.35;

            dihedralCtx.clearRect(0, 0, w, h);

            // Draw reflection axis if reflected
            if (reflected) {
                dihedralCtx.save();
                dihedralCtx.setLineDash([5, 5]);
                dihedralCtx.beginPath();
                dihedralCtx.moveTo(cx, cy - radius - 30);
                dihedralCtx.lineTo(cx, cy + radius + 30);
                dihedralCtx.strokeStyle = '#e63946';
                dihedralCtx.lineWidth = 2;
                dihedralCtx.stroke();
                dihedralCtx.restore();
            }

            // Draw polygon
            const angle = (2 * Math.PI * rotation) / n;
            drawPolygon(dihedralCtx, cx, cy, radius, n, angle, reflected);

            // Label
            const rotLabel = rotation === 0 ? '' : (rotation === 1 ? 'r' : `r${superscript(rotation)}`);
            const refLabel = reflected ? 's' : '';
            let label = 'e';
            if (reflected && rotation === 0) label = 's';
            else if (reflected) label = 's' + rotLabel;
            else if (rotation > 0) label = rotLabel;

            dihedralCtx.fillStyle = '#1a1a2e';
            dihedralCtx.font = '16px sans-serif';
            dihedralCtx.textAlign = 'center';
            dihedralCtx.fillText(`Current: ${label}`, cx, h - 20);
        }

        function updateDihedralStatus() {
            const { n, rotation, reflected } = dihedralState;
            const rotLabel = rotation === 0 ? '' : (rotation === 1 ? 'r' : `r${superscript(rotation)}`);
            let label = 'e';
            if (reflected && rotation === 0) label = 's';
            else if (reflected) label = 's' + rotLabel;
            else if (rotation > 0) label = rotLabel;

            dihedralStatus.innerHTML = `Current transformation: <strong>${label}</strong> ${label === 'e' ? '(identity)' : ''}`;
        }

        dihedralNSelect.addEventListener('change', () => {
            dihedralState.n = parseInt(dihedralNSelect.value);
            dihedralState.rotation = 0;
            dihedralState.reflected = false;
            updateDihedralStatus();
            drawDihedralGroup();
        });

        document.getElementById('dihedral-rotate').addEventListener('click', () => {
            dihedralState.rotation = mod(dihedralState.rotation + (dihedralState.reflected ? -1 : 1), dihedralState.n);
            updateDihedralStatus();
            drawDihedralGroup();
        });

        document.getElementById('dihedral-reflect').addEventListener('click', () => {
            dihedralState.reflected = !dihedralState.reflected;
            updateDihedralStatus();
            drawDihedralGroup();
        });

        document.getElementById('dihedral-reset').addEventListener('click', () => {
            dihedralState.rotation = 0;
            dihedralState.reflected = false;
            updateDihedralStatus();
            drawDihedralGroup();
        });

        drawDihedralGroup();
        updateDihedralStatus();

        // ========================================
        // NON-COMMUTATIVITY DEMO
        // ========================================

        const ncLeftCanvas = document.getElementById('noncommute-left');
        const ncRightCanvas = document.getElementById('noncommute-right');
        const ncLeftCtx = ncLeftCanvas.getContext('2d');
        const ncRightCtx = ncRightCanvas.getContext('2d');
        const ncStatus = document.getElementById('noncommute-status');

        let ncState = { phase: 0, animating: false };

        function drawNCPolygon(ctx, rotation, reflected) {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;
            ctx.clearRect(0, 0, w, h);
            drawPolygon(ctx, w/2, h/2, 70, 4, rotation * Math.PI / 2, reflected, true);
        }

        function animateNonCommute() {
            ncState.animating = true;
            let frame = 0;
            const totalFrames = 120;

            function step() {
                frame++;
                const progress = frame / totalFrames;

                // Left: rs (rotate then reflect)
                // Right: sr (reflect then rotate)

                if (progress < 0.4) {
                    // Phase 1: Left rotates, Right reflects
                    const p = progress / 0.4;
                    const eased = 1 - Math.pow(1 - p, 3);
                    drawNCPolygon(ncLeftCtx, eased, false);
                    drawNCPolygon(ncRightCtx, 0, p > 0.5);
                } else if (progress < 0.6) {
                    // Pause
                    drawNCPolygon(ncLeftCtx, 1, false);
                    drawNCPolygon(ncRightCtx, 0, true);
                } else {
                    // Phase 2: Left reflects, Right rotates
                    const p = (progress - 0.6) / 0.4;
                    const eased = 1 - Math.pow(1 - p, 3);
                    drawNCPolygon(ncLeftCtx, 1, p > 0.5);
                    drawNCPolygon(ncRightCtx, eased, true);
                }

                if (frame < totalFrames) {
                    requestAnimationFrame(step);
                } else {
                    ncState.animating = false;
                    ncStatus.innerHTML = '<strong style="color: #e63946;">rs ≠ sr!</strong> The final positions are different.';
                }
            }

            requestAnimationFrame(step);
        }

        document.getElementById('noncommute-play').addEventListener('click', () => {
            if (!ncState.animating) {
                ncStatus.textContent = 'Animating...';
                animateNonCommute();
            }
        });

        document.getElementById('noncommute-reset').addEventListener('click', () => {
            drawNCPolygon(ncLeftCtx, 0, false);
            drawNCPolygon(ncRightCtx, 0, false);
            ncStatus.textContent = 'Click "Play Both" to see why rs ≠ sr';
        });

        drawNCPolygon(ncLeftCtx, 0, false);
        drawNCPolygon(ncRightCtx, 0, false);

        // ========================================
        // PERMUTATION COMPOSER
        // ========================================

        const permN = document.getElementById('perm-n');
        const permSigmaDiv = document.getElementById('perm-sigma');
        const permTauDiv = document.getElementById('perm-tau');
        const permResultDiv = document.getElementById('perm-result');
        const permStatus = document.getElementById('perm-status');

        let permState = {
            n: 4,
            sigma: [0, 1, 2, 3],
            tau: [0, 1, 2, 3]
        };

        function composePerm(p, q) {
            return p.map((_, i) => p[q[i]]);
        }

        function renderPerm(div, perm, editable = false, onchange = null) {
            div.innerHTML = '';
            perm.forEach((val, i) => {
                const box = document.createElement('div');
                box.className = 'perm-box';
                box.innerHTML = `<span>${i + 1}</span><span class="perm-arrow">↓</span><span>${val + 1}</span>`;

                if (editable) {
                    box.style.cursor = 'pointer';
                    box.addEventListener('click', () => {
                        const newVal = (val + 1) % perm.length;
                        perm[i] = newVal;
                        if (onchange) onchange();
                    });
                }

                div.appendChild(box);
            });
        }

        function updatePermutation() {
            const n = permState.n;
            if (permState.sigma.length !== n) {
                permState.sigma = Array.from({length: n}, (_, i) => i);
            }
            if (permState.tau.length !== n) {
                permState.tau = Array.from({length: n}, (_, i) => i);
            }

            const result = composePerm(permState.sigma, permState.tau);

            renderPerm(permSigmaDiv, permState.sigma, true, updatePermutation);
            renderPerm(permTauDiv, permState.tau, true, updatePermutation);
            renderPerm(permResultDiv, result, false);

            // Check if commutative for this example
            const reverse = composePerm(permState.tau, permState.sigma);
            const commutes = result.every((v, i) => v === reverse[i]);
            permStatus.innerHTML = commutes ?
                'These permutations <strong>commute</strong>: σ∘τ = τ∘σ' :
                'These permutations <strong style="color: #e63946;">do not commute</strong>: σ∘τ ≠ τ∘σ';
        }

        permN.addEventListener('change', () => {
            permState.n = parseInt(permN.value);
            updatePermutation();
        });

        document.getElementById('perm-random-sigma').addEventListener('click', () => {
            permState.sigma = shuffle(Array.from({length: permState.n}, (_, i) => i));
            updatePermutation();
        });

        document.getElementById('perm-random-tau').addEventListener('click', () => {
            permState.tau = shuffle(Array.from({length: permState.n}, (_, i) => i));
            updatePermutation();
        });

        document.getElementById('perm-swap').addEventListener('click', () => {
            [permState.sigma, permState.tau] = [permState.tau, permState.sigma];
            updatePermutation();
        });

        updatePermutation();

        // ========================================
        // CYCLE NOTATION VISUALIZER
        // ========================================

        const cycleCanvas = document.getElementById('cycle-canvas');
        const cycleCtx = cycleCanvas.getContext('2d');
        const cycleStatus = document.getElementById('cycle-status');

        let cycleState = { perm: [0, 1, 2, 3, 4] };

        function getCycles(perm) {
            const n = perm.length;
            const visited = new Array(n).fill(false);
            const cycles = [];

            for (let i = 0; i < n; i++) {
                if (visited[i]) continue;
                const cycle = [];
                let j = i;
                while (!visited[j]) {
                    visited[j] = true;
                    cycle.push(j);
                    j = perm[j];
                }
                if (cycle.length > 0) {
                    cycles.push(cycle);
                }
            }
            return cycles;
        }

        function cyclesToString(cycles) {
            if (cycles.every(c => c.length === 1)) return '(identity)';
            return cycles
                .filter(c => c.length > 1)
                .map(c => '(' + c.map(x => x + 1).join(' ') + ')')
                .join('');
        }

        function drawCycles() {
            const w = cycleCanvas.width;
            const h = cycleCanvas.height;
            const n = cycleState.perm.length;

            cycleCtx.clearRect(0, 0, w, h);

            const cycles = getCycles(cycleState.perm);
            const colors = ['#e63946', '#457b9d', '#2a9d8f', '#f4a261', '#9b5de5'];

            // Position elements in a line
            const spacing = w / (n + 1);
            const y = h / 2;

            // Draw arrows for each cycle
            cycles.forEach((cycle, ci) => {
                if (cycle.length <= 1) return;
                const color = colors[ci % colors.length];

                cycleCtx.strokeStyle = color;
                cycleCtx.lineWidth = 2;

                for (let i = 0; i < cycle.length; i++) {
                    const from = cycle[i];
                    const to = cycle[(i + 1) % cycle.length];
                    const x1 = spacing * (from + 1);
                    const x2 = spacing * (to + 1);

                    // Draw curved arrow
                    const midX = (x1 + x2) / 2;
                    const curveHeight = 30 + ci * 20;

                    cycleCtx.beginPath();
                    cycleCtx.moveTo(x1, y - 20);
                    cycleCtx.quadraticCurveTo(midX, y - curveHeight - 20, x2, y - 20);
                    cycleCtx.stroke();

                    // Arrowhead
                    const angle = Math.atan2(-20, x2 > x1 ? 10 : -10);
                    cycleCtx.beginPath();
                    cycleCtx.moveTo(x2, y - 20);
                    cycleCtx.lineTo(x2 - 8 * Math.cos(angle - 0.5), y - 20 - 8 * Math.sin(angle - 0.5));
                    cycleCtx.moveTo(x2, y - 20);
                    cycleCtx.lineTo(x2 - 8 * Math.cos(angle + 0.5), y - 20 - 8 * Math.sin(angle + 0.5));
                    cycleCtx.stroke();
                }
            });

            // Draw elements
            for (let i = 0; i < n; i++) {
                const x = spacing * (i + 1);

                // Find which cycle this element is in
                let cycleIdx = cycles.findIndex(c => c.includes(i));
                const color = cycles[cycleIdx].length > 1 ? colors[cycleIdx % colors.length] : '#6c757d';

                cycleCtx.beginPath();
                cycleCtx.arc(x, y, 20, 0, Math.PI * 2);
                cycleCtx.fillStyle = color;
                cycleCtx.fill();

                cycleCtx.fillStyle = 'white';
                cycleCtx.font = 'bold 16px sans-serif';
                cycleCtx.textAlign = 'center';
                cycleCtx.textBaseline = 'middle';
                cycleCtx.fillText((i + 1).toString(), x, y);

                // Show where it maps to
                cycleCtx.fillStyle = '#6c757d';
                cycleCtx.font = '12px sans-serif';
                cycleCtx.fillText(`→ ${cycleState.perm[i] + 1}`, x, y + 40);
            }

            cycleStatus.innerHTML = `Cycle notation: <strong>${cyclesToString(cycles)}</strong>`;
        }

        document.getElementById('cycle-gen').addEventListener('click', () => {
            cycleState.perm = shuffle(Array.from({length: 5}, (_, i) => i));
            drawCycles();
        });

        drawCycles();

        // ========================================
        // ISOMORPHISM VISUALIZER
        // ========================================

        const isoCanvas = document.getElementById('iso-canvas');
        const isoCtx = isoCanvas.getContext('2d');
        const isoStatus = document.getElementById('iso-status');

        let isoState = { highlighted: -1 };

        function drawIsomorphism() {
            const w = isoCanvas.width;
            const h = isoCanvas.height;

            isoCtx.clearRect(0, 0, w, h);

            // Z/6Z on the left
            const leftX = 120;
            const centerY = h / 2;

            isoCtx.fillStyle = '#1a1a2e';
            isoCtx.font = 'bold 16px sans-serif';
            isoCtx.textAlign = 'center';
            isoCtx.fillText('ℤ/6ℤ', leftX, 30);

            // Z/2Z x Z/3Z on the right
            const rightX = w - 120;
            isoCtx.fillText('ℤ/2ℤ × ℤ/3ℤ', rightX, 30);

            // Draw elements
            const colors = ['#e63946', '#457b9d', '#2a9d8f', '#f4a261', '#9b5de5', '#e9c46a'];

            for (let k = 0; k < 6; k++) {
                const y = 60 + k * 40;
                const isHighlighted = isoState.highlighted === k;

                // Left element
                isoCtx.beginPath();
                isoCtx.arc(leftX, y, 18, 0, Math.PI * 2);
                isoCtx.fillStyle = isHighlighted ? colors[k] : '#f8f9fa';
                isoCtx.fill();
                isoCtx.strokeStyle = colors[k];
                isoCtx.lineWidth = 2;
                isoCtx.stroke();

                isoCtx.fillStyle = isHighlighted ? 'white' : '#1a1a2e';
                isoCtx.font = 'bold 14px sans-serif';
                isoCtx.textAlign = 'center';
                isoCtx.textBaseline = 'middle';
                isoCtx.fillText(k.toString(), leftX, y);

                // Right element (k mod 2, k mod 3)
                const r2 = k % 2;
                const r3 = k % 3;

                isoCtx.beginPath();
                isoCtx.arc(rightX, y, 18, 0, Math.PI * 2);
                isoCtx.fillStyle = isHighlighted ? colors[k] : '#f8f9fa';
                isoCtx.fill();
                isoCtx.strokeStyle = colors[k];
                isoCtx.stroke();

                isoCtx.fillStyle = isHighlighted ? 'white' : '#1a1a2e';
                isoCtx.fillText(`(${r2},${r3})`, rightX, y);

                // Connecting line
                isoCtx.beginPath();
                isoCtx.moveTo(leftX + 25, y);
                isoCtx.lineTo(rightX - 25, y);
                isoCtx.strokeStyle = isHighlighted ? colors[k] : '#dee2e6';
                isoCtx.lineWidth = isHighlighted ? 2 : 1;
                isoCtx.stroke();
            }

            // Draw arrow in middle
            isoCtx.fillStyle = '#6c757d';
            isoCtx.font = '20px sans-serif';
            isoCtx.textAlign = 'center';
            isoCtx.fillText('φ', w/2, centerY - 10);
            isoCtx.font = '16px sans-serif';
            isoCtx.fillText('≅', w/2, centerY + 15);
        }

        isoCanvas.addEventListener('mousemove', (e) => {
            const rect = isoCanvas.getBoundingClientRect();
            const y = e.clientY - rect.top;
            const idx = Math.floor((y - 42) / 40);
            isoState.highlighted = (idx >= 0 && idx < 6) ? idx : -1;
            drawIsomorphism();
        });

        isoCanvas.addEventListener('mouseleave', () => {
            isoState.highlighted = -1;
            drawIsomorphism();
        });

        document.getElementById('iso-highlight').addEventListener('click', () => {
            let i = 0;
            const interval = setInterval(() => {
                isoState.highlighted = i;
                drawIsomorphism();
                i++;
                if (i > 6) {
                    isoState.highlighted = -1;
                    drawIsomorphism();
                    clearInterval(interval);
                }
            }, 400);
        });

        document.getElementById('iso-verify').addEventListener('click', () => {
            const a = Math.floor(Math.random() * 6);
            const b = Math.floor(Math.random() * 6);
            const sum = (a + b) % 6;

            const phiA = [a % 2, a % 3];
            const phiB = [b % 2, b % 3];
            const phiSum = [sum % 2, sum % 3];
            const productPhi = [(phiA[0] + phiB[0]) % 2, (phiA[1] + phiB[1]) % 3];

            isoStatus.innerHTML = `φ(${a} + ${b}) = φ(${sum}) = (${phiSum[0]}, ${phiSum[1]})<br>` +
                `φ(${a}) + φ(${b}) = (${phiA[0]}, ${phiA[1]}) + (${phiB[0]}, ${phiB[1]}) = (${productPhi[0]}, ${productPhi[1]})<br>` +
                `<strong style="color: #2a9d8f;">✓ They match!</strong>`;
        });

        drawIsomorphism();

        // ========================================
        // SUBGROUP LATTICE
        // ========================================

        const subgroupCanvas = document.getElementById('subgroup-canvas');
        const subgroupCtx = subgroupCanvas.getContext('2d');
        const subgroupSelect = document.getElementById('subgroup-select');
        const subgroupStatus = document.getElementById('subgroup-status');

        function getSubgroups(type) {
            switch(type) {
                case 'z6':
                    return {
                        group: Groups.cyclic(6),
                        subgroups: [
                            { elements: [0], label: '{0}', order: 1 },
                            { elements: [0, 2, 4], label: '⟨2⟩', order: 3 },
                            { elements: [0, 3], label: '⟨3⟩', order: 2 },
                            { elements: [0, 1, 2, 3, 4, 5], label: 'ℤ/6ℤ', order: 6 }
                        ],
                        edges: [[0, 1], [0, 2], [1, 3], [2, 3]],
                        positions: [[250, 350], [150, 220], [350, 220], [250, 80]]
                    };
                case 'z12':
                    return {
                        group: Groups.cyclic(12),
                        subgroups: [
                            { elements: [0], label: '{0}', order: 1 },
                            { elements: [0, 6], label: '⟨6⟩', order: 2 },
                            { elements: [0, 4, 8], label: '⟨4⟩', order: 3 },
                            { elements: [0, 3, 6, 9], label: '⟨3⟩', order: 4 },
                            { elements: [0, 2, 4, 6, 8, 10], label: '⟨2⟩', order: 6 },
                            { elements: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], label: 'ℤ/12ℤ', order: 12 }
                        ],
                        edges: [[0,1], [0,2], [1,3], [2,4], [1,4], [3,5], [4,5]],
                        positions: [[250, 380], [150, 280], [350, 280], [100, 180], [250, 180], [250, 60]]
                    };
                case 'klein':
                    return {
                        group: Groups.klein(),
                        subgroups: [
                            { elements: [0], label: '{e}', order: 1 },
                            { elements: [0, 1], label: '⟨a⟩', order: 2 },
                            { elements: [0, 2], label: '⟨b⟩', order: 2 },
                            { elements: [0, 3], label: '⟨c⟩', order: 2 },
                            { elements: [0, 1, 2, 3], label: 'V₄', order: 4 }
                        ],
                        edges: [[0,1], [0,2], [0,3], [1,4], [2,4], [3,4]],
                        positions: [[250, 350], [100, 200], [250, 200], [400, 200], [250, 60]]
                    };
                case 's3':
                    return {
                        group: Groups.s3(),
                        subgroups: [
                            { elements: [0], label: '{e}', order: 1 },
                            { elements: [0, 1], label: '⟨(01)⟩', order: 2 },
                            { elements: [0, 2], label: '⟨(02)⟩', order: 2 },
                            { elements: [0, 3], label: '⟨(12)⟩', order: 2 },
                            { elements: [0, 4, 5], label: 'A₃', order: 3 },
                            { elements: [0, 1, 2, 3, 4, 5], label: 'S₃', order: 6 }
                        ],
                        edges: [[0,1], [0,2], [0,3], [0,4], [1,5], [2,5], [3,5], [4,5]],
                        positions: [[250, 380], [80, 230], [180, 230], [320, 230], [420, 230], [250, 60]]
                    };
            }
        }

        let subgroupData = null;
        let selectedSubgroup = -1;

        function drawSubgroupLattice() {
            const w = subgroupCanvas.width;
            const h = subgroupCanvas.height;

            subgroupCtx.clearRect(0, 0, w, h);

            if (!subgroupData) return;

            const { subgroups, edges, positions, group } = subgroupData;

            // Draw edges
            subgroupCtx.strokeStyle = '#dee2e6';
            subgroupCtx.lineWidth = 2;
            edges.forEach(([i, j]) => {
                subgroupCtx.beginPath();
                subgroupCtx.moveTo(positions[i][0], positions[i][1]);
                subgroupCtx.lineTo(positions[j][0], positions[j][1]);
                subgroupCtx.stroke();
            });

            // Draw nodes
            subgroups.forEach((sg, i) => {
                const [x, y] = positions[i];
                const isSelected = selectedSubgroup === i;

                subgroupCtx.beginPath();
                subgroupCtx.arc(x, y, 30, 0, Math.PI * 2);
                subgroupCtx.fillStyle = isSelected ? '#e63946' : '#457b9d';
                subgroupCtx.fill();

                subgroupCtx.fillStyle = 'white';
                subgroupCtx.font = 'bold 12px sans-serif';
                subgroupCtx.textAlign = 'center';
                subgroupCtx.textBaseline = 'middle';
                subgroupCtx.fillText(sg.label, x, y - 5);
                subgroupCtx.font = '10px sans-serif';
                subgroupCtx.fillText(`|H| = ${sg.order}`, x, y + 10);
            });
        }

        subgroupCanvas.addEventListener('click', (e) => {
            const rect = subgroupCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (!subgroupData) return;

            const { subgroups, positions, group } = subgroupData;

            for (let i = 0; i < subgroups.length; i++) {
                const [px, py] = positions[i];
                if (Math.hypot(x - px, y - py) < 30) {
                    selectedSubgroup = i;
                    const sg = subgroups[i];
                    const elements = sg.elements.map(e => group.labels[e]).join(', ');
                    subgroupStatus.innerHTML = `<strong>${sg.label}</strong>: {${elements}}<br>Order = ${sg.order}, Index = ${group.order / sg.order}`;
                    drawSubgroupLattice();
                    return;
                }
            }
        });

        subgroupSelect.addEventListener('change', () => {
            subgroupData = getSubgroups(subgroupSelect.value);
            selectedSubgroup = -1;
            subgroupStatus.textContent = 'Click on a subgroup to see its elements';
            drawSubgroupLattice();
        });

        subgroupData = getSubgroups('z6');
        drawSubgroupLattice();

        // ========================================
        // COSET VISUALIZER
        // ========================================

        const cosetGroup = document.getElementById('coset-group');
        const cosetSubgroup = document.getElementById('coset-subgroup');
        const cosetDisplay = document.getElementById('coset-display');
        const cosetStatus = document.getElementById('coset-status');

        function getDivisors(n) {
            const divs = [];
            for (let i = 1; i <= n; i++) {
                if (n % i === 0) divs.push(i);
            }
            return divs;
        }

        function updateCosetSubgroups() {
            const val = cosetGroup.value;
            const n = parseInt(val.substring(1));
            const divisors = getDivisors(n);

            cosetSubgroup.innerHTML = '';
            divisors.forEach(d => {
                if (d < n) {
                    const gen = n / d;
                    const opt = document.createElement('option');
                    opt.value = gen;
                    opt.textContent = `⟨${gen}⟩ (order ${d})`;
                    cosetSubgroup.appendChild(opt);
                }
            });

            updateCosets();
        }

        function updateCosets() {
            const val = cosetGroup.value;
            const n = parseInt(val.substring(1));
            const gen = parseInt(cosetSubgroup.value);

            // Generate subgroup
            const H = [];
            for (let i = 0; i < n; i += gen) {
                H.push(i);
            }

            // Generate cosets
            const cosets = [];
            const used = new Set();

            for (let g = 0; g < n; g++) {
                if (used.has(g)) continue;

                const coset = H.map(h => mod(g + h, n)).sort((a, b) => a - b);
                cosets.push({ rep: g, elements: coset });
                coset.forEach(e => used.add(e));
            }

            // Render
            cosetDisplay.innerHTML = '';
            cosets.forEach((coset, i) => {
                const box = document.createElement('div');
                box.className = 'coset-box' + (i === 0 ? ' subgroup' : '');
                box.innerHTML = `
                    <div class="coset-label">${i === 0 ? 'H (subgroup)' : `${coset.rep} + H`}</div>
                    <div class="coset-elements">{${coset.elements.join(', ')}}</div>
                `;
                cosetDisplay.appendChild(box);
            });

            cosetStatus.innerHTML = `|G| = ${n}, |H| = ${H.length}, [G:H] = ${cosets.length}<br>` +
                `<strong>Lagrange:</strong> ${n} = ${H.length} × ${cosets.length} ✓`;
        }

        cosetGroup.addEventListener('change', updateCosetSubgroups);
        cosetSubgroup.addEventListener('change', updateCosets);
        updateCosetSubgroups();

        // ========================================
        // GROUP CATALOG
        // ========================================

        const catalogGroups = [
            { name: 'ℤ/1ℤ', order: 1, type: 'cyclic', n: 1 },
            { name: 'ℤ/2ℤ', order: 2, type: 'cyclic', n: 2 },
            { name: 'ℤ/3ℤ', order: 3, type: 'cyclic', n: 3 },
            { name: 'ℤ/4ℤ', order: 4, type: 'cyclic', n: 4 },
            { name: 'V₄', order: 4, type: 'klein' },
            { name: 'ℤ/5ℤ', order: 5, type: 'cyclic', n: 5 },
            { name: 'ℤ/6ℤ', order: 6, type: 'cyclic', n: 6 },
            { name: 'S₃', order: 6, type: 's3' },
            { name: 'ℤ/7ℤ', order: 7, type: 'cyclic', n: 7 },
            { name: 'ℤ/8ℤ', order: 8, type: 'cyclic', n: 8 },
            { name: 'D₈', order: 8, type: 'dihedral', n: 4 },
        ];

        const catalogGrid = document.getElementById('catalog-grid');
        const catalogDetail = document.getElementById('catalog-detail');
        const catalogName = document.getElementById('catalog-name');
        const catalogCayley = document.getElementById('catalog-cayley');
        const catalogProps = document.getElementById('catalog-props');

        let selectedCatalogGroup = null;

        catalogGroups.forEach((g, idx) => {
            const card = document.createElement('div');
            card.className = 'group-card';
            card.innerHTML = `
                <div class="group-name">${g.name}</div>
                <div class="group-order">Order: ${g.order}</div>
            `;
            card.addEventListener('click', () => {
                document.querySelectorAll('.group-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                showCatalogDetail(g);
            });
            catalogGrid.appendChild(card);
        });

        function showCatalogDetail(g) {
            catalogDetail.style.display = 'block';
            catalogName.textContent = `${g.name} — Order ${g.order}`;

            let group;
            switch(g.type) {
                case 'cyclic': group = Groups.cyclic(g.n); break;
                case 'klein': group = Groups.klein(); break;
                case 's3': group = Groups.s3(); break;
                case 'dihedral': group = Groups.dihedral(g.n); break;
            }

            buildCayleyTable(group, catalogCayley, null);

            // Properties
            const props = [];
            props.push(`<li>Order: ${group.order}</li>`);
            props.push(`<li>${group.abelian ? 'Abelian' : 'Non-abelian'}</li>`);

            if (g.type === 'cyclic') {
                props.push(`<li>Cyclic (generated by 1)</li>`);
                const gens = [];
                for (let k = 1; k < g.n; k++) {
                    if (gcd(k, g.n) === 1) gens.push(k);
                }
                props.push(`<li>Generators: ${gens.join(', ')}</li>`);
            }

            if (g.type === 'klein') {
                props.push(`<li>Every non-identity element has order 2</li>`);
                props.push(`<li>Isomorphic to ℤ/2ℤ × ℤ/2ℤ</li>`);
            }

            if (g.type === 's3') {
                props.push(`<li>Smallest non-abelian group</li>`);
                props.push(`<li>Isomorphic to D₆</li>`);
            }

            if (g.type === 'dihedral') {
                props.push(`<li>Symmetries of a regular ${g.n}-gon</li>`);
                props.push(`<li>${g.n} rotations + ${g.n} reflections</li>`);
            }

            catalogProps.innerHTML = props.join('');
        }
    </script>
</body>
</html>
