<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>More on Groups Explorer | The Napkin</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #0a0b0f;
            --bg-surface: #12141a;
            --bg-elevated: #1a1d26;
            --bg-hover: #242833;
            --border-subtle: #2a2e3a;
            --border-active: #3d4255;
            --text-primary: #e8e9ed;
            --text-secondary: #9499a8;
            --text-muted: #5c6274;
            --accent-gold: #d4a853;
            --accent-gold-dim: #8b7036;
            --accent-cyan: #4ecdc4;
            --accent-cyan-dim: #2a7a74;
            --accent-coral: #ff6b6b;
            --accent-coral-dim: #a34545;
            --accent-violet: #a78bfa;
            --accent-violet-dim: #6b5aa3;
            --accent-lime: #a3e635;
            --accent-emerald: #34d399;
            --accent-rose: #fb7185;
            --grid-line: rgba(255, 255, 255, 0.06);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.03;
            pointer-events: none;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
            z-index: 10000;
        }

        header {
            padding: 2rem 3rem;
            border-bottom: 1px solid var(--border-subtle);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(180deg, var(--bg-surface) 0%, var(--bg-deep) 100%);
        }

        .logo {
            display: flex;
            align-items: baseline;
            gap: 1rem;
        }

        .logo h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.8rem;
            font-weight: 400;
            letter-spacing: -0.02em;
        }

        .logo span {
            font-size: 0.85rem;
            color: var(--text-muted);
            font-weight: 300;
        }

        .part-badge {
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            padding: 0.5rem 1rem;
            border-radius: 2rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        nav {
            display: flex;
            gap: 0.25rem;
            padding: 1rem 3rem;
            background: var(--bg-surface);
            border-bottom: 1px solid var(--border-subtle);
            overflow-x: auto;
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-family: 'Outfit', sans-serif;
            font-size: 0.9rem;
            font-weight: 400;
            cursor: pointer;
            border-radius: 0.5rem;
            transition: all 0.2s ease;
            white-space: nowrap;
            position: relative;
        }

        .tab:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .tab.active {
            background: var(--bg-elevated);
            color: var(--accent-gold);
            font-weight: 500;
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -1rem;
            left: 50%;
            transform: translateX(-50%);
            width: 2rem;
            height: 2px;
            background: var(--accent-gold);
            border-radius: 1px;
        }

        main {
            max-width: 1600px;
            margin: 0 auto;
            padding: 2rem 3rem;
        }

        .section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .section-header {
            margin-bottom: 2rem;
        }

        .section-header h2 {
            font-family: 'Cormorant Garamond', serif;
            font-size: 2.5rem;
            font-weight: 400;
            margin-bottom: 0.5rem;
            letter-spacing: -0.02em;
        }

        .section-header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
            font-weight: 300;
            max-width: 700px;
            line-height: 1.6;
        }

        .canvas-container {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: 1rem;
            overflow: hidden;
            position: relative;
        }

        canvas {
            display: block;
            cursor: pointer;
        }

        .controls {
            display: flex;
            gap: 2rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .control-group {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: 0.75rem;
            padding: 1.25rem;
            min-width: 200px;
        }

        .control-group h4 {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            font-weight: 500;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }

        .control-row:last-child {
            margin-bottom: 0;
        }

        .control-row label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            min-width: 80px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 120px;
            height: 4px;
            background: var(--bg-elevated);
            border-radius: 2px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-gold);
            border-radius: 50%;
            cursor: grab;
            transition: transform 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        input[type="number"], select {
            padding: 0.5rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            border-radius: 0.375rem;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            width: 80px;
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--accent-gold);
        }

        .btn {
            padding: 0.6rem 1.2rem;
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            border-radius: 0.5rem;
            color: var(--text-secondary);
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .btn:hover {
            background: var(--bg-hover);
            border-color: var(--border-active);
            color: var(--text-primary);
        }

        .btn.primary {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: var(--bg-deep);
            font-weight: 500;
        }

        .btn.primary:hover {
            background: #e5b964;
            border-color: #e5b964;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .info-card {
            background: var(--bg-surface);
            border: 1px solid var(--border-subtle);
            border-radius: 0.75rem;
            padding: 1.25rem;
        }

        .info-card h5 {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            font-weight: 500;
        }

        .info-card .value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            color: var(--accent-gold);
        }

        .info-card .value.cyan { color: var(--accent-cyan); }
        .info-card .value.coral { color: var(--accent-coral); }
        .info-card .value.violet { color: var(--accent-violet); }
        .info-card .value.lime { color: var(--accent-lime); }

        .info-card .detail {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.5rem;
            line-height: 1.5;
        }

        .legend {
            display: flex;
            gap: 1.5rem;
            padding: 1rem;
            background: var(--bg-elevated);
            border-radius: 0 0 1rem 1rem;
            border-top: 1px solid var(--border-subtle);
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.gold { background: var(--accent-gold); }
        .legend-dot.cyan { background: var(--accent-cyan); }
        .legend-dot.coral { background: var(--accent-coral); }
        .legend-dot.violet { background: var(--accent-violet); }
        .legend-dot.lime { background: var(--accent-lime); }

        .equation {
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.3rem;
            font-style: italic;
            color: var(--text-primary);
            text-align: center;
            padding: 1rem;
            background: var(--bg-elevated);
            border-radius: 0.5rem;
            margin: 1rem 0;
        }

        .equation .highlight {
            color: var(--accent-gold);
            font-weight: 600;
        }

        .split-layout {
            display: grid;
            grid-template-columns: 1fr 380px;
            gap: 1.5rem;
        }

        @media (max-width: 1100px) {
            .split-layout {
                grid-template-columns: 1fr;
            }
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        /* Color picker for necklaces */
        .color-palette {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .color-swatch {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.15s ease;
        }

        .color-swatch:hover {
            transform: scale(1.1);
        }

        .color-swatch.selected {
            border-color: white;
            box-shadow: 0 0 0 2px var(--bg-deep);
        }

        /* Orbit visualization */
        .orbit-list {
            max-height: 200px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .orbit-item {
            padding: 0.5rem;
            background: var(--bg-elevated);
            border-radius: 0.375rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .orbit-badge {
            background: var(--accent-violet);
            color: var(--bg-deep);
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
        }

        /* Fixed point table */
        .fixpt-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .fixpt-table th, .fixpt-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid var(--border-subtle);
        }

        .fixpt-table th {
            color: var(--text-muted);
            font-weight: 500;
            text-transform: uppercase;
            font-size: 0.7rem;
            letter-spacing: 0.05em;
        }

        /* Sylow constraints */
        .constraint {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-elevated);
            border-radius: 0.375rem;
            margin-bottom: 0.5rem;
        }

        .constraint-check {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .constraint-check.pass {
            background: var(--accent-emerald);
            color: var(--bg-deep);
        }

        .constraint-check.fail {
            background: var(--accent-coral);
            color: var(--bg-deep);
        }

        /* Decomposition display */
        .decomposition {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
        }

        .factor {
            background: var(--accent-violet);
            color: white;
            padding: 0.4rem 0.8rem;
            border-radius: 0.375rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
        }

        .factor-op {
            color: var(--text-muted);
            font-size: 1.2rem;
        }

        /* Checkbox styling */
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
        }

        .checkbox-wrapper input[type="checkbox"] {
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-subtle);
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: all 0.15s ease;
        }

        .checkbox-wrapper input[type="checkbox"]:checked {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
        }

        .checkbox-wrapper input[type="checkbox"]:checked::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--bg-deep);
            font-size: 12px;
            font-weight: bold;
        }

        .checkbox-wrapper span {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        @media (max-width: 768px) {
            header {
                padding: 1.5rem;
                flex-direction: column;
                gap: 1rem;
            }

            nav {
                padding: 1rem;
            }

            main {
                padding: 1.5rem;
            }

            .section-header h2 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">
            <h1>More on Groups</h1>
            <span>An Infinitely Large Napkin</span>
        </div>
        <div class="part-badge">Part V · Chapters 16–18</div>
    </header>

    <nav>
        <button class="tab active" data-section="actions">Group Actions</button>
        <button class="tab" data-section="burnside">Burnside's Lemma</button>
        <button class="tab" data-section="sylow">Sylow Theorems</button>
        <button class="tab" data-section="abelian">Abelian Groups</button>
    </nav>

    <main>
        <!-- Section 1: Group Actions -->
        <section id="actions" class="section active">
            <div class="section-header">
                <h2>Group Actions, Orbits & Stabilizers</h2>
                <p>A group G acts on a set X by sending elements to other elements while respecting the group structure. Click vertices to see how the group action permutes them, creating orbits.</p>
            </div>

            <div class="split-layout">
                <div class="canvas-container">
                    <canvas id="actionsCanvas" width="800" height="550"></canvas>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-dot gold"></div>Selected element</div>
                        <div class="legend-item"><div class="legend-dot cyan"></div>Same orbit</div>
                        <div class="legend-item"><div class="legend-dot violet"></div>Group element applied</div>
                    </div>
                </div>

                <div class="sidebar">
                    <div class="control-group">
                        <h4>Configuration</h4>
                        <div class="control-row">
                            <label>n-gon</label>
                            <input type="number" id="nGon" value="6" min="3" max="12">
                        </div>
                        <div class="control-row">
                            <label>Group</label>
                            <select id="actionGroup">
                                <option value="cyclic">Cyclic Z/nZ</option>
                                <option value="dihedral" selected>Dihedral D₂ₙ</option>
                            </select>
                        </div>
                    </div>

                    <div class="control-group">
                        <h4>Apply Group Element</h4>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button class="btn" id="rotateBtn">Rotate r</button>
                            <button class="btn" id="reflectBtn">Reflect s</button>
                            <button class="btn" id="resetAction">Reset</button>
                        </div>
                        <div class="detail" style="margin-top: 0.75rem; font-size: 0.8rem; color: var(--text-muted);">
                            Current: <span id="currentElement" style="color: var(--accent-gold);">e (identity)</span>
                        </div>
                    </div>

                    <div class="info-card">
                        <h5>Orbit-Stabilizer Theorem</h5>
                        <div class="equation" style="font-size: 1.1rem;">
                            |O| × |Stab<sub>G</sub>(x)| = |G|
                        </div>
                        <div class="detail">The size of an orbit times the size of the stabilizer equals the group order.</div>
                    </div>

                    <div class="info-grid" style="grid-template-columns: 1fr 1fr;">
                        <div class="info-card">
                            <h5>Group Order |G|</h5>
                            <div class="value" id="groupOrder">12</div>
                        </div>
                        <div class="info-card">
                            <h5>Number of Orbits</h5>
                            <div class="value cyan" id="numOrbits">1</div>
                        </div>
                    </div>

                    <div class="control-group">
                        <h4>Orbits on Vertices</h4>
                        <div class="orbit-list" id="orbitList">
                            <!-- Populated by JS -->
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 2: Burnside's Lemma -->
        <section id="burnside" class="section">
            <div class="section-header">
                <h2>Burnside's Lemma</h2>
                <p>Count distinct colorings up to symmetry: the number of orbits equals the average number of fixed points across all group elements. Try coloring the beads and see which colorings are equivalent under rotation.</p>
            </div>

            <div class="split-layout">
                <div class="canvas-container">
                    <canvas id="burnsideCanvas" width="800" height="550"></canvas>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-dot coral"></div>Click beads to change color</div>
                        <div class="legend-item"><div class="legend-dot violet"></div>Equivalent colorings shown</div>
                    </div>
                </div>

                <div class="sidebar">
                    <div class="control-group">
                        <h4>Necklace Setup</h4>
                        <div class="control-row">
                            <label>Beads</label>
                            <input type="number" id="numBeads" value="6" min="3" max="10">
                        </div>
                        <div class="control-row">
                            <label>Colors</label>
                            <input type="number" id="numColors" value="2" min="2" max="5">
                        </div>
                        <div class="control-row">
                            <label>Symmetry</label>
                            <select id="symmetryType">
                                <option value="rotation">Rotations only (necklace)</option>
                                <option value="full">Rotations + reflections (bracelet)</option>
                            </select>
                        </div>
                    </div>

                    <div class="equation">
                        # orbits = <span class="highlight">1/|G|</span> Σ |FixPt(g)|
                    </div>

                    <div class="info-grid" style="grid-template-columns: 1fr 1fr;">
                        <div class="info-card">
                            <h5>Total Colorings</h5>
                            <div class="value" id="totalColorings">64</div>
                            <div class="detail">k<sup>n</sup> without symmetry</div>
                        </div>
                        <div class="info-card">
                            <h5>Distinct (up to symmetry)</h5>
                            <div class="value cyan" id="distinctColorings">14</div>
                            <div class="detail">By Burnside's lemma</div>
                        </div>
                    </div>

                    <div class="control-group">
                        <h4>Fixed Points by Element</h4>
                        <div style="max-height: 180px; overflow-y: auto;">
                            <table class="fixpt-table" id="fixptTable">
                                <thead>
                                    <tr>
                                        <th>Element g</th>
                                        <th>|FixPt(g)|</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <!-- Populated by JS -->
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="control-group">
                        <h4>Current Coloring</h4>
                        <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                            <button class="btn" id="randomColoring">Random</button>
                            <button class="btn" id="clearColoring">Clear</button>
                        </div>
                        <div class="detail" style="margin-top: 0.75rem;">
                            Orbit size: <span id="currentOrbitSize" style="color: var(--accent-gold);">—</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 3: Sylow Theorems -->
        <section id="sylow" class="section">
            <div class="section-header">
                <h2>The Sylow Theorems</h2>
                <p>For a group G of order p<sup>n</sup>m (where gcd(p,m)=1), the number n<sub>p</sub> of Sylow p-subgroups satisfies strong constraints. Enter a group order to explore which Sylow subgroup counts are possible.</p>
            </div>

            <div class="split-layout">
                <div class="canvas-container">
                    <canvas id="sylowCanvas" width="800" height="550"></canvas>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-dot gold"></div>Sylow p-subgroups</div>
                        <div class="legend-item"><div class="legend-dot cyan"></div>Constraints visualization</div>
                    </div>
                </div>

                <div class="sidebar">
                    <div class="control-group">
                        <h4>Group Order</h4>
                        <div class="control-row">
                            <label>|G| =</label>
                            <input type="number" id="groupOrderInput" value="60" min="2" max="1000">
                        </div>
                        <button class="btn primary" id="analyzeSylow" style="margin-top: 0.5rem; width: 100%;">Analyze</button>
                    </div>

                    <div class="info-card">
                        <h5>Factorization</h5>
                        <div class="value" id="factorization" style="font-size: 1.2rem;">60 = 2² · 3 · 5</div>
                    </div>

                    <div class="control-group">
                        <h4>Sylow Theorems</h4>
                        <div class="detail" style="margin-bottom: 0.75rem;">
                            For each prime p dividing |G|:
                        </div>
                        <div class="constraint">
                            <div class="constraint-check pass">1</div>
                            <span>n<sub>p</sub> ≡ 1 (mod p)</span>
                        </div>
                        <div class="constraint">
                            <div class="constraint-check pass">2</div>
                            <span>n<sub>p</sub> divides m = |G|/p<sup>n</sup></span>
                        </div>
                        <div class="constraint">
                            <div class="constraint-check pass">3</div>
                            <span>All Sylow p-subgroups are conjugate</span>
                        </div>
                    </div>

                    <div class="control-group">
                        <h4>Possible n<sub>p</sub> Values</h4>
                        <div id="sylowResults" style="max-height: 200px; overflow-y: auto;">
                            <!-- Populated by JS -->
                        </div>
                    </div>

                    <div class="info-card">
                        <h5>Normal Sylow Subgroup?</h5>
                        <div class="detail" id="normalSylow">
                            A Sylow p-subgroup is normal iff n<sub>p</sub> = 1
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 4: Abelian Groups -->
        <section id="abelian" class="section">
            <div class="section-header">
                <h2>Classification of Finite Abelian Groups</h2>
                <p>Every finitely generated abelian group decomposes uniquely (up to order) as a direct sum of cyclic groups of prime power order. Enter an order to see all possible abelian groups of that size.</p>
            </div>

            <div class="split-layout">
                <div class="canvas-container">
                    <canvas id="abelianCanvas" width="800" height="550"></canvas>
                    <div class="legend">
                        <div class="legend-item"><div class="legend-dot violet"></div>Prime power factors</div>
                        <div class="legend-item"><div class="legend-dot gold"></div>Direct sum structure</div>
                    </div>
                </div>

                <div class="sidebar">
                    <div class="control-group">
                        <h4>Group Order</h4>
                        <div class="control-row">
                            <label>|G| =</label>
                            <input type="number" id="abelianOrder" value="36" min="2" max="500">
                        </div>
                        <button class="btn primary" id="classifyAbelian" style="margin-top: 0.5rem; width: 100%;">Classify</button>
                    </div>

                    <div class="info-card">
                        <h5>Prime Factorization</h5>
                        <div class="value" id="abelianFactor" style="font-size: 1.2rem;">36 = 2² · 3²</div>
                    </div>

                    <div class="equation">
                        G ≅ Z/q₁Z ⊕ Z/q₂Z ⊕ ···
                    </div>

                    <div class="control-group">
                        <h4>All Abelian Groups of Order <span id="orderDisplay">36</span></h4>
                        <div id="abelianList" style="max-height: 250px; overflow-y: auto;">
                            <!-- Populated by JS -->
                        </div>
                    </div>

                    <div class="info-card">
                        <h5>Number of Groups</h5>
                        <div class="value lime" id="numAbelianGroups">4</div>
                        <div class="detail">Non-isomorphic abelian groups of this order</div>
                    </div>

                    <div class="info-card">
                        <h5>Chinese Remainder Theorem</h5>
                        <div class="detail">
                            Z/mnZ ≅ Z/mZ × Z/nZ when gcd(m,n) = 1
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <script>
        // ============================================================
        // Tab Navigation
        // ============================================================

        const tabs = document.querySelectorAll('.tab');
        const sections = document.querySelectorAll('.section');

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const sectionId = tab.dataset.section;
                tabs.forEach(t => t.classList.remove('active'));
                sections.forEach(s => s.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(sectionId).classList.add('active');
            });
        });

        // ============================================================
        // Utility Functions
        // ============================================================

        function gcd(a, b) {
            return b === 0 ? a : gcd(b, a % b);
        }

        function factorize(n) {
            const factors = {};
            let d = 2;
            while (d * d <= n) {
                while (n % d === 0) {
                    factors[d] = (factors[d] || 0) + 1;
                    n /= d;
                }
                d++;
            }
            if (n > 1) factors[n] = (factors[n] || 0) + 1;
            return factors;
        }

        function formatFactorization(n) {
            const factors = factorize(n);
            const parts = [];
            for (const [p, e] of Object.entries(factors).sort((a,b) => a[0] - b[0])) {
                parts.push(e === 1 ? p : `${p}<sup>${e}</sup>`);
            }
            return `${n} = ${parts.join(' · ')}`;
        }

        // ============================================================
        // Section 1: Group Actions
        // ============================================================

        const actionsCanvas = document.getElementById('actionsCanvas');
        const actionsCtx = actionsCanvas.getContext('2d');

        let actionState = {
            n: 6,
            groupType: 'dihedral',
            currentRotation: 0,
            currentReflection: false,
            selectedVertex: null,
            vertices: []
        };

        function computeVertices(n, cx, cy, radius) {
            const vertices = [];
            for (let i = 0; i < n; i++) {
                const angle = -Math.PI/2 + (2 * Math.PI * i) / n;
                vertices.push({
                    x: cx + radius * Math.cos(angle),
                    y: cy + radius * Math.sin(angle),
                    index: i
                });
            }
            return vertices;
        }

        function applyGroupElement(index, rotation, reflection, n) {
            let result = index;
            if (reflection) {
                result = (n - result) % n;
            }
            result = (result + rotation) % n;
            return result;
        }

        function getOrbit(startIndex, n, groupType) {
            const orbit = new Set();
            const maxRotations = n;
            const reflections = groupType === 'dihedral' ? [false, true] : [false];

            for (const refl of reflections) {
                for (let rot = 0; rot < maxRotations; rot++) {
                    orbit.add(applyGroupElement(startIndex, rot, refl, n));
                }
            }
            return Array.from(orbit).sort((a, b) => a - b);
        }

        function drawActions() {
            const ctx = actionsCtx;
            const width = actionsCanvas.width;
            const height = actionsCanvas.height;

            ctx.fillStyle = '#12141a';
            ctx.fillRect(0, 0, width, height);

            const cx = width / 2;
            const cy = height / 2;
            const radius = 180;

            const n = actionState.n;
            actionState.vertices = computeVertices(n, cx, cy, radius);

            // Draw polygon edges
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < n; i++) {
                const v1 = actionState.vertices[i];
                const v2 = actionState.vertices[(i + 1) % n];
                ctx.moveTo(v1.x, v1.y);
                ctx.lineTo(v2.x, v2.y);
            }
            ctx.stroke();

            // Draw center
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.beginPath();
            ctx.arc(cx, cy, 5, 0, Math.PI * 2);
            ctx.fill();

            // Draw reflection axis if applicable
            if (actionState.groupType === 'dihedral' && actionState.currentReflection) {
                ctx.strokeStyle = 'rgba(167, 139, 250, 0.4)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                const angle = -Math.PI/2 + (Math.PI * actionState.currentRotation) / n;
                ctx.beginPath();
                ctx.moveTo(cx - 220 * Math.cos(angle), cy - 220 * Math.sin(angle));
                ctx.lineTo(cx + 220 * Math.cos(angle), cy + 220 * Math.sin(angle));
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Compute orbit of selected vertex
            let orbitIndices = [];
            if (actionState.selectedVertex !== null) {
                orbitIndices = getOrbit(actionState.selectedVertex, n, actionState.groupType);
            }

            // Draw vertices
            for (let i = 0; i < n; i++) {
                const v = actionState.vertices[i];
                const isSelected = i === actionState.selectedVertex;
                const isInOrbit = orbitIndices.includes(i) && !isSelected;

                // Apply current transformation to show where vertex maps
                const mappedIndex = applyGroupElement(i, actionState.currentRotation, actionState.currentReflection, n);

                let color = 'rgba(255, 255, 255, 0.6)';
                if (isSelected) color = '#d4a853';
                else if (isInOrbit) color = '#4ecdc4';

                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(v.x, v.y, isSelected ? 20 : 16, 0, Math.PI * 2);
                ctx.fill();

                // Label
                ctx.fillStyle = isSelected || isInOrbit ? '#0a0b0f' : '#e8e9ed';
                ctx.font = '600 14px "JetBrains Mono", monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(i.toString(), v.x, v.y);

                // Draw arrow showing where this vertex maps to
                if (actionState.currentRotation !== 0 || actionState.currentReflection) {
                    const target = actionState.vertices[mappedIndex];
                    if (mappedIndex !== i) {
                        ctx.strokeStyle = 'rgba(167, 139, 250, 0.5)';
                        ctx.lineWidth = 2;
                        const dx = target.x - v.x;
                        const dy = target.y - v.y;
                        const len = Math.sqrt(dx*dx + dy*dy);
                        const ux = dx/len, uy = dy/len;

                        ctx.beginPath();
                        ctx.moveTo(v.x + ux * 22, v.y + uy * 22);
                        ctx.lineTo(target.x - ux * 22, target.y - uy * 22);
                        ctx.stroke();

                        // Arrowhead
                        const ax = target.x - ux * 22;
                        const ay = target.y - uy * 22;
                        ctx.fillStyle = 'rgba(167, 139, 250, 0.5)';
                        ctx.beginPath();
                        ctx.moveTo(ax, ay);
                        ctx.lineTo(ax - 8*ux + 4*uy, ay - 8*uy - 4*ux);
                        ctx.lineTo(ax - 8*ux - 4*uy, ay - 8*uy + 4*ux);
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }

            // Draw group info
            ctx.font = '500 16px "Outfit", sans-serif';
            ctx.fillStyle = '#9499a8';
            ctx.textAlign = 'left';
            const groupName = actionState.groupType === 'cyclic' ? `Z/${n}Z` : `D₂·${n}`;
            ctx.fillText(`Group: ${groupName}`, 20, 30);

            // Update sidebar info
            const groupOrder = actionState.groupType === 'cyclic' ? n : 2 * n;
            document.getElementById('groupOrder').textContent = groupOrder;

            // For dihedral acting on vertices, there's always 1 orbit (transitive action)
            document.getElementById('numOrbits').textContent = '1';

            // Update orbit list
            updateOrbitList();
        }

        function updateOrbitList() {
            const n = actionState.n;
            const orbitList = document.getElementById('orbitList');

            // For vertices under dihedral/cyclic, all vertices are in one orbit
            orbitList.innerHTML = `
                <div class="orbit-item">
                    <span class="orbit-badge">Orbit 1</span>
                    <span>{${Array.from({length: n}, (_, i) => i).join(', ')}}</span>
                </div>
            `;
        }

        function updateCurrentElement() {
            const n = actionState.n;
            let text = 'e (identity)';
            if (actionState.currentRotation !== 0 || actionState.currentReflection) {
                if (actionState.currentReflection) {
                    text = `sr${actionState.currentRotation > 0 ? '^' + actionState.currentRotation : ''}`;
                } else {
                    text = `r${actionState.currentRotation > 1 ? '^' + actionState.currentRotation : ''}`;
                }
            }
            document.getElementById('currentElement').textContent = text;
        }

        actionsCanvas.addEventListener('click', (e) => {
            const rect = actionsCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            for (const v of actionState.vertices) {
                const dx = x - v.x;
                const dy = y - v.y;
                if (dx*dx + dy*dy < 400) {
                    actionState.selectedVertex = v.index;
                    drawActions();
                    return;
                }
            }
        });

        document.getElementById('nGon').addEventListener('change', (e) => {
            actionState.n = parseInt(e.target.value) || 6;
            actionState.currentRotation = 0;
            actionState.currentReflection = false;
            actionState.selectedVertex = null;
            updateCurrentElement();
            drawActions();
        });

        document.getElementById('actionGroup').addEventListener('change', (e) => {
            actionState.groupType = e.target.value;
            actionState.currentRotation = 0;
            actionState.currentReflection = false;
            updateCurrentElement();
            drawActions();
        });

        document.getElementById('rotateBtn').addEventListener('click', () => {
            actionState.currentRotation = (actionState.currentRotation + 1) % actionState.n;
            updateCurrentElement();
            drawActions();
        });

        document.getElementById('reflectBtn').addEventListener('click', () => {
            if (actionState.groupType === 'dihedral') {
                actionState.currentReflection = !actionState.currentReflection;
                updateCurrentElement();
                drawActions();
            }
        });

        document.getElementById('resetAction').addEventListener('click', () => {
            actionState.currentRotation = 0;
            actionState.currentReflection = false;
            updateCurrentElement();
            drawActions();
        });

        // ============================================================
        // Section 2: Burnside's Lemma
        // ============================================================

        const burnsideCanvas = document.getElementById('burnsideCanvas');
        const burnsideCtx = burnsideCanvas.getContext('2d');

        const BEAD_COLORS = ['#ff6b6b', '#4ecdc4', '#d4a853', '#a78bfa', '#a3e635'];

        let burnsideState = {
            n: 6,
            k: 2,
            symmetry: 'rotation',
            coloring: []
        };

        function initColoring() {
            burnsideState.coloring = new Array(burnsideState.n).fill(0);
        }

        function countFixedPoints(n, k, symmetry) {
            const results = [];

            // Rotations: r^i for i = 0, 1, ..., n-1
            for (let i = 0; i < n; i++) {
                // Number of fixed points under rotation by i: k^gcd(i, n)
                const g = gcd(i, n);
                const fixed = Math.pow(k, g);
                results.push({
                    element: i === 0 ? 'e' : `r${i > 1 ? '^' + i : ''}`,
                    fixed: fixed
                });
            }

            // Reflections (if full symmetry)
            if (symmetry === 'full') {
                for (let i = 0; i < n; i++) {
                    // Reflection through axis at angle πi/n
                    let fixed;
                    if (n % 2 === 0) {
                        // Even n: n/2 reflections through vertices, n/2 through edges
                        if (i < n / 2) {
                            fixed = Math.pow(k, n / 2 + 1); // Through 2 vertices
                        } else {
                            fixed = Math.pow(k, n / 2); // Through 2 edges
                        }
                    } else {
                        // Odd n: all reflections through a vertex and opposite edge midpoint
                        fixed = Math.pow(k, (n + 1) / 2);
                    }
                    results.push({
                        element: `s${i > 0 ? 'r^' + i : ''}`,
                        fixed: fixed
                    });
                }
            }

            return results;
        }

        function computeBurnside(n, k, symmetry) {
            const fixedPoints = countFixedPoints(n, k, symmetry);
            const total = fixedPoints.reduce((sum, fp) => sum + fp.fixed, 0);
            const groupSize = symmetry === 'full' ? 2 * n : n;
            return { orbits: total / groupSize, fixedPoints, groupSize, total };
        }

        function getOrbitOfColoring(coloring, n, symmetry) {
            const orbit = new Set();
            const coloringStr = arr => arr.join(',');
            orbit.add(coloringStr(coloring));

            // Apply all rotations
            for (let r = 1; r < n; r++) {
                const rotated = coloring.map((_, i) => coloring[(i + n - r) % n]);
                orbit.add(coloringStr(rotated));
            }

            // Apply reflections if full symmetry
            if (symmetry === 'full') {
                for (let r = 0; r < n; r++) {
                    const reflected = coloring.map((_, i) => coloring[(n - i) % n]);
                    const rotatedReflected = reflected.map((_, i) => reflected[(i + n - r) % n]);
                    orbit.add(coloringStr(rotatedReflected));
                }
            }

            return orbit.size;
        }

        function drawBurnside() {
            const ctx = burnsideCtx;
            const width = burnsideCanvas.width;
            const height = burnsideCanvas.height;

            ctx.fillStyle = '#12141a';
            ctx.fillRect(0, 0, width, height);

            const n = burnsideState.n;
            const k = burnsideState.k;
            const cx = width / 2;
            const cy = height / 2 - 30;
            const radius = 150;

            // Draw connecting lines (necklace string)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < n; i++) {
                const angle1 = -Math.PI/2 + (2 * Math.PI * i) / n;
                const angle2 = -Math.PI/2 + (2 * Math.PI * (i + 1)) / n;
                const x1 = cx + radius * Math.cos(angle1);
                const y1 = cy + radius * Math.sin(angle1);
                const x2 = cx + radius * Math.cos(angle2);
                const y2 = cy + radius * Math.sin(angle2);
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
            }
            ctx.stroke();

            // Draw beads
            const beadRadius = 25;
            for (let i = 0; i < n; i++) {
                const angle = -Math.PI/2 + (2 * Math.PI * i) / n;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);

                const colorIndex = burnsideState.coloring[i] || 0;
                ctx.fillStyle = BEAD_COLORS[colorIndex];
                ctx.beginPath();
                ctx.arc(x, y, beadRadius, 0, Math.PI * 2);
                ctx.fill();

                // Highlight
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Draw title
            ctx.font = '500 16px "Outfit", sans-serif';
            ctx.fillStyle = '#9499a8';
            ctx.textAlign = 'center';
            ctx.fillText(`${n} beads, ${k} colors`, cx, 30);
            ctx.fillText(`Click beads to change color`, cx, height - 30);

            // Update stats
            const burnside = computeBurnside(n, k, burnsideState.symmetry);
            document.getElementById('totalColorings').textContent = Math.pow(k, n);
            document.getElementById('distinctColorings').textContent = Math.round(burnside.orbits);

            // Update fixed points table
            const tbody = document.querySelector('#fixptTable tbody');
            tbody.innerHTML = burnside.fixedPoints.slice(0, 12).map(fp =>
                `<tr><td>${fp.element}</td><td>${fp.fixed}</td></tr>`
            ).join('');
            if (burnside.fixedPoints.length > 12) {
                tbody.innerHTML += `<tr><td colspan="2" style="color: var(--text-muted);">... and ${burnside.fixedPoints.length - 12} more</td></tr>`;
            }

            // Update orbit size of current coloring
            const orbitSize = getOrbitOfColoring(burnsideState.coloring, n, burnsideState.symmetry);
            document.getElementById('currentOrbitSize').textContent = orbitSize;
        }

        burnsideCanvas.addEventListener('click', (e) => {
            const rect = burnsideCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const n = burnsideState.n;
            const k = burnsideState.k;
            const cx = burnsideCanvas.width / 2;
            const cy = burnsideCanvas.height / 2 - 30;
            const radius = 150;

            for (let i = 0; i < n; i++) {
                const angle = -Math.PI/2 + (2 * Math.PI * i) / n;
                const bx = cx + radius * Math.cos(angle);
                const by = cy + radius * Math.sin(angle);

                const dx = x - bx;
                const dy = y - by;
                if (dx*dx + dy*dy < 625) { // 25^2
                    burnsideState.coloring[i] = (burnsideState.coloring[i] + 1) % k;
                    drawBurnside();
                    return;
                }
            }
        });

        document.getElementById('numBeads').addEventListener('change', (e) => {
            burnsideState.n = parseInt(e.target.value) || 6;
            initColoring();
            drawBurnside();
        });

        document.getElementById('numColors').addEventListener('change', (e) => {
            burnsideState.k = parseInt(e.target.value) || 2;
            burnsideState.coloring = burnsideState.coloring.map(c => c % burnsideState.k);
            drawBurnside();
        });

        document.getElementById('symmetryType').addEventListener('change', (e) => {
            burnsideState.symmetry = e.target.value;
            drawBurnside();
        });

        document.getElementById('randomColoring').addEventListener('click', () => {
            const k = burnsideState.k;
            burnsideState.coloring = burnsideState.coloring.map(() => Math.floor(Math.random() * k));
            drawBurnside();
        });

        document.getElementById('clearColoring').addEventListener('click', () => {
            initColoring();
            drawBurnside();
        });

        // ============================================================
        // Section 3: Sylow Theorems
        // ============================================================

        const sylowCanvas = document.getElementById('sylowCanvas');
        const sylowCtx = sylowCanvas.getContext('2d');

        function computeSylowConstraints(n) {
            const factors = factorize(n);
            const results = [];

            for (const [p, exp] of Object.entries(factors)) {
                const prime = parseInt(p);
                const pPower = Math.pow(prime, exp);
                const m = n / pPower;

                // Find all valid n_p values
                const validNp = [];
                for (let np = 1; np <= m; np++) {
                    if (np % prime === 1 && m % np === 0) {
                        validNp.push(np);
                    }
                }

                results.push({
                    prime,
                    exponent: exp,
                    pPower,
                    m,
                    validNp,
                    hasNormal: validNp.includes(1)
                });
            }

            return results;
        }

        function drawSylow() {
            const ctx = sylowCtx;
            const width = sylowCanvas.width;
            const height = sylowCanvas.height;

            ctx.fillStyle = '#12141a';
            ctx.fillRect(0, 0, width, height);

            const n = parseInt(document.getElementById('groupOrderInput').value) || 60;
            const results = computeSylowConstraints(n);

            // Draw visualization
            const startY = 80;
            const rowHeight = 100;

            ctx.font = '600 24px "Cormorant Garamond", serif';
            ctx.fillStyle = '#e8e9ed';
            ctx.textAlign = 'center';
            ctx.fillText(`Sylow Analysis for |G| = ${n}`, width / 2, 40);

            results.forEach((r, i) => {
                const y = startY + i * rowHeight;
                const cx = width / 2;

                // Prime power box
                ctx.fillStyle = '#a78bfa';
                ctx.beginPath();
                ctx.roundRect(cx - 300, y, 120, 60, 8);
                ctx.fill();

                ctx.fillStyle = '#0a0b0f';
                ctx.font = '600 20px "JetBrains Mono", monospace';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const pText = r.exponent === 1 ? `${r.prime}` : `${r.prime}^${r.exponent}`;
                ctx.fillText(pText, cx - 240, y + 30);

                // Arrow
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx - 170, y + 30);
                ctx.lineTo(cx - 100, y + 30);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx - 100, y + 30);
                ctx.lineTo(cx - 110, y + 25);
                ctx.moveTo(cx - 100, y + 30);
                ctx.lineTo(cx - 110, y + 35);
                ctx.stroke();

                // Valid n_p values
                ctx.fillStyle = '#1a1d26';
                ctx.beginPath();
                ctx.roundRect(cx - 90, y, 380, 60, 8);
                ctx.fill();
                ctx.strokeStyle = '#3d4255';
                ctx.lineWidth = 1;
                ctx.stroke();

                ctx.fillStyle = '#9499a8';
                ctx.font = '400 14px "Outfit", sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`n${r.prime} ∈ {${r.validNp.slice(0, 8).join(', ')}${r.validNp.length > 8 ? ', ...' : ''}}`, cx - 75, y + 25);

                ctx.fillStyle = '#5c6274';
                ctx.font = '400 12px "Outfit", sans-serif';
                ctx.fillText(`n${r.prime} ≡ 1 (mod ${r.prime})  and  n${r.prime} | ${r.m}`, cx - 75, y + 45);

                // Normal indicator
                if (r.hasNormal) {
                    ctx.fillStyle = '#34d399';
                    ctx.beginPath();
                    ctx.arc(cx + 320, y + 30, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Update sidebar
            document.getElementById('factorization').innerHTML = formatFactorization(n);

            const resultsDiv = document.getElementById('sylowResults');
            resultsDiv.innerHTML = results.map(r => `
                <div style="margin-bottom: 1rem;">
                    <div style="color: var(--accent-violet); font-weight: 600; margin-bottom: 0.25rem;">
                        p = ${r.prime}, Sylow ${r.prime}-subgroups of order ${r.pPower}
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem;">
                        n<sub>${r.prime}</sub> ∈ {${r.validNp.join(', ')}}
                    </div>
                    ${r.hasNormal ? '<div style="color: var(--accent-emerald); font-size: 0.8rem; margin-top: 0.25rem;">✓ Normal subgroup possible (n<sub>p</sub>=1)</div>' : ''}
                </div>
            `).join('');

            // Check for guaranteed normal Sylow
            const hasDefiniteNormal = results.some(r => r.validNp.length === 1 && r.validNp[0] === 1);
            document.getElementById('normalSylow').innerHTML = hasDefiniteNormal
                ? '<span style="color: var(--accent-emerald);">✓ Group has a normal Sylow subgroup</span>'
                : 'A Sylow p-subgroup is normal iff n<sub>p</sub> = 1';
        }

        document.getElementById('analyzeSylow').addEventListener('click', drawSylow);
        document.getElementById('groupOrderInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') drawSylow();
        });

        // ============================================================
        // Section 4: Abelian Groups
        // ============================================================

        const abelianCanvas = document.getElementById('abelianCanvas');
        const abelianCtx = abelianCanvas.getContext('2d');

        function partitions(n) {
            const result = [];
            function partition(n, max, current) {
                if (n === 0) {
                    result.push([...current]);
                    return;
                }
                for (let i = Math.min(n, max); i >= 1; i--) {
                    current.push(i);
                    partition(n - i, i, current);
                    current.pop();
                }
            }
            partition(n, n, []);
            return result;
        }

        function classifyAbelianGroups(n) {
            const factors = factorize(n);
            const primePartitions = [];

            for (const [p, exp] of Object.entries(factors)) {
                const prime = parseInt(p);
                const parts = partitions(exp);
                primePartitions.push({
                    prime,
                    partitions: parts.map(part => ({
                        partition: part,
                        factors: part.map(e => Math.pow(prime, e))
                    }))
                });
            }

            // Generate all combinations
            const groups = [];
            function combine(index, current) {
                if (index === primePartitions.length) {
                    const allFactors = current.flat().sort((a, b) => a - b);
                    groups.push(allFactors);
                    return;
                }
                for (const part of primePartitions[index].partitions) {
                    combine(index + 1, [...current, part.factors]);
                }
            }
            combine(0, []);

            return groups;
        }

        function drawAbelian() {
            const ctx = abelianCtx;
            const width = abelianCanvas.width;
            const height = abelianCanvas.height;

            ctx.fillStyle = '#12141a';
            ctx.fillRect(0, 0, width, height);

            const n = parseInt(document.getElementById('abelianOrder').value) || 36;
            const groups = classifyAbelianGroups(n);

            ctx.font = '600 24px "Cormorant Garamond", serif';
            ctx.fillStyle = '#e8e9ed';
            ctx.textAlign = 'center';
            ctx.fillText(`Abelian Groups of Order ${n}`, width / 2, 40);

            // Draw each group
            const startY = 90;
            const rowHeight = 65;
            const maxShow = Math.min(groups.length, 7);

            groups.slice(0, maxShow).forEach((factors, i) => {
                const y = startY + i * rowHeight;

                // Group number
                ctx.fillStyle = '#5c6274';
                ctx.font = '500 14px "JetBrains Mono", monospace';
                ctx.textAlign = 'left';
                ctx.fillText(`#${i + 1}`, 30, y + 25);

                // Draw factors
                let x = 80;
                factors.forEach((f, j) => {
                    // Factor box
                    const text = `Z/${f}Z`;
                    ctx.font = '500 16px "JetBrains Mono", monospace';
                    const textWidth = ctx.measureText(text).width + 20;

                    ctx.fillStyle = '#a78bfa';
                    ctx.beginPath();
                    ctx.roundRect(x, y, textWidth, 40, 6);
                    ctx.fill();

                    ctx.fillStyle = '#0a0b0f';
                    ctx.textAlign = 'center';
                    ctx.fillText(text, x + textWidth/2, y + 25);

                    x += textWidth + 10;

                    // Plus sign
                    if (j < factors.length - 1) {
                        ctx.fillStyle = '#5c6274';
                        ctx.font = '400 20px "Outfit", sans-serif';
                        ctx.fillText('⊕', x, y + 25);
                        x += 30;
                    }
                });

                // Check if cyclic
                const isCyclic = factors.length === 1 || factors.every((f, i) =>
                    factors.slice(i + 1).every(g => gcd(f, g) === 1)
                );
                if (isCyclic) {
                    ctx.fillStyle = '#34d399';
                    ctx.font = '400 12px "Outfit", sans-serif';
                    ctx.textAlign = 'left';
                    ctx.fillText('(cyclic)', x + 20, y + 25);
                }
            });

            if (groups.length > maxShow) {
                ctx.fillStyle = '#5c6274';
                ctx.font = '400 14px "Outfit", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`... and ${groups.length - maxShow} more`, width / 2, startY + maxShow * rowHeight + 20);
            }

            // Update sidebar
            document.getElementById('abelianFactor').innerHTML = formatFactorization(n);
            document.getElementById('orderDisplay').textContent = n;
            document.getElementById('numAbelianGroups').textContent = groups.length;

            const listDiv = document.getElementById('abelianList');
            listDiv.innerHTML = groups.map((factors, i) => {
                const isCyclic = factors.length === 1 || factors.every((f, idx) =>
                    factors.slice(idx + 1).every(g => gcd(f, g) === 1)
                );
                return `
                    <div style="padding: 0.5rem; background: var(--bg-elevated); border-radius: 0.375rem; margin-bottom: 0.5rem;">
                        <span style="color: var(--text-muted); font-size: 0.8rem;">#${i + 1}</span>
                        <span style="color: var(--text-primary); font-family: 'JetBrains Mono', monospace; margin-left: 0.5rem;">
                            ${factors.map(f => `Z/${f}Z`).join(' ⊕ ')}
                        </span>
                        ${isCyclic ? '<span style="color: var(--accent-emerald); font-size: 0.75rem; margin-left: 0.5rem;">(cyclic)</span>' : ''}
                    </div>
                `;
            }).join('');
        }

        document.getElementById('classifyAbelian').addEventListener('click', drawAbelian);
        document.getElementById('abelianOrder').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') drawAbelian();
        });

        // ============================================================
        // Initialize
        // ============================================================

        initColoring();
        drawActions();
        drawBurnside();
        drawSylow();
        drawAbelian();
    </script>
</body>
</html>
