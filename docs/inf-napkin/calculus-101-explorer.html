<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculus 101 Explorer | The Infinitely Large Napkin</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;0,700;1,400&family=Source+Serif+4:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #050a12;
            --bg-primary: #0a0f1c;
            --bg-elevated: #111827;
            --bg-card: #1a2234;
            --accent-gold: #f59e0b;
            --accent-gold-dim: #b45309;
            --accent-cyan: #06b6d4;
            --accent-cyan-dim: #0891b2;
            --converge: #10b981;
            --diverge: #f43f5e;
            --text-primary: #f5f5f4;
            --text-secondary: #a1a1aa;
            --text-dim: #71717a;
            --border: #27303f;
            --font-display: 'Cormorant Garamond', Georgia, serif;
            --font-body: 'Source Serif 4', Georgia, serif;
            --font-mono: 'JetBrains Mono', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: var(--font-body);
            background: var(--bg-deep);
            color: var(--text-primary);
            line-height: 1.7;
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Subtle grid background */
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background-image:
                linear-gradient(rgba(245, 158, 11, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(245, 158, 11, 0.02) 1px, transparent 1px);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 0;
        }

        /* Navigation */
        nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background: linear-gradient(to bottom, var(--bg-deep) 0%, transparent 100%);
            padding: 1.5rem 2rem 3rem;
        }

        .nav-inner {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .nav-brand {
            font-family: var(--font-display);
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--accent-gold);
            text-decoration: none;
            letter-spacing: 0.02em;
        }

        .nav-links {
            display: flex;
            gap: 0.25rem;
            background: var(--bg-card);
            padding: 0.25rem;
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .nav-link {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            color: var(--text-secondary);
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.2s ease;
        }

        .nav-link:hover, .nav-link.active {
            color: var(--text-primary);
            background: var(--bg-elevated);
        }

        /* Hero */
        .hero {
            position: relative;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 6rem 2rem;
        }

        .hero::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 800px;
            background: radial-gradient(ellipse at center, rgba(245, 158, 11, 0.08) 0%, transparent 70%);
            pointer-events: none;
        }

        .hero-part {
            font-family: var(--font-mono);
            font-size: 0.875rem;
            color: var(--accent-gold);
            margin-bottom: 1rem;
            letter-spacing: 0.1em;
            opacity: 0;
            animation: fadeUp 0.8s ease forwards;
        }

        .hero h1 {
            font-family: var(--font-display);
            font-size: clamp(3rem, 8vw, 6rem);
            font-weight: 700;
            line-height: 1.1;
            margin-bottom: 1.5rem;
            opacity: 0;
            animation: fadeUp 0.8s ease 0.1s forwards;
        }

        .hero h1 span {
            display: block;
            font-size: 0.5em;
            font-weight: 400;
            font-style: italic;
            color: var(--text-secondary);
            margin-top: 0.5rem;
        }

        .hero-subtitle {
            font-size: 1.25rem;
            color: var(--text-secondary);
            max-width: 600px;
            margin-bottom: 3rem;
            opacity: 0;
            animation: fadeUp 0.8s ease 0.2s forwards;
        }

        .hero-chapters {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 1rem;
            opacity: 0;
            animation: fadeUp 0.8s ease 0.3s forwards;
        }

        .chapter-pill {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            padding: 0.5rem 1rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 20px;
            color: var(--text-secondary);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .chapter-pill:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
            transform: translateY(-2px);
        }

        @keyframes fadeUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Sections */
        section {
            position: relative;
            padding: 6rem 2rem;
            max-width: 1200px;
            margin: 0 auto;
        }

        .section-header {
            margin-bottom: 3rem;
        }

        .section-number {
            font-family: var(--font-mono);
            font-size: 0.875rem;
            color: var(--accent-gold);
            margin-bottom: 0.5rem;
        }

        .section-title {
            font-family: var(--font-display);
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 600;
            margin-bottom: 1rem;
        }

        .section-desc {
            font-size: 1.125rem;
            color: var(--text-secondary);
            max-width: 700px;
        }

        /* Interactive Cards */
        .interactive-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            transition: border-color 0.3s ease;
        }

        .interactive-card:hover {
            border-color: rgba(245, 158, 11, 0.3);
        }

        .card-title {
            font-family: var(--font-display);
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .card-subtitle {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--accent-gold);
            margin-bottom: 1.5rem;
        }

        /* Canvas containers */
        .canvas-container {
            position: relative;
            background: var(--bg-elevated);
            border-radius: 12px;
            overflow: hidden;
            margin: 1.5rem 0;
        }

        .canvas-container canvas {
            display: block;
            width: 100%;
            height: 400px;
        }

        /* Controls */
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1.5rem;
        }

        .control-group {
            flex: 1;
            min-width: 200px;
        }

        .control-label {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-value {
            color: var(--accent-cyan);
            font-weight: 500;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--bg-deep);
            border-radius: 3px;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--accent-gold);
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        /* Buttons */
        .btn-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .btn {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            padding: 0.6rem 1.2rem;
            background: var(--bg-deep);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            border-color: var(--accent-gold);
            color: var(--accent-gold);
        }

        .btn.active {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: var(--bg-deep);
        }

        .btn-primary {
            background: var(--accent-gold);
            border-color: var(--accent-gold);
            color: var(--bg-deep);
        }

        .btn-primary:hover {
            background: var(--accent-gold-dim);
            border-color: var(--accent-gold-dim);
            color: var(--bg-deep);
        }

        /* Info box */
        .info-box {
            background: rgba(6, 182, 212, 0.1);
            border-left: 3px solid var(--accent-cyan);
            padding: 1rem 1.5rem;
            margin: 1.5rem 0;
            border-radius: 0 8px 8px 0;
        }

        .info-box p {
            font-size: 0.95rem;
            color: var(--text-secondary);
            margin: 0;
        }

        .info-box strong {
            color: var(--accent-cyan);
        }

        /* Math display */
        .math-display {
            font-family: var(--font-mono);
            font-size: 1.1rem;
            color: var(--text-primary);
            background: var(--bg-deep);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            text-align: center;
            margin: 1rem 0;
            overflow-x: auto;
        }

        .math-display .gold { color: var(--accent-gold); }
        .math-display .cyan { color: var(--accent-cyan); }
        .math-display .green { color: var(--converge); }
        .math-display .red { color: var(--diverge); }

        /* Status indicator */
        .status {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            font-family: var(--font-mono);
            font-size: 0.8rem;
            padding: 0.4rem 0.8rem;
            border-radius: 20px;
            margin-top: 1rem;
        }

        .status.converges {
            background: rgba(16, 185, 129, 0.15);
            color: var(--converge);
        }

        .status.diverges {
            background: rgba(244, 63, 94, 0.15);
            color: var(--diverge);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Grid layout for side-by-side */
        .two-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        @media (max-width: 900px) {
            .two-col {
                grid-template-columns: 1fr;
            }
        }

        /* Annotation popup */
        .annotation {
            position: absolute;
            background: var(--bg-card);
            border: 1px solid var(--accent-gold);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            color: var(--text-primary);
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.2s ease;
            max-width: 250px;
            z-index: 10;
        }

        .annotation.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Footer */
        footer {
            text-align: center;
            padding: 4rem 2rem;
            border-top: 1px solid var(--border);
            margin-top: 4rem;
        }

        footer p {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--text-dim);
        }

        footer a {
            color: var(--accent-gold);
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-deep);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-gold-dim);
        }
    </style>
</head>
<body>
    <nav>
        <div class="nav-inner">
            <a href="#" class="nav-brand">∞ Napkin</a>
            <div class="nav-links">
                <a href="#limits" class="nav-link">Limits</a>
                <a href="#series" class="nav-link">Series</a>
                <a href="#differentiation" class="nav-link">Derivatives</a>
                <a href="#taylor" class="nav-link">Taylor</a>
                <a href="#integration" class="nav-link">Integrals</a>
            </div>
        </div>
    </nav>

    <header class="hero">
        <p class="hero-part">PART VIII</p>
        <h1>Calculus 101<span>An Interactive Exploration</span></h1>
        <p class="hero-subtitle">From limits and series through differentiation, Taylor expansions, and Riemann integration—made tangible through direct manipulation.</p>
        <div class="hero-chapters">
            <a href="#limits" class="chapter-pill">§26 Limits & Series</a>
            <a href="#series" class="chapter-pill">§26.4 Infinite Series</a>
            <a href="#differentiation" class="chapter-pill">§28 Differentiation</a>
            <a href="#taylor" class="chapter-pill">§29 Taylor Series</a>
            <a href="#integration" class="chapter-pill">§30 Riemann Integrals</a>
        </div>
    </header>

    <!-- SECTION: Limits -->
    <section id="limits">
        <div class="section-header">
            <p class="section-number">§26.1 – §26.3</p>
            <h2 class="section-title">Limits and Convergence</h2>
            <p class="section-desc">A sequence converges to a limit L if, for any desired precision ε, eventually all terms stay within that precision of L.</p>
        </div>

        <div class="interactive-card">
            <h3 class="card-title">The ε-δ Definition</h3>
            <p class="card-subtitle">Visualizing convergence of aₙ = 1/n → 0</p>

            <div class="canvas-container">
                <canvas id="limitCanvas"></canvas>
                <div class="annotation" id="limitAnnotation"></div>
            </div>

            <div class="math-display">
                For every <span class="gold">ε > 0</span>, there exists <span class="cyan">N</span> such that n ≥ N implies |aₙ - L| < <span class="gold">ε</span>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label class="control-label">
                        <span>Epsilon (ε)</span>
                        <span class="control-value" id="epsilonValue">0.20</span>
                    </label>
                    <input type="range" id="epsilonSlider" min="0.02" max="0.5" step="0.01" value="0.2">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        <span>Animation Speed</span>
                        <span class="control-value" id="speedValue">1.0x</span>
                    </label>
                    <input type="range" id="speedSlider" min="0.5" max="3" step="0.1" value="1">
                </div>
            </div>

            <div class="info-box">
                <p><strong>Observe:</strong> The yellow band shows the ε-neighborhood around the limit L = 0. Once n exceeds N = ⌈1/ε⌉, all subsequent terms (shown in green) lie within the band.</p>
            </div>
        </div>

        <div class="interactive-card">
            <h3 class="card-title">Supremum and Infimum</h3>
            <p class="card-subtitle">sup S is the smallest upper bound</p>

            <div class="canvas-container">
                <canvas id="supInfCanvas"></canvas>
            </div>

            <div class="math-display">
                S = (0, 1) → <span class="cyan">inf S = 0</span>, <span class="gold">sup S = 1</span>
            </div>

            <div class="controls">
                <div class="control-group">
                    <div class="btn-group">
                        <button class="btn active" data-set="open">S = (0, 1)</button>
                        <button class="btn" data-set="closed">S = [0, 1]</button>
                        <button class="btn" data-set="discrete">S = {1/n}</button>
                    </div>
                </div>
            </div>

            <div class="info-box">
                <p><strong>Key insight:</strong> For the open interval (0,1), neither 0 nor 1 belongs to S, yet sup S = 1. The supremum need not be an element of the set!</p>
            </div>
        </div>
    </section>

    <!-- SECTION: Series -->
    <section id="series">
        <div class="section-header">
            <p class="section-number">§26.4 – §26.5</p>
            <h2 class="section-title">Infinite Series</h2>
            <p class="section-desc">An infinite sum Σaₙ converges if its sequence of partial sums converges. The limit of partial sums—not infinite addition—is what we mean.</p>
        </div>

        <div class="two-col">
            <div class="interactive-card">
                <h3 class="card-title">Geometric Series</h3>
                <p class="card-subtitle">Σrⁿ = 1/(1-r) for |r| < 1</p>

                <div class="canvas-container">
                    <canvas id="geometricCanvas"></canvas>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <label class="control-label">
                            <span>Ratio r</span>
                            <span class="control-value" id="ratioValue">0.50</span>
                        </label>
                        <input type="range" id="ratioSlider" min="-0.95" max="0.95" step="0.01" value="0.5">
                    </div>
                    <div class="control-group">
                        <label class="control-label">
                            <span>Terms shown</span>
                            <span class="control-value" id="termsValue">15</span>
                        </label>
                        <input type="range" id="termsSlider" min="3" max="50" step="1" value="15">
                    </div>
                </div>

                <div class="math-display" id="geometricFormula">
                    sₙ = 1 + r + r² + ... = <span class="green">2.0000</span>
                </div>

                <div class="status converges" id="geometricStatus">
                    <span class="status-dot"></span>
                    Converges to 1/(1-r)
                </div>
            </div>

            <div class="interactive-card">
                <h3 class="card-title">Harmonic Series</h3>
                <p class="card-subtitle">Σ(1/n) = ∞ (diverges!)</p>

                <div class="canvas-container">
                    <canvas id="harmonicCanvas"></canvas>
                </div>

                <div class="controls">
                    <div class="control-group">
                        <label class="control-label">
                            <span>Terms computed</span>
                            <span class="control-value" id="harmonicTermsValue">100</span>
                        </label>
                        <input type="range" id="harmonicTermsSlider" min="10" max="1000" step="10" value="100">
                    </div>
                </div>

                <div class="math-display" id="harmonicFormula">
                    Hₙ = 1 + 1/2 + 1/3 + ... + 1/n ≈ <span class="red">5.187</span>
                </div>

                <div class="status diverges">
                    <span class="status-dot"></span>
                    Diverges (grows without bound)
                </div>
            </div>
        </div>

        <div class="interactive-card">
            <h3 class="card-title">Telescoping Series</h3>
            <p class="card-subtitle">Σ 1/(k(k+1)) = 1</p>

            <div class="canvas-container">
                <canvas id="telescopingCanvas"></canvas>
            </div>

            <div class="math-display">
                <span class="cyan">1/(k(k+1))</span> = <span class="gold">1/k</span> - <span class="gold">1/(k+1)</span> → Partial sum = 1 - 1/(n+1) → <span class="green">1</span>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label class="control-label">
                        <span>Terms</span>
                        <span class="control-value" id="telescopeTermsValue">10</span>
                    </label>
                    <input type="range" id="telescopeTermsSlider" min="2" max="30" step="1" value="10">
                </div>
            </div>
        </div>
    </section>

    <!-- SECTION: Differentiation -->
    <section id="differentiation">
        <div class="section-header">
            <p class="section-number">§28</p>
            <h2 class="section-title">Differentiation</h2>
            <p class="section-desc">The derivative f'(p) is the limit of the difference quotient as h→0—geometrically, the slope of the tangent line at p.</p>
        </div>

        <div class="interactive-card">
            <h3 class="card-title">Secant to Tangent</h3>
            <p class="card-subtitle">Watch the secant line become tangent as h → 0</p>

            <div class="canvas-container">
                <canvas id="derivativeCanvas"></canvas>
            </div>

            <div class="math-display">
                f'(p) = lim<sub>h→0</sub> <span class="cyan">[f(p+h) - f(p)]</span> / <span class="gold">h</span>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label class="control-label">
                        <span>h (step size)</span>
                        <span class="control-value" id="hValue">1.00</span>
                    </label>
                    <input type="range" id="hSlider" min="0.01" max="2" step="0.01" value="1">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        <span>Point p</span>
                        <span class="control-value" id="pValue">1.00</span>
                    </label>
                    <input type="range" id="pSlider" min="-1.5" max="2" step="0.05" value="1">
                </div>
            </div>

            <div class="btn-group" style="margin-top: 1rem;">
                <button class="btn active" data-func="cubic">f(x) = x³</button>
                <button class="btn" data-func="sin">f(x) = sin(x)</button>
                <button class="btn" data-func="exp">f(x) = eˣ</button>
                <button class="btn" data-func="log">f(x) = ln(x+2)</button>
            </div>

            <div class="info-box">
                <p><strong>Drag h toward 0</strong> to see the secant line (green) approach the tangent line (gold). The slope of the secant is the difference quotient; its limit is the derivative.</p>
            </div>
        </div>

        <div class="interactive-card">
            <h3 class="card-title">Mean Value Theorem</h3>
            <p class="card-subtitle">There exists c ∈ (a,b) where f'(c) equals the average rate of change</p>

            <div class="canvas-container">
                <canvas id="mvtCanvas"></canvas>
            </div>

            <div class="math-display">
                f'(<span class="cyan">c</span>) = [f(b) - f(a)] / (b - a) = <span class="gold">slope of secant</span>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label class="control-label">
                        <span>Point a</span>
                        <span class="control-value" id="aValue">-1.00</span>
                    </label>
                    <input type="range" id="aSlider" min="-2" max="1" step="0.1" value="-1">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        <span>Point b</span>
                        <span class="control-value" id="bValue">2.00</span>
                    </label>
                    <input type="range" id="bSlider" min="0" max="3" step="0.1" value="2">
                </div>
            </div>
        </div>
    </section>

    <!-- SECTION: Taylor Series -->
    <section id="taylor">
        <div class="section-header">
            <p class="section-number">§29</p>
            <h2 class="section-title">Power Series & Taylor Series</h2>
            <p class="section-desc">Many functions can be expressed as "infinite polynomials." The Taylor series at p is Σ f⁽ⁿ⁾(p)/n! · (x-p)ⁿ.</p>
        </div>

        <div class="interactive-card">
            <h3 class="card-title">Taylor Approximations</h3>
            <p class="card-subtitle">Watch polynomials converge to the target function</p>

            <div class="canvas-container">
                <canvas id="taylorCanvas"></canvas>
            </div>

            <div class="math-display" id="taylorFormula">
                eˣ = 1 + x + x²/2! + x³/3! + ...
            </div>

            <div class="controls">
                <div class="control-group">
                    <label class="control-label">
                        <span>Polynomial Degree</span>
                        <span class="control-value" id="degreeValue">3</span>
                    </label>
                    <input type="range" id="degreeSlider" min="0" max="15" step="1" value="3">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        <span>Expansion Point</span>
                        <span class="control-value" id="centerValue">0.00</span>
                    </label>
                    <input type="range" id="centerSlider" min="-2" max="2" step="0.1" value="0">
                </div>
            </div>

            <div class="btn-group" style="margin-top: 1rem;">
                <button class="btn active" data-taylor="exp">eˣ</button>
                <button class="btn" data-taylor="sin">sin(x)</button>
                <button class="btn" data-taylor="cos">cos(x)</button>
                <button class="btn" data-taylor="log">ln(1+x)</button>
                <button class="btn" data-taylor="geometric">1/(1-x)</button>
            </div>

            <div class="info-box">
                <p><strong>Increase the degree</strong> to add more terms. Notice how the approximation improves near the expansion point but may diverge farther away (radius of convergence).</p>
            </div>
        </div>

        <div class="interactive-card">
            <h3 class="card-title">Radius of Convergence</h3>
            <p class="card-subtitle">The series converges for |x - center| < R</p>

            <div class="canvas-container">
                <canvas id="radiusCanvas"></canvas>
            </div>

            <div class="math-display">
                1/(1-x) = Σxⁿ converges for <span class="green">|x| < 1</span>, diverges for <span class="red">|x| ≥ 1</span>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label class="control-label">
                        <span>Evaluate at x</span>
                        <span class="control-value" id="evalXValue">0.50</span>
                    </label>
                    <input type="range" id="evalXSlider" min="-1.5" max="1.5" step="0.05" value="0.5">
                </div>
            </div>
        </div>
    </section>

    <!-- SECTION: Integration -->
    <section id="integration">
        <div class="section-header">
            <p class="section-number">§30</p>
            <h2 class="section-title">Riemann Integrals</h2>
            <p class="section-desc">The integral is defined as the limit of rectangular approximations as the mesh width approaches zero.</p>
        </div>

        <div class="interactive-card">
            <h3 class="card-title">Riemann Sums</h3>
            <p class="card-subtitle">Approximate area with rectangles</p>

            <div class="canvas-container">
                <canvas id="integralCanvas"></canvas>
            </div>

            <div class="math-display">
                ∫<sub>a</sub><sup>b</sup> f(x)dx = lim<sub>mesh→0</sub> Σf(ξᵢ)(tᵢ - tᵢ₋₁) ≈ <span class="green" id="integralApprox">2.000</span>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label class="control-label">
                        <span>Number of Rectangles</span>
                        <span class="control-value" id="rectsValue">10</span>
                    </label>
                    <input type="range" id="rectsSlider" min="1" max="100" step="1" value="10">
                </div>
            </div>

            <div class="btn-group" style="margin-top: 1rem;">
                <button class="btn active" data-sum="left">Left Riemann</button>
                <button class="btn" data-sum="right">Right Riemann</button>
                <button class="btn" data-sum="mid">Midpoint</button>
                <button class="btn" data-sum="trap">Trapezoidal</button>
            </div>

            <div class="btn-group" style="margin-top: 0.5rem;">
                <button class="btn active" data-intfunc="parabola">f(x) = x²</button>
                <button class="btn" data-intfunc="sine">f(x) = sin(x)</button>
                <button class="btn" data-intfunc="cubic">f(x) = x³</button>
            </div>
        </div>

        <div class="interactive-card">
            <h3 class="card-title">Fundamental Theorem of Calculus</h3>
            <p class="card-subtitle">∫ₐᵇ f'(x)dx = f(b) - f(a)</p>

            <div class="canvas-container">
                <canvas id="ftcCanvas"></canvas>
            </div>

            <div class="math-display">
                Area under <span class="cyan">f'(x) = 2x</span> from a to b = <span class="gold">f(b) - f(a)</span> = <span class="green" id="ftcResult">b² - a²</span>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label class="control-label">
                        <span>Upper bound b</span>
                        <span class="control-value" id="ftcBValue">2.00</span>
                    </label>
                    <input type="range" id="ftcBSlider" min="0.5" max="3" step="0.1" value="2">
                </div>
            </div>

            <div class="info-box">
                <p><strong>The FTC connects</strong> differentiation and integration: the integral of the derivative recovers the net change in the original function.</p>
            </div>
        </div>
    </section>

    <footer>
        <p>Based on <a href="https://venhance.github.io/napkin/" target="_blank">An Infinitely Large Napkin</a> by Evan Chen</p>
        <p style="margin-top: 0.5rem;">Interactive exploration for Part VIII: Calculus 101</p>
    </footer>

    <script>
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        const colors = {
            gold: '#f59e0b',
            goldDim: '#b45309',
            cyan: '#06b6d4',
            cyanDim: '#0891b2',
            green: '#10b981',
            red: '#f43f5e',
            text: '#f5f5f4',
            textDim: '#71717a',
            grid: 'rgba(245, 158, 11, 0.1)',
            bg: '#111827'
        };

        function setupCanvas(canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            const ctx = canvas.getContext('2d');
            ctx.scale(dpr, dpr);
            return { ctx, width: rect.width, height: rect.height };
        }

        function drawGrid(ctx, width, height, originX, originY, scaleX, scaleY) {
            ctx.strokeStyle = colors.grid;
            ctx.lineWidth = 1;

            // Vertical lines
            for (let x = originX % (scaleX); x < width; x += scaleX) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            // Horizontal lines
            for (let y = originY % scaleY; y < height; y += scaleY) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
        }

        function drawAxes(ctx, width, height, originX, originY) {
            ctx.strokeStyle = colors.textDim;
            ctx.lineWidth = 1.5;

            // X axis
            ctx.beginPath();
            ctx.moveTo(0, originY);
            ctx.lineTo(width, originY);
            ctx.stroke();

            // Y axis
            ctx.beginPath();
            ctx.moveTo(originX, 0);
            ctx.lineTo(originX, height);
            ctx.stroke();
        }

        // ============================================
        // LIMIT VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('limitCanvas');
            const epsilonSlider = document.getElementById('epsilonSlider');
            const epsilonValue = document.getElementById('epsilonValue');
            const speedSlider = document.getElementById('speedSlider');
            const speedValue = document.getElementById('speedValue');

            let epsilon = 0.2;
            let speed = 1;
            let animationTime = 0;

            function draw() {
                const { ctx, width, height } = setupCanvas(canvas);
                const originY = height * 0.5;
                const originX = 60;
                const scaleX = (width - 80) / 25;
                const scaleY = height * 0.35;

                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, width, height);

                drawGrid(ctx, width, height, originX, originY, scaleX, scaleY * 0.5);
                drawAxes(ctx, width, height, originX, originY);

                // Epsilon band
                ctx.fillStyle = 'rgba(245, 158, 11, 0.15)';
                ctx.fillRect(originX, originY - epsilon * scaleY, width - originX, epsilon * 2 * scaleY);

                ctx.strokeStyle = colors.gold;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(originX, originY - epsilon * scaleY);
                ctx.lineTo(width, originY - epsilon * scaleY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(originX, originY + epsilon * scaleY);
                ctx.lineTo(width, originY + epsilon * scaleY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Label epsilon
                ctx.fillStyle = colors.gold;
                ctx.font = '12px JetBrains Mono';
                ctx.fillText(`+ε`, 30, originY - epsilon * scaleY + 4);
                ctx.fillText(`-ε`, 30, originY + epsilon * scaleY + 4);

                // Limit line (L = 0)
                ctx.strokeStyle = colors.cyan;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(originX, originY);
                ctx.lineTo(width, originY);
                ctx.stroke();

                ctx.fillStyle = colors.cyan;
                ctx.fillText('L = 0', 30, originY + 4);

                // Calculate N = ceil(1/epsilon)
                const N = Math.ceil(1 / epsilon);

                // Draw N marker
                ctx.strokeStyle = colors.cyan;
                ctx.lineWidth = 2;
                ctx.setLineDash([3, 3]);
                const nX = originX + N * scaleX;
                ctx.beginPath();
                ctx.moveTo(nX, 0);
                ctx.lineTo(nX, height);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = colors.cyan;
                ctx.fillText(`N = ${N}`, nX + 5, 20);

                // Draw sequence points aₙ = 1/n
                const numPoints = 25;
                const showUpTo = Math.min(numPoints, Math.floor(animationTime * speed) + 1);

                for (let n = 1; n <= showUpTo; n++) {
                    const x = originX + n * scaleX;
                    const y = originY - (1 / n) * scaleY;

                    const inBand = n >= N;
                    ctx.fillStyle = inBand ? colors.green : colors.red;

                    ctx.beginPath();
                    ctx.arc(x, y, inBand ? 6 : 5, 0, Math.PI * 2);
                    ctx.fill();

                    // Small label
                    if (n <= 6 || n === N || n === showUpTo) {
                        ctx.fillStyle = colors.textDim;
                        ctx.font = '10px JetBrains Mono';
                        ctx.fillText(`a${n}`, x - 8, y - 12);
                    }
                }

                // X axis labels
                ctx.fillStyle = colors.textDim;
                ctx.font = '10px JetBrains Mono';
                for (let i = 5; i <= 25; i += 5) {
                    ctx.fillText(i.toString(), originX + i * scaleX - 5, originY + 20);
                }
                ctx.fillText('n', width - 20, originY + 20);

                animationTime += 0.05;
                requestAnimationFrame(draw);
            }

            epsilonSlider.addEventListener('input', (e) => {
                epsilon = parseFloat(e.target.value);
                epsilonValue.textContent = epsilon.toFixed(2);
                animationTime = 0;
            });

            speedSlider.addEventListener('input', (e) => {
                speed = parseFloat(e.target.value);
                speedValue.textContent = speed.toFixed(1) + 'x';
            });

            draw();
        })();

        // ============================================
        // SUP/INF VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('supInfCanvas');
            const buttons = document.querySelectorAll('[data-set]');
            let currentSet = 'open';

            function draw() {
                const { ctx, width, height } = setupCanvas(canvas);
                const originY = height * 0.5;
                const originX = 80;
                const scale = (width - 160) / 2;

                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, width, height);

                // Number line
                ctx.strokeStyle = colors.textDim;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(40, originY);
                ctx.lineTo(width - 40, originY);
                ctx.stroke();

                // Tick marks
                ctx.fillStyle = colors.textDim;
                ctx.font = '12px JetBrains Mono';
                for (let i = -1; i <= 2; i++) {
                    const x = originX + i * scale;
                    ctx.beginPath();
                    ctx.moveTo(x, originY - 8);
                    ctx.lineTo(x, originY + 8);
                    ctx.stroke();
                    ctx.fillText(i.toString(), x - 4, originY + 25);
                }

                // Draw set
                const x0 = originX;
                const x1 = originX + scale;

                if (currentSet === 'open' || currentSet === 'closed') {
                    // Draw interval
                    ctx.strokeStyle = colors.cyan;
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(x0 + 10, originY);
                    ctx.lineTo(x1 - 10, originY);
                    ctx.stroke();

                    // Endpoints
                    const openLeft = currentSet === 'open';
                    const openRight = currentSet === 'open';

                    // Left endpoint
                    ctx.beginPath();
                    ctx.arc(x0, originY, 8, 0, Math.PI * 2);
                    if (openLeft) {
                        ctx.strokeStyle = colors.cyan;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = colors.cyan;
                        ctx.fill();
                    }

                    // Right endpoint
                    ctx.beginPath();
                    ctx.arc(x1, originY, 8, 0, Math.PI * 2);
                    if (openRight) {
                        ctx.strokeStyle = colors.cyan;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = colors.cyan;
                        ctx.fill();
                    }
                } else if (currentSet === 'discrete') {
                    // Draw 1/n points
                    for (let n = 1; n <= 20; n++) {
                        const x = originX + (1/n) * scale;
                        ctx.fillStyle = colors.cyan;
                        ctx.beginPath();
                        ctx.arc(x, originY, n === 1 ? 6 : 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                // Inf marker
                ctx.fillStyle = colors.cyan;
                ctx.font = '14px JetBrains Mono';
                ctx.fillText('inf S = 0', x0 - 20, originY - 40);
                ctx.beginPath();
                ctx.moveTo(x0, originY - 20);
                ctx.lineTo(x0, originY - 35);
                ctx.strokeStyle = colors.cyan;
                ctx.lineWidth = 1;
                ctx.stroke();

                // Sup marker
                ctx.fillStyle = colors.gold;
                ctx.fillText('sup S = 1', x1 - 20, originY - 40);
                ctx.beginPath();
                ctx.moveTo(x1, originY - 20);
                ctx.lineTo(x1, originY - 35);
                ctx.strokeStyle = colors.gold;
                ctx.lineWidth = 1;
                ctx.stroke();

                // Set label
                ctx.fillStyle = colors.text;
                ctx.font = '16px Source Serif 4';
                const setLabel = currentSet === 'open' ? 'S = (0, 1)' :
                                currentSet === 'closed' ? 'S = [0, 1]' : 'S = {1/n : n ∈ ℕ}';
                ctx.fillText(setLabel, width/2 - 50, originY + 60);
            }

            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    buttons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentSet = btn.dataset.set;
                    draw();
                });
            });

            draw();
            window.addEventListener('resize', draw);
        })();

        // ============================================
        // GEOMETRIC SERIES
        // ============================================
        (function() {
            const canvas = document.getElementById('geometricCanvas');
            const ratioSlider = document.getElementById('ratioSlider');
            const ratioValue = document.getElementById('ratioValue');
            const termsSlider = document.getElementById('termsSlider');
            const termsValue = document.getElementById('termsValue');
            const formula = document.getElementById('geometricFormula');
            const status = document.getElementById('geometricStatus');

            let r = 0.5;
            let terms = 15;

            function draw() {
                const { ctx, width, height } = setupCanvas(canvas);
                const margin = 50;
                const graphWidth = width - 2 * margin;
                const graphHeight = height - 2 * margin;

                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, width, height);

                // Calculate partial sums
                const sums = [1];
                let sum = 1;
                for (let i = 1; i < terms; i++) {
                    sum += Math.pow(r, i);
                    sums.push(sum);
                }

                // Find scale
                const maxSum = Math.max(...sums.map(Math.abs), Math.abs(r) < 1 ? 1/(1-r) : 5);
                const minSum = Math.min(...sums, 0);
                const range = maxSum - minSum;
                const scaleY = graphHeight / (range * 1.2);
                const originY = margin + (maxSum / (range * 1.2)) * graphHeight;

                drawGrid(ctx, width, height, margin, originY, graphWidth / terms, scaleY);
                drawAxes(ctx, width, height, margin, originY);

                // Draw limit line if converges
                if (Math.abs(r) < 1) {
                    const limit = 1 / (1 - r);
                    const limitY = originY - limit * scaleY;

                    ctx.strokeStyle = colors.gold;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 4]);
                    ctx.beginPath();
                    ctx.moveTo(margin, limitY);
                    ctx.lineTo(width - margin, limitY);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    ctx.fillStyle = colors.gold;
                    ctx.font = '12px JetBrains Mono';
                    ctx.fillText(`L = ${limit.toFixed(3)}`, width - margin - 80, limitY - 10);
                }

                // Draw partial sum curve
                ctx.strokeStyle = colors.cyan;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let i = 0; i < sums.length; i++) {
                    const x = margin + (i / (terms - 1)) * graphWidth;
                    const y = originY - sums[i] * scaleY;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Draw points
                for (let i = 0; i < sums.length; i++) {
                    const x = margin + (i / (terms - 1)) * graphWidth;
                    const y = originY - sums[i] * scaleY;

                    ctx.fillStyle = Math.abs(r) < 1 ? colors.green : colors.red;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Update formula
                const finalSum = sums[sums.length - 1];
                const limitStr = Math.abs(r) < 1 ? (1/(1-r)).toFixed(4) : '∞';
                formula.innerHTML = `s<sub>${terms}</sub> = 1 + r + r² + ... = <span class="${Math.abs(r) < 1 ? 'green' : 'red'}">${finalSum.toFixed(4)}</span> → ${limitStr}`;

                // Update status
                if (Math.abs(r) < 1) {
                    status.className = 'status converges';
                    status.innerHTML = `<span class="status-dot"></span> Converges to ${(1/(1-r)).toFixed(4)}`;
                } else {
                    status.className = 'status diverges';
                    status.innerHTML = '<span class="status-dot"></span> Diverges';
                }
            }

            ratioSlider.addEventListener('input', (e) => {
                r = parseFloat(e.target.value);
                ratioValue.textContent = r.toFixed(2);
                draw();
            });

            termsSlider.addEventListener('input', (e) => {
                terms = parseInt(e.target.value);
                termsValue.textContent = terms;
                draw();
            });

            draw();
            window.addEventListener('resize', draw);
        })();

        // ============================================
        // HARMONIC SERIES
        // ============================================
        (function() {
            const canvas = document.getElementById('harmonicCanvas');
            const termsSlider = document.getElementById('harmonicTermsSlider');
            const termsValue = document.getElementById('harmonicTermsValue');
            const formula = document.getElementById('harmonicFormula');

            let terms = 100;

            function draw() {
                const { ctx, width, height } = setupCanvas(canvas);
                const margin = 50;

                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, width, height);

                // Calculate harmonic numbers
                const H = [0];
                let sum = 0;
                for (let n = 1; n <= terms; n++) {
                    sum += 1/n;
                    if (n <= 50 || n % Math.floor(terms/50) === 0) {
                        H.push({ n, sum });
                    }
                }

                const maxH = H[H.length - 1].sum;
                const scaleX = (width - 2*margin) / terms;
                const scaleY = (height - 2*margin) / (maxH * 1.1);
                const originY = height - margin;

                // Draw log(n) comparison
                ctx.strokeStyle = colors.textDim;
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                for (let n = 1; n <= terms; n++) {
                    const x = margin + n * scaleX;
                    const y = originY - Math.log(n) * scaleY;
                    if (n === 1) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = colors.textDim;
                ctx.font = '11px JetBrains Mono';
                ctx.fillText('ln(n)', width - 60, originY - Math.log(terms) * scaleY - 5);

                // Draw Hₙ curve
                ctx.strokeStyle = colors.red;
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                H.forEach((point, i) => {
                    const x = margin + point.n * scaleX;
                    const y = originY - point.sum * scaleY;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                // Draw axes
                drawAxes(ctx, width, height, margin, originY);

                // Labels
                ctx.fillStyle = colors.red;
                ctx.font = '12px JetBrains Mono';
                ctx.fillText('Hₙ', width - 60, originY - maxH * scaleY - 10);

                ctx.fillStyle = colors.textDim;
                ctx.fillText('n →', width - 40, originY + 20);

                // Update formula
                formula.innerHTML = `H<sub>${terms}</sub> = 1 + 1/2 + 1/3 + ... + 1/${terms} ≈ <span class="red">${sum.toFixed(3)}</span>`;
            }

            termsSlider.addEventListener('input', (e) => {
                terms = parseInt(e.target.value);
                termsValue.textContent = terms;
                draw();
            });

            draw();
            window.addEventListener('resize', draw);
        })();

        // ============================================
        // TELESCOPING SERIES
        // ============================================
        (function() {
            const canvas = document.getElementById('telescopingCanvas');
            const termsSlider = document.getElementById('telescopeTermsSlider');
            const termsValue = document.getElementById('telescopeTermsValue');

            let terms = 10;

            function draw() {
                const { ctx, width, height } = setupCanvas(canvas);
                const margin = 60;

                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, width, height);

                const barWidth = (width - 2*margin) / (terms + 2);
                const maxHeight = height - 2*margin;

                // Draw telescoping visualization
                for (let k = 1; k <= terms; k++) {
                    const x = margin + (k - 0.5) * barWidth;
                    const termVal = 1/(k*(k+1));
                    const barHeight = termVal * maxHeight * 3;

                    // Draw 1/k part (positive)
                    ctx.fillStyle = colors.gold;
                    ctx.globalAlpha = 0.7;
                    ctx.fillRect(x, height - margin - (1/k) * maxHeight, barWidth * 0.4, (1/k) * maxHeight);

                    // Draw -1/(k+1) part (negative, overlapping)
                    ctx.fillStyle = colors.cyan;
                    ctx.fillRect(x + barWidth * 0.3, height - margin - (1/(k+1)) * maxHeight, barWidth * 0.4, (1/(k+1)) * maxHeight);
                    ctx.globalAlpha = 1;
                }

                // Draw partial sum line approaching 1
                const partialSum = 1 - 1/(terms + 1);
                ctx.strokeStyle = colors.green;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const sumY = height - margin - partialSum * maxHeight;
                ctx.moveTo(margin, sumY);
                ctx.lineTo(width - margin, sumY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Limit line at 1
                ctx.strokeStyle = colors.text;
                ctx.lineWidth = 1;
                ctx.beginPath();
                const limitY = height - margin - maxHeight;
                ctx.moveTo(margin, limitY);
                ctx.lineTo(width - margin, limitY);
                ctx.stroke();

                ctx.fillStyle = colors.text;
                ctx.font = '12px JetBrains Mono';
                ctx.fillText('L = 1', margin - 45, limitY + 4);

                ctx.fillStyle = colors.green;
                ctx.fillText(`sₙ = ${partialSum.toFixed(4)}`, margin - 55, sumY + 4);

                // Legend
                ctx.fillStyle = colors.gold;
                ctx.fillRect(width - 150, 30, 15, 15);
                ctx.fillStyle = colors.text;
                ctx.font = '11px JetBrains Mono';
                ctx.fillText('1/k', width - 130, 42);

                ctx.fillStyle = colors.cyan;
                ctx.fillRect(width - 150, 55, 15, 15);
                ctx.fillStyle = colors.text;
                ctx.fillText('-1/(k+1)', width - 130, 67);
            }

            termsSlider.addEventListener('input', (e) => {
                terms = parseInt(e.target.value);
                termsValue.textContent = terms;
                draw();
            });

            draw();
            window.addEventListener('resize', draw);
        })();

        // ============================================
        // DERIVATIVE VISUALIZATION
        // ============================================
        (function() {
            const canvas = document.getElementById('derivativeCanvas');
            const hSlider = document.getElementById('hSlider');
            const hValue = document.getElementById('hValue');
            const pSlider = document.getElementById('pSlider');
            const pValue = document.getElementById('pValue');
            const funcButtons = document.querySelectorAll('[data-func]');

            let h = 1;
            let p = 1;
            let currentFunc = 'cubic';

            const funcs = {
                cubic: { f: x => x*x*x, df: x => 3*x*x, label: 'x³' },
                sin: { f: x => Math.sin(x), df: x => Math.cos(x), label: 'sin(x)' },
                exp: { f: x => Math.exp(x), df: x => Math.exp(x), label: 'eˣ' },
                log: { f: x => Math.log(x + 2), df: x => 1/(x + 2), label: 'ln(x+2)' }
            };

            function draw() {
                const { ctx, width, height } = setupCanvas(canvas);
                const { f, df, label } = funcs[currentFunc];

                const originX = width * 0.4;
                const originY = height * 0.6;
                const scaleX = 80;
                const scaleY = 40;

                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, width, height);

                drawGrid(ctx, width, height, originX, originY, scaleX, scaleY);
                drawAxes(ctx, width, height, originX, originY);

                // Draw function
                ctx.strokeStyle = colors.text;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let px = 0; px < width; px++) {
                    const x = (px - originX) / scaleX;
                    const y = f(x);
                    const py = originY - y * scaleY;
                    if (px === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Points
                const pX = originX + p * scaleX;
                const pY = originY - f(p) * scaleY;
                const qX = originX + (p + h) * scaleX;
                const qY = originY - f(p + h) * scaleY;

                // Secant line (extended)
                const secantSlope = (f(p + h) - f(p)) / h;
                ctx.strokeStyle = colors.green;
                ctx.lineWidth = 2;
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.moveTo(0, pY + (pX) * secantSlope);
                ctx.lineTo(width, pY - (width - pX) * secantSlope);
                ctx.stroke();
                ctx.globalAlpha = 1;

                // Tangent line (true derivative)
                const tangentSlope = df(p);
                ctx.strokeStyle = colors.gold;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, pY + pX * tangentSlope / scaleX * scaleY);
                ctx.lineTo(width, pY - (width - pX) * tangentSlope / scaleX * scaleY);
                ctx.stroke();

                // Draw points
                ctx.fillStyle = colors.cyan;
                ctx.beginPath();
                ctx.arc(pX, pY, 8, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = colors.green;
                ctx.beginPath();
                ctx.arc(qX, qY, 6, 0, Math.PI * 2);
                ctx.fill();

                // Draw h distance
                ctx.strokeStyle = colors.gold;
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(pX, pY);
                ctx.lineTo(pX, pY + 40);
                ctx.moveTo(qX, qY);
                ctx.lineTo(qX, pY + 40);
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.strokeStyle = colors.gold;
                ctx.beginPath();
                ctx.moveTo(pX, pY + 35);
                ctx.lineTo(qX, pY + 35);
                ctx.stroke();

                ctx.fillStyle = colors.gold;
                ctx.font = '12px JetBrains Mono';
                ctx.fillText(`h = ${h.toFixed(2)}`, (pX + qX) / 2 - 25, pY + 55);

                // Labels
                ctx.fillStyle = colors.cyan;
                ctx.fillText(`(p, f(p))`, pX - 35, pY - 15);

                ctx.fillStyle = colors.green;
                ctx.fillText(`secant: ${secantSlope.toFixed(3)}`, 20, 30);

                ctx.fillStyle = colors.gold;
                ctx.fillText(`tangent: ${tangentSlope.toFixed(3)}`, 20, 50);

                ctx.fillStyle = colors.text;
                ctx.fillText(`f(x) = ${label}`, width - 100, 30);
            }

            hSlider.addEventListener('input', (e) => {
                h = parseFloat(e.target.value);
                hValue.textContent = h.toFixed(2);
                draw();
            });

            pSlider.addEventListener('input', (e) => {
                p = parseFloat(e.target.value);
                pValue.textContent = p.toFixed(2);
                draw();
            });

            funcButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    funcButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentFunc = btn.dataset.func;
                    draw();
                });
            });

            draw();
            window.addEventListener('resize', draw);
        })();

        // ============================================
        // MEAN VALUE THEOREM
        // ============================================
        (function() {
            const canvas = document.getElementById('mvtCanvas');
            const aSlider = document.getElementById('aSlider');
            const aValue = document.getElementById('aValue');
            const bSlider = document.getElementById('bSlider');
            const bValue = document.getElementById('bValue');

            let a = -1;
            let b = 2;

            const f = x => x * x * x - x;
            const df = x => 3 * x * x - 1;

            function draw() {
                const { ctx, width, height } = setupCanvas(canvas);

                const originX = width * 0.4;
                const originY = height * 0.5;
                const scaleX = 80;
                const scaleY = 30;

                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, width, height);

                drawGrid(ctx, width, height, originX, originY, scaleX, scaleY);
                drawAxes(ctx, width, height, originX, originY);

                // Draw function
                ctx.strokeStyle = colors.text;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let px = 0; px < width; px++) {
                    const x = (px - originX) / scaleX;
                    const y = f(x);
                    const py = originY - y * scaleY;
                    if (px === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Points a and b
                const aX = originX + a * scaleX;
                const aY = originY - f(a) * scaleY;
                const bX = originX + b * scaleX;
                const bY = originY - f(b) * scaleY;

                // Secant line
                const secantSlope = (f(b) - f(a)) / (b - a);
                ctx.strokeStyle = colors.gold;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(aX - 50, aY + 50 * secantSlope);
                ctx.lineTo(bX + 50, bY - 50 * secantSlope);
                ctx.stroke();

                // Find c where f'(c) = secant slope
                // For f(x) = x³ - x, f'(x) = 3x² - 1
                // Solve 3c² - 1 = secantSlope
                const discriminant = (secantSlope + 1) / 3;
                let c = null;
                if (discriminant >= 0) {
                    const c1 = Math.sqrt(discriminant);
                    const c2 = -Math.sqrt(discriminant);
                    if (c1 > a && c1 < b) c = c1;
                    else if (c2 > a && c2 < b) c = c2;
                }

                // Draw tangent at c
                if (c !== null) {
                    const cX = originX + c * scaleX;
                    const cY = originY - f(c) * scaleY;
                    const tangentSlope = df(c);

                    ctx.strokeStyle = colors.cyan;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 4]);
                    ctx.beginPath();
                    ctx.moveTo(cX - 100, cY + 100 * tangentSlope / scaleX * scaleY);
                    ctx.lineTo(cX + 100, cY - 100 * tangentSlope / scaleX * scaleY);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Point c
                    ctx.fillStyle = colors.cyan;
                    ctx.beginPath();
                    ctx.arc(cX, cY, 7, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.font = '12px JetBrains Mono';
                    ctx.fillText(`c ≈ ${c.toFixed(2)}`, cX + 10, cY - 10);
                }

                // Draw points a and b
                ctx.fillStyle = colors.gold;
                ctx.beginPath();
                ctx.arc(aX, aY, 7, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(bX, bY, 7, 0, Math.PI * 2);
                ctx.fill();

                ctx.font = '12px JetBrains Mono';
                ctx.fillText('a', aX - 15, aY + 20);
                ctx.fillText('b', bX + 10, bY - 10);

                // Function label
                ctx.fillStyle = colors.text;
                ctx.fillText('f(x) = x³ - x', width - 110, 30);
            }

            aSlider.addEventListener('input', (e) => {
                a = parseFloat(e.target.value);
                if (a >= b) a = b - 0.1;
                aValue.textContent = a.toFixed(2);
                draw();
            });

            bSlider.addEventListener('input', (e) => {
                b = parseFloat(e.target.value);
                if (b <= a) b = a + 0.1;
                bValue.textContent = b.toFixed(2);
                draw();
            });

            draw();
            window.addEventListener('resize', draw);
        })();

        // ============================================
        // TAYLOR SERIES
        // ============================================
        (function() {
            const canvas = document.getElementById('taylorCanvas');
            const degreeSlider = document.getElementById('degreeSlider');
            const degreeValue = document.getElementById('degreeValue');
            const centerSlider = document.getElementById('centerSlider');
            const centerValue = document.getElementById('centerValue');
            const taylorFormula = document.getElementById('taylorFormula');
            const taylorButtons = document.querySelectorAll('[data-taylor]');

            let degree = 3;
            let center = 0;
            let currentFunc = 'exp';

            // Taylor coefficients at center = 0
            const taylorFuncs = {
                exp: {
                    f: x => Math.exp(x),
                    coeffs: n => 1 / factorial(n),
                    formula: 'eˣ = 1 + x + x²/2! + x³/3! + ...'
                },
                sin: {
                    f: x => Math.sin(x),
                    coeffs: n => n % 2 === 0 ? 0 : Math.pow(-1, (n-1)/2) / factorial(n),
                    formula: 'sin(x) = x - x³/3! + x⁵/5! - ...'
                },
                cos: {
                    f: x => Math.cos(x),
                    coeffs: n => n % 2 === 1 ? 0 : Math.pow(-1, n/2) / factorial(n),
                    formula: 'cos(x) = 1 - x²/2! + x⁴/4! - ...'
                },
                log: {
                    f: x => Math.log(1 + x),
                    coeffs: n => n === 0 ? 0 : Math.pow(-1, n+1) / n,
                    formula: 'ln(1+x) = x - x²/2 + x³/3 - ...'
                },
                geometric: {
                    f: x => 1 / (1 - x),
                    coeffs: n => 1,
                    formula: '1/(1-x) = 1 + x + x² + x³ + ...'
                }
            };

            function factorial(n) {
                if (n <= 1) return 1;
                let result = 1;
                for (let i = 2; i <= n; i++) result *= i;
                return result;
            }

            function taylorEval(x, n, centerVal) {
                const { coeffs } = taylorFuncs[currentFunc];
                let sum = 0;
                for (let i = 0; i <= n; i++) {
                    sum += coeffs(i) * Math.pow(x - centerVal, i);
                }
                return sum;
            }

            function draw() {
                const { ctx, width, height } = setupCanvas(canvas);
                const { f, formula } = taylorFuncs[currentFunc];

                const originX = width * 0.5;
                const originY = height * 0.5;
                const scaleX = 60;
                const scaleY = 50;

                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, width, height);

                drawGrid(ctx, width, height, originX, originY, scaleX, scaleY);
                drawAxes(ctx, width, height, originX, originY);

                // Clipping bounds
                const minX = (0 - originX) / scaleX;
                const maxX = (width - originX) / scaleX;

                // Draw true function
                ctx.strokeStyle = colors.text;
                ctx.lineWidth = 2;
                ctx.beginPath();
                let started = false;
                for (let px = 0; px < width; px++) {
                    const x = (px - originX) / scaleX;
                    let y;
                    try {
                        y = f(x);
                        if (!isFinite(y) || Math.abs(y) > 10) continue;
                    } catch { continue; }
                    const py = originY - y * scaleY;
                    if (py < -100 || py > height + 100) continue;
                    if (!started) { ctx.moveTo(px, py); started = true; }
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Draw Taylor polynomial
                ctx.strokeStyle = colors.cyan;
                ctx.lineWidth = 3;
                ctx.beginPath();
                started = false;
                for (let px = 0; px < width; px++) {
                    const x = (px - originX) / scaleX;
                    const y = taylorEval(x, degree, center);
                    if (!isFinite(y) || Math.abs(y) > 10) continue;
                    const py = originY - y * scaleY;
                    if (py < -100 || py > height + 100) continue;
                    if (!started) { ctx.moveTo(px, py); started = true; }
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Mark center point
                const centerX = originX + center * scaleX;
                const centerY = originY - f(center) * scaleY;
                ctx.fillStyle = colors.gold;
                ctx.beginPath();
                ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
                ctx.fill();

                // Legend
                ctx.font = '12px JetBrains Mono';
                ctx.fillStyle = colors.text;
                ctx.fillText('True function', 20, 25);
                ctx.fillStyle = colors.cyan;
                ctx.fillText(`Taylor (n=${degree})`, 20, 45);

                taylorFormula.textContent = formula;
            }

            degreeSlider.addEventListener('input', (e) => {
                degree = parseInt(e.target.value);
                degreeValue.textContent = degree;
                draw();
            });

            centerSlider.addEventListener('input', (e) => {
                center = parseFloat(e.target.value);
                centerValue.textContent = center.toFixed(2);
                draw();
            });

            taylorButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    taylorButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentFunc = btn.dataset.taylor;
                    draw();
                });
            });

            draw();
            window.addEventListener('resize', draw);
        })();

        // ============================================
        // RADIUS OF CONVERGENCE
        // ============================================
        (function() {
            const canvas = document.getElementById('radiusCanvas');
            const evalXSlider = document.getElementById('evalXSlider');
            const evalXValue = document.getElementById('evalXValue');

            let evalX = 0.5;

            function draw() {
                const { ctx, width, height } = setupCanvas(canvas);

                const originX = width * 0.5;
                const originY = height * 0.6;
                const scaleX = 150;
                const scaleY = 80;

                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, width, height);

                // Draw convergence region
                ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
                const leftBound = originX - scaleX;
                const rightBound = originX + scaleX;
                ctx.fillRect(leftBound, 0, rightBound - leftBound, height);

                // Divergence regions
                ctx.fillStyle = 'rgba(244, 63, 94, 0.1)';
                ctx.fillRect(0, 0, leftBound, height);
                ctx.fillRect(rightBound, 0, width - rightBound, height);

                // Boundaries
                ctx.strokeStyle = colors.textDim;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(leftBound, 0);
                ctx.lineTo(leftBound, height);
                ctx.moveTo(rightBound, 0);
                ctx.lineTo(rightBound, height);
                ctx.stroke();
                ctx.setLineDash([]);

                drawAxes(ctx, width, height, originX, originY);

                // Draw 1/(1-x)
                ctx.strokeStyle = colors.text;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let px = 0; px < width; px++) {
                    const x = (px - originX) / scaleX;
                    if (Math.abs(x - 1) < 0.05) continue; // Skip singularity
                    const y = 1 / (1 - x);
                    if (Math.abs(y) > 5) continue;
                    const py = originY - y * scaleY;
                    if (px === 0 || Math.abs(x - 1) < 0.1) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Draw partial sum at evalX
                const evalPX = originX + evalX * scaleX;
                const trueVal = 1 / (1 - evalX);

                // Compute partial sums
                let sum = 0;
                const partials = [];
                for (let n = 0; n <= 20; n++) {
                    sum += Math.pow(evalX, n);
                    partials.push(sum);
                }

                // Draw vertical line at evalX
                ctx.strokeStyle = Math.abs(evalX) < 1 ? colors.green : colors.red;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(evalPX, 0);
                ctx.lineTo(evalPX, height);
                ctx.stroke();

                // Draw partial sum points
                if (Math.abs(evalX) < 1) {
                    for (let i = 0; i < partials.length; i++) {
                        const py = originY - partials[i] * scaleY;
                        if (py < 0 || py > height) continue;
                        ctx.fillStyle = colors.cyan;
                        ctx.globalAlpha = 0.3 + 0.7 * (i / partials.length);
                        ctx.beginPath();
                        ctx.arc(evalPX, py, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.globalAlpha = 1;

                    // True value marker
                    const trueY = originY - trueVal * scaleY;
                    ctx.fillStyle = colors.gold;
                    ctx.beginPath();
                    ctx.arc(evalPX, trueY, 8, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Labels
                ctx.font = '12px JetBrains Mono';
                ctx.fillStyle = colors.green;
                ctx.fillText('|x| < 1: converges', originX - 50, 30);
                ctx.fillStyle = colors.red;
                ctx.fillText('|x| ≥ 1: diverges', rightBound + 10, 30);
                ctx.fillText('|x| ≥ 1: diverges', 20, 30);

                ctx.fillStyle = colors.textDim;
                ctx.fillText('-1', leftBound - 10, originY + 25);
                ctx.fillText('1', rightBound - 5, originY + 25);
                ctx.fillText(`x = ${evalX.toFixed(2)}`, evalPX - 30, height - 20);
            }

            evalXSlider.addEventListener('input', (e) => {
                evalX = parseFloat(e.target.value);
                evalXValue.textContent = evalX.toFixed(2);
                draw();
            });

            draw();
            window.addEventListener('resize', draw);
        })();

        // ============================================
        // RIEMANN INTEGRAL
        // ============================================
        (function() {
            const canvas = document.getElementById('integralCanvas');
            const rectsSlider = document.getElementById('rectsSlider');
            const rectsValue = document.getElementById('rectsValue');
            const integralApprox = document.getElementById('integralApprox');
            const sumButtons = document.querySelectorAll('[data-sum]');
            const funcButtons = document.querySelectorAll('[data-intfunc]');

            let numRects = 10;
            let sumType = 'left';
            let currentFunc = 'parabola';

            const intFuncs = {
                parabola: { f: x => x * x, F: x => x*x*x/3, a: 0, b: 2, label: 'x²' },
                sine: { f: x => Math.sin(x), F: x => -Math.cos(x), a: 0, b: Math.PI, label: 'sin(x)' },
                cubic: { f: x => x * x * x, F: x => x*x*x*x/4, a: 0, b: 2, label: 'x³' }
            };

            function draw() {
                const { ctx, width, height } = setupCanvas(canvas);
                const { f, F, a, b, label } = intFuncs[currentFunc];

                const margin = 60;
                const graphWidth = width - 2 * margin;
                const graphHeight = height - 2 * margin;

                // Find scale
                let maxY = 0;
                for (let x = a; x <= b; x += 0.01) {
                    maxY = Math.max(maxY, f(x));
                }
                const scaleX = graphWidth / (b - a);
                const scaleY = graphHeight / (maxY * 1.2);
                const originY = height - margin;

                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, width, height);

                // Draw rectangles
                const dx = (b - a) / numRects;
                let sum = 0;

                for (let i = 0; i < numRects; i++) {
                    const x0 = a + i * dx;
                    const x1 = x0 + dx;
                    let sampleX;

                    switch(sumType) {
                        case 'left': sampleX = x0; break;
                        case 'right': sampleX = x1; break;
                        case 'mid': sampleX = (x0 + x1) / 2; break;
                        case 'trap': sampleX = x0; break; // Handle separately
                    }

                    const rectX = margin + (x0 - a) * scaleX;
                    const rectWidth = dx * scaleX;
                    let rectHeight;

                    if (sumType === 'trap') {
                        const h0 = f(x0) * scaleY;
                        const h1 = f(x1) * scaleY;
                        sum += (f(x0) + f(x1)) / 2 * dx;

                        // Draw trapezoid
                        ctx.fillStyle = 'rgba(6, 182, 212, 0.3)';
                        ctx.strokeStyle = colors.cyan;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(rectX, originY);
                        ctx.lineTo(rectX, originY - h0);
                        ctx.lineTo(rectX + rectWidth, originY - h1);
                        ctx.lineTo(rectX + rectWidth, originY);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        rectHeight = f(sampleX) * scaleY;
                        sum += f(sampleX) * dx;

                        ctx.fillStyle = 'rgba(6, 182, 212, 0.3)';
                        ctx.strokeStyle = colors.cyan;
                        ctx.lineWidth = 1;
                        ctx.fillRect(rectX, originY - rectHeight, rectWidth, rectHeight);
                        ctx.strokeRect(rectX, originY - rectHeight, rectWidth, rectHeight);
                    }
                }

                // Draw function
                ctx.strokeStyle = colors.gold;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let px = margin; px < width - margin; px++) {
                    const x = a + (px - margin) / scaleX;
                    const y = f(x);
                    const py = originY - y * scaleY;
                    if (px === margin) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Draw axes
                ctx.strokeStyle = colors.textDim;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(margin, originY);
                ctx.lineTo(width - margin, originY);
                ctx.moveTo(margin, originY);
                ctx.lineTo(margin, margin);
                ctx.stroke();

                // Labels
                ctx.fillStyle = colors.textDim;
                ctx.font = '12px JetBrains Mono';
                ctx.fillText(a.toFixed(1), margin - 5, originY + 20);
                ctx.fillText(b.toFixed(1), width - margin - 10, originY + 20);
                ctx.fillText(`f(x) = ${label}`, width - margin - 80, 30);

                // True integral value
                const trueValue = F(b) - F(a);
                ctx.fillStyle = colors.text;
                ctx.fillText(`True: ${trueValue.toFixed(4)}`, 20, 30);
                ctx.fillStyle = colors.cyan;
                ctx.fillText(`Approx: ${sum.toFixed(4)}`, 20, 50);
                ctx.fillStyle = colors.green;
                ctx.fillText(`Error: ${Math.abs(trueValue - sum).toFixed(4)}`, 20, 70);

                integralApprox.textContent = sum.toFixed(4);
            }

            rectsSlider.addEventListener('input', (e) => {
                numRects = parseInt(e.target.value);
                rectsValue.textContent = numRects;
                draw();
            });

            sumButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    sumButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    sumType = btn.dataset.sum;
                    draw();
                });
            });

            funcButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    funcButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentFunc = btn.dataset.intfunc;
                    draw();
                });
            });

            draw();
            window.addEventListener('resize', draw);
        })();

        // ============================================
        // FUNDAMENTAL THEOREM OF CALCULUS
        // ============================================
        (function() {
            const canvas = document.getElementById('ftcCanvas');
            const bSlider = document.getElementById('ftcBSlider');
            const bValueEl = document.getElementById('ftcBValue');
            const resultEl = document.getElementById('ftcResult');

            let b = 2;
            const a = 0;

            // f(x) = x², F(x) = x³/3, f'(x) = 2x
            const fprime = x => 2 * x;
            const F = x => x * x;

            function draw() {
                const { ctx, width, height } = setupCanvas(canvas);

                const margin = 60;
                const midY = height / 2;

                ctx.fillStyle = colors.bg;
                ctx.fillRect(0, 0, width, height);

                // Top graph: f'(x) = 2x with shaded area
                const topOriginY = midY - 30;
                const scaleX = (width - 2 * margin) / 3.5;
                const scaleY = 40;

                // Shade area under f'
                ctx.fillStyle = 'rgba(6, 182, 212, 0.3)';
                ctx.beginPath();
                ctx.moveTo(margin + a * scaleX, topOriginY);
                for (let x = a; x <= b; x += 0.05) {
                    ctx.lineTo(margin + x * scaleX, topOriginY - fprime(x) * scaleY);
                }
                ctx.lineTo(margin + b * scaleX, topOriginY);
                ctx.closePath();
                ctx.fill();

                // Draw f'(x)
                ctx.strokeStyle = colors.cyan;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = -0.5; x <= 3.5; x += 0.05) {
                    const px = margin + x * scaleX;
                    const py = topOriginY - fprime(x) * scaleY;
                    if (x === -0.5) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Top axes
                ctx.strokeStyle = colors.textDim;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(margin - 20, topOriginY);
                ctx.lineTo(width - margin + 20, topOriginY);
                ctx.stroke();

                // Labels
                ctx.fillStyle = colors.cyan;
                ctx.font = '12px JetBrains Mono';
                ctx.fillText("f'(x) = 2x", width - margin - 80, topOriginY - 100);
                ctx.fillStyle = colors.textDim;
                ctx.fillText('0', margin - 5, topOriginY + 15);
                ctx.fillText(`b = ${b.toFixed(1)}`, margin + b * scaleX - 15, topOriginY + 20);

                // Area annotation
                const area = F(b) - F(a);
                ctx.fillStyle = colors.green;
                ctx.font = '14px JetBrains Mono';
                ctx.fillText(`Area = ${area.toFixed(2)}`, margin + (b/2) * scaleX - 30, topOriginY - 30);

                // Bottom graph: f(x) = x² with net change
                const botOriginY = height - margin;
                const botScaleY = 30;

                // Draw f(x)
                ctx.strokeStyle = colors.gold;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = -0.5; x <= 3.5; x += 0.05) {
                    const px = margin + x * scaleX;
                    const py = botOriginY - F(x) * botScaleY;
                    if (x === -0.5) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();

                // Bottom axes
                ctx.strokeStyle = colors.textDim;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(margin - 20, botOriginY);
                ctx.lineTo(width - margin + 20, botOriginY);
                ctx.stroke();

                // Mark f(a) and f(b)
                const faY = botOriginY - F(a) * botScaleY;
                const fbY = botOriginY - F(b) * botScaleY;
                const bX = margin + b * scaleX;

                ctx.fillStyle = colors.gold;
                ctx.beginPath();
                ctx.arc(margin, faY, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(bX, fbY, 6, 0, Math.PI * 2);
                ctx.fill();

                // Net change line
                ctx.strokeStyle = colors.green;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(bX + 20, faY);
                ctx.lineTo(bX + 20, fbY);
                ctx.stroke();
                ctx.setLineDash([]);

                // Arrow heads
                ctx.fillStyle = colors.green;
                ctx.beginPath();
                ctx.moveTo(bX + 20, fbY);
                ctx.lineTo(bX + 15, fbY + 10);
                ctx.lineTo(bX + 25, fbY + 10);
                ctx.closePath();
                ctx.fill();

                ctx.font = '12px JetBrains Mono';
                ctx.fillText(`Δf = ${area.toFixed(2)}`, bX + 30, (faY + fbY) / 2);

                ctx.fillStyle = colors.gold;
                ctx.fillText('f(x) = x²', width - margin - 80, botOriginY - 100);
                ctx.fillText('f(a) = 0', margin - 50, faY + 5);
                ctx.fillText(`f(b) = ${F(b).toFixed(1)}`, bX + 10, fbY - 10);

                resultEl.textContent = `b² - a² = ${b.toFixed(1)}² - 0² = ${area.toFixed(2)}`;
            }

            bSlider.addEventListener('input', (e) => {
                b = parseFloat(e.target.value);
                bValueEl.textContent = b.toFixed(2);
                draw();
            });

            draw();
            window.addEventListener('resize', draw);
        })();

        // ============================================
        // SMOOTH SCROLL FOR NAV
        // ============================================
        document.querySelectorAll('.nav-link').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const target = document.querySelector(link.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });

        // Highlight active nav on scroll
        const sections = document.querySelectorAll('section');
        const navLinks = document.querySelectorAll('.nav-link');

        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (window.scrollY >= sectionTop - 200) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === '#' + current) {
                    link.classList.add('active');
                }
            });
        });
    </script>
</body>
</html>
