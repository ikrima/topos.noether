<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sampling the Infinite</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --deep-void: #06080f;
            --glow-cyan: #00d4ff;
            --glow-magenta: #ff006e;
            --glow-gold: #ffd700;
            --glow-emerald: #00ffaa;
            --glow-violet: #8844ff;
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: var(--deep-void);
            color: var(--text-primary);
            line-height: 1.7;
            overflow-x: hidden;
        }

        /* Matrix-like background */
        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 30% 30%, rgba(136, 68, 255, 0.08) 0%, transparent 50%),
                radial-gradient(ellipse at 70% 70%, rgba(0, 255, 170, 0.06) 0%, transparent 50%),
                radial-gradient(ellipse at 50% 50%, rgba(0, 212, 255, 0.04) 0%, transparent 60%),
                var(--deep-void);
            pointer-events: none;
            z-index: 0;
        }

        /* Animated grid lines */
        .grid-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 170, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 170, 0.03) 1px, transparent 1px);
            background-size: 60px 60px;
            pointer-events: none;
            z-index: 0;
            animation: gridPulse 8s ease-in-out infinite;
        }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 60px 40px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 80px;
            animation: fadeInDown 1s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .series-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: var(--glow-emerald);
            margin-bottom: 20px;
            display: inline-block;
            padding: 8px 16px;
            border: 1px solid rgba(0, 255, 170, 0.3);
            background: rgba(0, 255, 170, 0.05);
        }

        h1 {
            font-size: clamp(2.5rem, 6vw, 4rem);
            font-weight: 400;
            margin-bottom: 24px;
            background: linear-gradient(135deg, var(--glow-emerald) 0%, var(--glow-cyan) 50%, var(--glow-violet) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.4rem;
            font-style: italic;
            color: var(--text-secondary);
            max-width: 680px;
            margin: 0 auto;
        }

        section { margin-bottom: 100px; }

        h2 {
            font-size: 2rem;
            font-weight: 400;
            color: var(--glow-emerald);
            margin-bottom: 30px;
            position: relative;
            display: inline-block;
        }

        h2::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 0;
            width: 60%;
            height: 2px;
            background: linear-gradient(90deg, var(--glow-emerald), transparent);
        }

        h3 {
            font-size: 1.5rem;
            font-weight: 400;
            color: var(--glow-cyan);
            margin: 40px 0 20px;
        }

        p {
            font-size: 1.2rem;
            margin-bottom: 24px;
            color: var(--text-primary);
            max-width: 800px;
        }

        .highlight-text {
            color: var(--glow-emerald);
            font-weight: 600;
        }

        .code-inline {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            background: rgba(0, 255, 170, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
            color: var(--glow-emerald);
        }

        .equation-box {
            background: rgba(136, 68, 255, 0.08);
            border-left: 3px solid var(--glow-violet);
            padding: 30px;
            margin: 40px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            text-align: center;
            border-radius: 0 8px 8px 0;
        }

        .equation-box .main-eq {
            font-size: 1.4rem;
            color: var(--glow-emerald);
            margin: 20px 0;
        }

        .callout {
            background: linear-gradient(135deg, rgba(0, 255, 170, 0.1), rgba(136, 68, 255, 0.08));
            border: 1px solid rgba(0, 255, 170, 0.2);
            border-radius: 12px;
            padding: 30px;
            margin: 40px 0;
        }

        .callout-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--glow-emerald);
            margin-bottom: 15px;
        }

        /* Interactive canvas containers */
        .interactive-panel {
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid rgba(0, 255, 170, 0.2);
            border-radius: 12px;
            padding: 30px;
            margin: 50px 0;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(0, 255, 170, 0.15);
        }

        .panel-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--glow-emerald);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
            background: rgba(6, 8, 15, 0.8);
            border-radius: 8px;
            overflow: hidden;
        }

        .canvas-container canvas {
            width: 100%;
            height: 100%;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .control-btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            padding: 10px 20px;
            background: rgba(0, 255, 170, 0.1);
            border: 1px solid rgba(0, 255, 170, 0.3);
            border-radius: 6px;
            color: var(--glow-emerald);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(0, 255, 170, 0.2);
            border-color: var(--glow-emerald);
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.2);
        }

        .control-btn.active {
            background: var(--glow-emerald);
            color: var(--deep-void);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .slider-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-secondary);
            min-width: 100px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 200px;
            height: 4px;
            background: rgba(0, 255, 170, 0.2);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--glow-emerald);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px var(--glow-emerald);
        }

        .value-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--glow-cyan);
            min-width: 40px;
        }

        /* Complexity comparison visualization */
        .complexity-comparison {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 30px;
            margin: 40px 0;
        }

        .complexity-card {
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid rgba(136, 68, 255, 0.2);
            border-radius: 12px;
            padding: 25px;
            transition: all 0.3s ease;
        }

        .complexity-card:hover {
            border-color: var(--glow-violet);
            box-shadow: 0 0 30px rgba(136, 68, 255, 0.15);
        }

        .complexity-card.efficient {
            border-color: rgba(0, 255, 170, 0.2);
        }

        .complexity-card.efficient:hover {
            border-color: var(--glow-emerald);
            box-shadow: 0 0 30px rgba(0, 255, 170, 0.15);
        }

        .complexity-card h4 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--glow-violet);
            margin-bottom: 15px;
        }

        .complexity-card.efficient h4 {
            color: var(--glow-emerald);
        }

        .complexity-formula {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.3rem;
            margin: 15px 0;
        }

        .complexity-desc {
            font-size: 1rem;
            color: var(--text-secondary);
        }

        /* Algorithm steps visualization */
        .algorithm-flow {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 40px 0;
        }

        .algo-step {
            display: flex;
            align-items: flex-start;
            gap: 20px;
            padding: 20px;
            background: rgba(10, 15, 25, 0.6);
            border-left: 3px solid var(--glow-emerald);
            border-radius: 0 8px 8px 0;
            transition: all 0.3s ease;
        }

        .algo-step:hover {
            background: rgba(0, 255, 170, 0.05);
            transform: translateX(5px);
        }

        .step-number {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--glow-emerald);
            background: rgba(0, 255, 170, 0.1);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .step-content h4 {
            color: var(--glow-cyan);
            margin-bottom: 8px;
            font-weight: 600;
        }

        .step-content p {
            font-size: 1rem;
            margin-bottom: 0;
        }

        /* Mirzakhani connection panel */
        .parallel-panel {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            gap: 20px;
            align-items: center;
            margin: 50px 0;
        }

        .parallel-item {
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid rgba(136, 68, 255, 0.2);
            border-radius: 12px;
            padding: 25px;
            text-align: center;
        }

        .parallel-item h4 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--glow-violet);
            margin-bottom: 10px;
        }

        .parallel-item .domain {
            font-size: 1.1rem;
            color: var(--glow-cyan);
            margin-bottom: 10px;
        }

        .parallel-connector {
            font-size: 2rem;
            color: var(--glow-emerald);
        }

        /* Stats display */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 40px 0;
        }

        .stat-item {
            text-align: center;
            padding: 25px;
            background: rgba(10, 15, 25, 0.9);
            border: 1px solid rgba(0, 255, 170, 0.15);
            border-radius: 12px;
        }

        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2rem;
            color: var(--glow-emerald);
            margin-bottom: 8px;
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Footer navigation */
        .essay-nav {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            padding: 40px 0;
            border-top: 1px solid rgba(0, 255, 170, 0.15);
            margin-top: 80px;
        }

        .nav-link {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            letter-spacing: 0.1em;
            padding: 10px 18px;
            background: transparent;
            border: 1px solid rgba(0, 255, 170, 0.2);
            border-radius: 4px;
            color: var(--text-secondary);
            text-decoration: none;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            border-color: var(--glow-emerald);
            color: var(--glow-emerald);
        }

        .nav-link.current {
            border-color: var(--glow-emerald);
            background: rgba(0, 255, 170, 0.1);
            color: var(--glow-emerald);
        }

        /* Animation for sampling dots */
        @keyframes samplePulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
        }

        /* Responsive */
        @media (max-width: 768px) {
            .container { padding: 40px 20px; }
            .complexity-comparison { grid-template-columns: 1fr; }
            .parallel-panel { 
                grid-template-columns: 1fr;
                text-align: center;
            }
            .parallel-connector { transform: rotate(90deg); }
            .stats-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="matrix-bg"></div>
    <div class="grid-overlay"></div>

    <div class="container">
        <header class="header">
            <div class="series-tag">Essay V ¬∑ Graph Space Chronicles</div>
            <h1>Sampling the Infinite</h1>
            <p class="subtitle">How exact solvability enables polynomial-time exploration of moduli spaces</p>
        </header>

        <section>
            <h2>The Computational Challenge</h2>
            <p>
                We've established that moduli spaces of graphs contain vast amounts of hidden structure‚Äîbillions 
                upon billions of cohomology classes lurking in higher dimensions. But knowing something exists 
                and being able to <span class="highlight-text">find it</span> are vastly different computational challenges.
            </p>
            <p>
                The naive approach to exploring these spaces faces a fundamental barrier: the number of graphs 
                grows super-exponentially with rank. To systematically search through all graphs of rank n 
                would require time proportional to (n/e)^n‚Äîfor n = 20, that's roughly 10^17 graphs. Even at 
                a billion graphs per second, you'd need three years. For n = 30, the universe isn't old enough.
            </p>

            <div class="callout">
                <div class="callout-title">The Complexity Wall</div>
                <p>
                    Traditional perturbative QFT calculations grow factorially: the number of Feynman diagrams 
                    at n loops is roughly n! (n factorial). This is why physicists rarely compute beyond 4-5 loops‚Äî
                    the combinatorial explosion overwhelms any computational resources.
                </p>
            </div>
        </section>

        <section>
            <h2>The Tropical Breakthrough</h2>
            <p>
                Borinsky's 2025 discovery transforms this picture entirely. By tropicalizing the quantum field 
                theory‚Äîtaking the limit Œæ ‚Üí 0‚Å∫ in a deformed action‚Äîhe discovered that the resulting theory 
                is <span class="highlight-text">exactly solvable</span>.
            </p>
            <p>
                "Exactly solvable" means we can write closed-form recursion relations that compute the answer 
                without needing to enumerate all possibilities. The key is a non-linear recursion for the 
                coefficients of the quantum effective action:
            </p>

            <div class="equation-box">
                <div style="color: var(--text-secondary);">Tropical Recursion for Effective Action Coefficients</div>
                <div class="main-eq">
                    ŒìÃÇ<sub>g,n</sub> = F(ŒìÃÇ<sub>&lt;g,*</sub>, ŒìÃÇ<sub>g,&lt;n</sub>)
                </div>
                <div style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 10px;">
                    Each coefficient is determined by finitely many earlier coefficients
                </div>
            </div>

            <p>
                This recursion is structurally identical to Mirzakhani's celebrated volume recursions for moduli 
                spaces of hyperbolic surfaces‚Äîexcept it operates on graphs rather than curves. The geometric 
                interpretation is profound: these coefficients are actually <span class="highlight-text">volumes</span> 
                of moduli spaces of metric graphs.
            </p>
        </section>

        <!-- Mirzakhani Connection Panel -->
        <div class="parallel-panel">
            <div class="parallel-item">
                <h4>Mirzakhani (Curves)</h4>
                <div class="domain">ùìú<sub>g,n</sub></div>
                <p>Moduli of hyperbolic surfaces</p>
                <p style="color: var(--glow-violet); margin-top: 10px;">Weil-Petersson volumes</p>
            </div>
            <div class="parallel-connector">‚ü∑</div>
            <div class="parallel-item">
                <h4>Borinsky (Graphs)</h4>
                <div class="domain">ùìúùìñ<sub>g,n</sub></div>
                <p>Moduli of metric graphs</p>
                <p style="color: var(--glow-violet); margin-top: 10px;">Tropical volumes</p>
            </div>
        </div>

        <section>
            <h2>From Recursion to Sampling</h2>
            <p>
                The exact solvability of the tropical theory enables something remarkable: we can 
                <span class="highlight-text">sample uniformly</span> from the moduli space of graphs in 
                polynomial time. Not just any graphs‚Äîbut graphs distributed exactly according to the 
                natural measure on the moduli space.
            </p>

            <div class="algorithm-flow">
                <div class="algo-step">
                    <div class="step-number">1</div>
                    <div class="step-content">
                        <h4>Compute Tropical Volumes</h4>
                        <p>Use the recursion to pre-compute volumes for all (g, n) up to desired bounds. This is a one-time cost with polynomial complexity.</p>
                    </div>
                </div>
                <div class="algo-step">
                    <div class="step-number">2</div>
                    <div class="step-content">
                        <h4>Build Probability Distribution</h4>
                        <p>The volumes define a probability measure over graph types. Higher volume means more representative graphs in that stratum.</p>
                    </div>
                </div>
                <div class="algo-step">
                    <div class="step-number">3</div>
                    <div class="step-content">
                        <h4>Recursive Decomposition</h4>
                        <p>Sample by recursively choosing edges and contractions, with probabilities weighted by tropical volumes of sub-graphs.</p>
                    </div>
                </div>
                <div class="algo-step">
                    <div class="step-number">4</div>
                    <div class="step-content">
                        <h4>Assign Edge Lengths</h4>
                        <p>For metric graphs, sample edge lengths from the appropriate distribution on each stratum.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Interactive Sampling Visualization -->
        <div class="interactive-panel">
            <div class="panel-header">
                <span class="panel-title">‚ñ∏ Interactive: Global Tropical Sampling</span>
            </div>
            <div class="canvas-container">
                <canvas id="samplingCanvas"></canvas>
            </div>
            <div class="controls">
                <button class="control-btn active" onclick="setRank(3)">Rank 3</button>
                <button class="control-btn" onclick="setRank(4)">Rank 4</button>
                <button class="control-btn" onclick="setRank(5)">Rank 5</button>
                <button class="control-btn" onclick="setRank(6)">Rank 6</button>
                <button class="control-btn" style="margin-left: auto;" onclick="sampleNew()">Sample New Graph</button>
                <button class="control-btn" onclick="toggleAutoSample()">Auto Sample</button>
            </div>
            <p style="margin-top: 20px; font-size: 0.95rem; color: var(--text-secondary);">
                Watch as graphs are sampled uniformly from the moduli space. Each sample is weighted by 
                tropical volumes‚Äîrare graph types appear less frequently, common ones more often.
            </p>
        </div>

        <section>
            <h2>Complexity Revolution</h2>
            <p>
                The polynomial-time sampling algorithm has profound implications for computational complexity. 
                Traditional perturbative QFT calculations face factorial growth‚Äîbut the tropical approach 
                suggests this barrier might not be fundamental.
            </p>

            <div class="complexity-comparison">
                <div class="complexity-card">
                    <h4>Classical Approach</h4>
                    <div class="complexity-formula" style="color: var(--glow-magenta);">O(n!)</div>
                    <p class="complexity-desc">
                        Enumerate all Feynman diagrams. Time grows faster than exponentially‚Äî
                        utterly impractical beyond small n.
                    </p>
                </div>
                <div class="complexity-card efficient">
                    <h4>Tropical Sampling</h4>
                    <div class="complexity-formula" style="color: var(--glow-emerald);">O(n<sup>k</sup>)</div>
                    <p class="complexity-desc">
                        Polynomial in the loop number. Potentially tractable even for large n‚Äî
                        a fundamental improvement.
                    </p>
                </div>
            </div>

            <div class="callout">
                <div class="callout-title">Speculation: QFT in P?</div>
                <p>
                    Borinsky's work raises a tantalizing possibility: might perturbative QFT calculations 
                    ultimately lie in complexity class P (polynomial time)? The tropical theory provides 
                    an exactly solvable "skeleton"‚Äîperhaps the full theory's corrections can also be 
                    computed efficiently. This remains speculative but represents a potential paradigm 
                    shift in computational physics.
                </p>
            </div>
        </section>

        <!-- Complexity Scaling Visualization -->
        <div class="interactive-panel">
            <div class="panel-header">
                <span class="panel-title">‚ñ∏ Complexity Scaling Comparison</span>
            </div>
            <div class="canvas-container">
                <canvas id="complexityCanvas"></canvas>
            </div>
            <div class="controls">
                <div class="slider-container">
                    <span class="slider-label">Max Loop Order</span>
                    <input type="range" id="loopSlider" min="5" max="20" value="12" onchange="updateComplexity()">
                    <span class="value-display" id="loopValue">12</span>
                </div>
            </div>
            <p style="margin-top: 20px; font-size: 0.95rem; color: var(--text-secondary);">
                The vertical axis is logarithmic. Notice how factorial growth (red) quickly outpaces 
                polynomial growth (green), even for modest loop numbers.
            </p>
        </div>

        <section>
            <h2>What Can We Compute?</h2>
            <p>
                The practical implications are immediate. With polynomial-time sampling, we can now:
            </p>

            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value">10<sup>6</sup></div>
                    <div class="stat-label">Samples per second from ùìúùìñ<sub>n</sub></div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">n ‚â§ 50</div>
                    <div class="stat-label">Practically accessible loop orders</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value">Exact</div>
                    <div class="stat-label">Volume computations (not approximate)</div>
                </div>
            </div>

            <h3>Applications</h3>
            <p>
                The ability to efficiently sample from moduli spaces opens new avenues of investigation:
            </p>
            <p>
                <span class="highlight-text">Cohomology hunting:</span> Instead of exhaustive enumeration, 
                we can Monte Carlo search for the elusive odd-dimensional classes. Sample millions of graphs, 
                check for non-trivial cocycles. The one known class (dimension 11, found by Bartholdi in 2015) 
                took enormous computational effort‚Äîperhaps tropical sampling could find more.
            </p>
            <p>
                <span class="highlight-text">Volume statistics:</span> Understand the shape of moduli space 
                through the distribution of sampled graphs. Which regions have high volume? How does the 
                geometry change with rank?
            </p>
            <p>
                <span class="highlight-text">Physics applications:</span> The tropical integrals provide 
                approximations to actual Feynman integrals. Sampling enables statistical estimation of 
                physical quantities previously beyond computational reach.
            </p>
        </section>

        <!-- Sample Statistics Panel -->
        <div class="interactive-panel">
            <div class="panel-header">
                <span class="panel-title">‚ñ∏ Sample Distribution Visualization</span>
            </div>
            <div class="canvas-container" style="height: 350px;">
                <canvas id="distributionCanvas"></canvas>
            </div>
            <div class="controls">
                <button class="control-btn" onclick="resetDistribution()">Reset Statistics</button>
                <button class="control-btn active" id="accumBtn" onclick="toggleAccumulate()">Accumulating...</button>
            </div>
            <p style="margin-top: 20px; font-size: 0.95rem; color: var(--text-secondary);">
                As samples accumulate, the histogram reveals the true volume distribution over graph types.
                Taller bars indicate higher-volume strata‚Äîmore "common" graph structures.
            </p>
        </div>

        <section>
            <h2>The View From Here</h2>
            <p>
                We've traced an arc from mystery to methodology. The 2023 discovery that moduli spaces 
                contain super-exponentially many cohomology classes seemed to deepen the mystery‚Äîhow could 
                we ever explore such vast spaces? The 2025 tropical breakthrough provides an answer: not 
                by brute force enumeration, but by leveraging exact solvability.
            </p>
            <p>
                The story connects three mathematical worlds: <span class="highlight-text">topology</span> 
                (moduli spaces and cohomology), <span class="highlight-text">physics</span> (quantum field 
                theory and Feynman diagrams), and <span class="highlight-text">computation</span> 
                (complexity classes and algorithms). The bridge between them is tropical geometry‚Äîa 
                crystalline limit where smooth structures become piecewise-linear, and where intractable 
                integrals become exact recursions.
            </p>
            <p>
                Perhaps most remarkably, this story is still being written. We now have tools to explore 
                spaces we could barely imagine a decade ago. What structures will we find? What patterns 
                will emerge from millions of samples? The mathematical ocean before us is infinite, but 
                we finally have a vessel capable of navigating it.
            </p>

            <div class="equation-box" style="border-color: var(--glow-emerald); background: rgba(0, 255, 170, 0.08);">
                <div style="color: var(--glow-emerald); font-size: 1.1rem;">
                    "The tropical limit is not a simplification‚Äîit is a revelation."
                </div>
                <div style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 10px; font-style: italic;">
                    ‚Äî synthesis of Borinsky's insight
                </div>
            </div>
        </section>

        <nav class="essay-nav">
            <a href="essay1_moduli_sea.html" class="nav-link">I ¬∑ Moduli Sea</a>
            <a href="essay2_cohomology.html" class="nav-link">II ¬∑ Cohomology</a>
            <a href="essay3_feynman.html" class="nav-link">III ¬∑ Feynman</a>
            <a href="essay4_tropical.html" class="nav-link">IV ¬∑ Tropical</a>
            <a href="essay5_sampling.html" class="nav-link current">V ¬∑ Sampling</a>
        </nav>
    </div>

    <script>
        // ===== Sampling Canvas =====
        const samplingCanvas = document.getElementById('samplingCanvas');
        const sCtx = samplingCanvas.getContext('2d');
        let currentRank = 3;
        let autoSampling = false;
        let sampledGraph = null;
        let sampleHistory = [];
        const MAX_HISTORY = 8;

        function resizeSamplingCanvas() {
            const container = samplingCanvas.parentElement;
            samplingCanvas.width = container.clientWidth;
            samplingCanvas.height = container.clientHeight;
        }

        // Generate a random graph structure for visualization
        function generateRandomGraph(rank) {
            const numVertices = Math.floor(Math.random() * (rank)) + 2;
            const vertices = [];
            const edges = [];
            
            // Position vertices in a pleasing arrangement
            const centerX = samplingCanvas.width / 2;
            const centerY = samplingCanvas.height / 2;
            const radius = Math.min(samplingCanvas.width, samplingCanvas.height) * 0.25;
            
            for (let i = 0; i < numVertices; i++) {
                const angle = (2 * Math.PI * i / numVertices) - Math.PI / 2;
                const jitter = (Math.random() - 0.5) * 30;
                vertices.push({
                    x: centerX + (radius + jitter) * Math.cos(angle),
                    y: centerY + (radius + jitter) * Math.sin(angle),
                    pulsePhase: Math.random() * Math.PI * 2
                });
            }
            
            // Create edges to achieve desired rank (loops = edges - vertices + 1)
            // Required edges = rank + numVertices - 1
            const requiredEdges = rank + numVertices - 1;
            
            // First, create a spanning tree
            for (let i = 1; i < numVertices; i++) {
                const target = Math.floor(Math.random() * i);
                edges.push({ from: i, to: target, length: Math.random() * 0.8 + 0.2 });
            }
            
            // Add remaining edges to create loops
            let attempts = 0;
            while (edges.length < requiredEdges && attempts < 100) {
                const from = Math.floor(Math.random() * numVertices);
                const to = Math.floor(Math.random() * numVertices);
                if (from !== to) {
                    const exists = edges.some(e => 
                        (e.from === from && e.to === to) || (e.from === to && e.to === from)
                    );
                    if (!exists || edges.length < requiredEdges - 2) {
                        edges.push({ from, to, length: Math.random() * 0.8 + 0.2 });
                    }
                }
                attempts++;
            }
            
            // Self-loops for extra rank if needed
            while (edges.length < requiredEdges) {
                const v = Math.floor(Math.random() * numVertices);
                edges.push({ from: v, to: v, length: Math.random() * 0.5 + 0.3, selfLoop: true });
            }
            
            return { vertices, edges, rank, birthTime: Date.now() };
        }

        function drawSamplingScene() {
            sCtx.fillStyle = 'rgba(6, 8, 15, 0.15)';
            sCtx.fillRect(0, 0, samplingCanvas.width, samplingCanvas.height);
            
            const time = Date.now() / 1000;
            
            // Draw history (faded previous samples)
            sampleHistory.forEach((graph, idx) => {
                const age = (Date.now() - graph.birthTime) / 1000;
                const alpha = Math.max(0, 0.3 - age * 0.05);
                if (alpha > 0) {
                    drawGraph(graph, alpha, idx);
                }
            });
            
            // Draw current graph
            if (sampledGraph) {
                drawGraph(sampledGraph, 1, -1);
            }
            
            // Draw sampling indicator
            if (autoSampling) {
                const pulse = Math.sin(time * 3) * 0.5 + 0.5;
                sCtx.fillStyle = `rgba(0, 255, 170, ${0.3 + pulse * 0.3})`;
                sCtx.beginPath();
                sCtx.arc(50, 50, 10 + pulse * 5, 0, Math.PI * 2);
                sCtx.fill();
                
                sCtx.font = '12px JetBrains Mono';
                sCtx.fillStyle = 'rgba(0, 255, 170, 0.8)';
                sCtx.fillText('SAMPLING...', 70, 55);
            }
            
            requestAnimationFrame(drawSamplingScene);
        }

        function drawGraph(graph, alpha, historyIdx) {
            const time = Date.now() / 1000;
            const offsetX = historyIdx >= 0 ? (historyIdx - MAX_HISTORY/2) * 60 : 0;
            const scale = historyIdx >= 0 ? 0.5 : 1;
            
            // Draw edges
            graph.edges.forEach(edge => {
                const v1 = graph.vertices[edge.from];
                const v2 = graph.vertices[edge.to];
                
                if (edge.selfLoop) {
                    // Draw self-loop
                    sCtx.strokeStyle = `rgba(0, 212, 255, ${alpha * 0.6})`;
                    sCtx.lineWidth = 2 * scale;
                    sCtx.beginPath();
                    const loopRadius = 25 * scale;
                    sCtx.arc(
                        v1.x * scale + offsetX + samplingCanvas.width * (1-scale)/2, 
                        v1.y * scale - loopRadius + samplingCanvas.height * (1-scale)/2, 
                        loopRadius, 0, Math.PI * 2
                    );
                    sCtx.stroke();
                } else {
                    // Draw regular edge
                    const gradient = sCtx.createLinearGradient(
                        v1.x * scale + offsetX + samplingCanvas.width * (1-scale)/2,
                        v1.y * scale + samplingCanvas.height * (1-scale)/2,
                        v2.x * scale + offsetX + samplingCanvas.width * (1-scale)/2,
                        v2.y * scale + samplingCanvas.height * (1-scale)/2
                    );
                    gradient.addColorStop(0, `rgba(0, 212, 255, ${alpha * 0.4})`);
                    gradient.addColorStop(0.5, `rgba(0, 255, 170, ${alpha * 0.7})`);
                    gradient.addColorStop(1, `rgba(0, 212, 255, ${alpha * 0.4})`);
                    
                    sCtx.strokeStyle = gradient;
                    sCtx.lineWidth = (2 + edge.length * 2) * scale;
                    sCtx.beginPath();
                    sCtx.moveTo(
                        v1.x * scale + offsetX + samplingCanvas.width * (1-scale)/2,
                        v1.y * scale + samplingCanvas.height * (1-scale)/2
                    );
                    sCtx.lineTo(
                        v2.x * scale + offsetX + samplingCanvas.width * (1-scale)/2,
                        v2.y * scale + samplingCanvas.height * (1-scale)/2
                    );
                    sCtx.stroke();
                }
            });
            
            // Draw vertices
            graph.vertices.forEach((v, i) => {
                const pulse = Math.sin(time * 2 + v.pulsePhase) * 0.3 + 0.7;
                const vx = v.x * scale + offsetX + samplingCanvas.width * (1-scale)/2;
                const vy = v.y * scale + samplingCanvas.height * (1-scale)/2;
                
                // Glow
                const glow = sCtx.createRadialGradient(vx, vy, 0, vx, vy, 25 * scale);
                glow.addColorStop(0, `rgba(0, 255, 170, ${alpha * pulse * 0.5})`);
                glow.addColorStop(1, 'transparent');
                sCtx.fillStyle = glow;
                sCtx.beginPath();
                sCtx.arc(vx, vy, 25 * scale, 0, Math.PI * 2);
                sCtx.fill();
                
                // Core
                sCtx.fillStyle = `rgba(0, 255, 170, ${alpha})`;
                sCtx.beginPath();
                sCtx.arc(vx, vy, 6 * scale, 0, Math.PI * 2);
                sCtx.fill();
            });
            
            // Draw rank indicator
            if (historyIdx < 0) {
                sCtx.font = '14px JetBrains Mono';
                sCtx.fillStyle = `rgba(0, 255, 170, ${alpha * 0.8})`;
                sCtx.fillText(`Rank ${graph.rank}`, samplingCanvas.width - 100, 40);
                sCtx.fillText(`Vertices: ${graph.vertices.length}`, samplingCanvas.width - 100, 60);
                sCtx.fillText(`Edges: ${graph.edges.length}`, samplingCanvas.width - 100, 80);
            }
        }

        function sampleNew() {
            if (sampledGraph) {
                sampleHistory.unshift(sampledGraph);
                if (sampleHistory.length > MAX_HISTORY) {
                    sampleHistory.pop();
                }
            }
            sampledGraph = generateRandomGraph(currentRank);
            updateDistributionFromSample();
        }

        function setRank(r) {
            currentRank = r;
            document.querySelectorAll('.controls .control-btn').forEach((btn, i) => {
                if (i < 4) btn.classList.toggle('active', parseInt(btn.textContent.split(' ')[1]) === r);
            });
            sampleNew();
        }

        let autoInterval = null;
        function toggleAutoSample() {
            autoSampling = !autoSampling;
            if (autoSampling) {
                autoInterval = setInterval(sampleNew, 800);
            } else {
                clearInterval(autoInterval);
            }
        }

        // ===== Complexity Canvas =====
        const complexityCanvas = document.getElementById('complexityCanvas');
        const cCtx = complexityCanvas.getContext('2d');

        function resizeComplexityCanvas() {
            const container = complexityCanvas.parentElement;
            complexityCanvas.width = container.clientWidth;
            complexityCanvas.height = container.clientHeight;
        }

        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) result *= i;
            return result;
        }

        function drawComplexityChart() {
            const maxN = parseInt(document.getElementById('loopSlider').value);
            document.getElementById('loopValue').textContent = maxN;
            
            cCtx.fillStyle = 'rgba(6, 8, 15, 1)';
            cCtx.fillRect(0, 0, complexityCanvas.width, complexityCanvas.height);
            
            const padding = { left: 80, right: 40, top: 40, bottom: 60 };
            const chartWidth = complexityCanvas.width - padding.left - padding.right;
            const chartHeight = complexityCanvas.height - padding.top - padding.bottom;
            
            // Calculate max values for scaling
            const factorialMax = factorial(maxN);
            const polyMax = Math.pow(maxN, 4);
            const logMax = Math.log10(factorialMax);
            
            // Draw grid
            cCtx.strokeStyle = 'rgba(0, 255, 170, 0.1)';
            cCtx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) {
                const y = padding.top + (chartHeight * i / 10);
                cCtx.beginPath();
                cCtx.moveTo(padding.left, y);
                cCtx.lineTo(complexityCanvas.width - padding.right, y);
                cCtx.stroke();
            }
            
            // Draw axes
            cCtx.strokeStyle = 'rgba(0, 255, 170, 0.5)';
            cCtx.lineWidth = 2;
            cCtx.beginPath();
            cCtx.moveTo(padding.left, padding.top);
            cCtx.lineTo(padding.left, complexityCanvas.height - padding.bottom);
            cCtx.lineTo(complexityCanvas.width - padding.right, complexityCanvas.height - padding.bottom);
            cCtx.stroke();
            
            // Labels
            cCtx.font = '12px JetBrains Mono';
            cCtx.fillStyle = 'rgba(0, 255, 170, 0.7)';
            cCtx.fillText('log‚ÇÅ‚ÇÄ(operations)', 10, padding.top + chartHeight/2);
            cCtx.fillText('loop order n', complexityCanvas.width/2, complexityCanvas.height - 15);
            
            // Y-axis labels
            for (let i = 0; i <= 5; i++) {
                const logVal = (logMax * (5-i) / 5).toFixed(0);
                const y = padding.top + (chartHeight * i / 5);
                cCtx.fillText(logVal, padding.left - 35, y + 4);
            }
            
            // X-axis labels
            for (let n = 1; n <= maxN; n += Math.max(1, Math.floor(maxN/10))) {
                const x = padding.left + (chartWidth * (n-1) / (maxN-1));
                cCtx.fillText(n.toString(), x - 5, complexityCanvas.height - padding.bottom + 20);
            }
            
            // Draw factorial curve (red/magenta)
            cCtx.strokeStyle = '#ff006e';
            cCtx.lineWidth = 3;
            cCtx.beginPath();
            for (let n = 1; n <= maxN; n++) {
                const x = padding.left + (chartWidth * (n-1) / (maxN-1));
                const logVal = Math.log10(factorial(n));
                const y = padding.top + chartHeight * (1 - logVal / logMax);
                if (n === 1) cCtx.moveTo(x, y);
                else cCtx.lineTo(x, y);
            }
            cCtx.stroke();
            
            // Draw polynomial curve (green/emerald)
            cCtx.strokeStyle = '#00ffaa';
            cCtx.lineWidth = 3;
            cCtx.beginPath();
            for (let n = 1; n <= maxN; n++) {
                const x = padding.left + (chartWidth * (n-1) / (maxN-1));
                const logVal = Math.log10(Math.pow(n, 4));
                const y = padding.top + chartHeight * (1 - logVal / logMax);
                if (n === 1) cCtx.moveTo(x, y);
                else cCtx.lineTo(x, y);
            }
            cCtx.stroke();
            
            // Legend
            const legendX = complexityCanvas.width - 180;
            const legendY = padding.top + 20;
            
            cCtx.fillStyle = 'rgba(10, 15, 25, 0.9)';
            cCtx.fillRect(legendX - 10, legendY - 10, 160, 60);
            
            cCtx.strokeStyle = '#ff006e';
            cCtx.lineWidth = 3;
            cCtx.beginPath();
            cCtx.moveTo(legendX, legendY + 10);
            cCtx.lineTo(legendX + 30, legendY + 10);
            cCtx.stroke();
            cCtx.fillStyle = '#ff006e';
            cCtx.fillText('O(n!) Classical', legendX + 40, legendY + 14);
            
            cCtx.strokeStyle = '#00ffaa';
            cCtx.beginPath();
            cCtx.moveTo(legendX, legendY + 35);
            cCtx.lineTo(legendX + 30, legendY + 35);
            cCtx.stroke();
            cCtx.fillStyle = '#00ffaa';
            cCtx.fillText('O(n‚Å¥) Tropical', legendX + 40, legendY + 39);
        }

        function updateComplexity() {
            drawComplexityChart();
        }

        // ===== Distribution Canvas =====
        const distributionCanvas = document.getElementById('distributionCanvas');
        const dCtx = distributionCanvas.getContext('2d');
        let distribution = {};
        let isAccumulating = true;

        function resizeDistributionCanvas() {
            const container = distributionCanvas.parentElement;
            distributionCanvas.width = container.clientWidth;
            distributionCanvas.height = container.clientHeight;
        }

        function updateDistributionFromSample() {
            if (!isAccumulating || !sampledGraph) return;
            
            const key = `V${sampledGraph.vertices.length}E${sampledGraph.edges.length}`;
            distribution[key] = (distribution[key] || 0) + 1;
            drawDistribution();
        }

        function drawDistribution() {
            dCtx.fillStyle = 'rgba(6, 8, 15, 1)';
            dCtx.fillRect(0, 0, distributionCanvas.width, distributionCanvas.height);
            
            const keys = Object.keys(distribution).sort();
            if (keys.length === 0) {
                dCtx.font = '14px JetBrains Mono';
                dCtx.fillStyle = 'rgba(0, 255, 170, 0.5)';
                dCtx.fillText('Sample graphs to build distribution...', 50, distributionCanvas.height/2);
                return;
            }
            
            const padding = { left: 60, right: 40, top: 40, bottom: 80 };
            const chartWidth = distributionCanvas.width - padding.left - padding.right;
            const chartHeight = distributionCanvas.height - padding.top - padding.bottom;
            
            const maxCount = Math.max(...Object.values(distribution));
            const barWidth = Math.min(60, (chartWidth / keys.length) - 10);
            
            // Draw axes
            dCtx.strokeStyle = 'rgba(0, 255, 170, 0.5)';
            dCtx.lineWidth = 2;
            dCtx.beginPath();
            dCtx.moveTo(padding.left, padding.top);
            dCtx.lineTo(padding.left, distributionCanvas.height - padding.bottom);
            dCtx.lineTo(distributionCanvas.width - padding.right, distributionCanvas.height - padding.bottom);
            dCtx.stroke();
            
            // Y-axis label
            dCtx.font = '12px JetBrains Mono';
            dCtx.fillStyle = 'rgba(0, 255, 170, 0.7)';
            dCtx.fillText('count', 10, padding.top + chartHeight/2);
            
            // Draw bars
            keys.forEach((key, i) => {
                const count = distribution[key];
                const x = padding.left + 20 + (i * (chartWidth / keys.length));
                const barHeight = (count / maxCount) * chartHeight;
                const y = distributionCanvas.height - padding.bottom - barHeight;
                
                // Gradient bar
                const gradient = dCtx.createLinearGradient(x, y, x, distributionCanvas.height - padding.bottom);
                gradient.addColorStop(0, 'rgba(0, 255, 170, 0.9)');
                gradient.addColorStop(1, 'rgba(136, 68, 255, 0.6)');
                
                dCtx.fillStyle = gradient;
                dCtx.fillRect(x, y, barWidth, barHeight);
                
                // Glow effect
                dCtx.shadowColor = '#00ffaa';
                dCtx.shadowBlur = 10;
                dCtx.fillRect(x, y, barWidth, 2);
                dCtx.shadowBlur = 0;
                
                // Label
                dCtx.save();
                dCtx.translate(x + barWidth/2, distributionCanvas.height - padding.bottom + 15);
                dCtx.rotate(-Math.PI/4);
                dCtx.font = '10px JetBrains Mono';
                dCtx.fillStyle = 'rgba(0, 255, 170, 0.7)';
                dCtx.fillText(key, 0, 0);
                dCtx.restore();
                
                // Count on top
                if (barHeight > 20) {
                    dCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    dCtx.fillText(count.toString(), x + barWidth/2 - 8, y - 5);
                }
            });
            
            // Total samples
            const total = Object.values(distribution).reduce((a, b) => a + b, 0);
            dCtx.font = '14px JetBrains Mono';
            dCtx.fillStyle = 'rgba(0, 255, 170, 0.8)';
            dCtx.fillText(`Total samples: ${total}`, distributionCanvas.width - 180, padding.top);
        }

        function resetDistribution() {
            distribution = {};
            drawDistribution();
        }

        function toggleAccumulate() {
            isAccumulating = !isAccumulating;
            const btn = document.getElementById('accumBtn');
            btn.textContent = isAccumulating ? 'Accumulating...' : 'Paused';
            btn.classList.toggle('active', isAccumulating);
        }

        // ===== Initialization =====
        function init() {
            resizeSamplingCanvas();
            resizeComplexityCanvas();
            resizeDistributionCanvas();
            
            sampledGraph = generateRandomGraph(currentRank);
            
            drawSamplingScene();
            drawComplexityChart();
            drawDistribution();
        }

        window.addEventListener('resize', () => {
            resizeSamplingCanvas();
            resizeComplexityCanvas();
            resizeDistributionCanvas();
            drawComplexityChart();
            drawDistribution();
        });

        window.addEventListener('load', init);
    </script>
</body>
</html>
