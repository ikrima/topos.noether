<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Tropical Revolution</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --deep-void: #0a0a12;
            --glow-cyan: #00d4ff;
            --glow-magenta: #ff006e;
            --glow-gold: #ffd700;
            --glow-orange: #ff8c00;
            --glow-green: #00ff88;
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: var(--deep-void);
            color: var(--text-primary);
            line-height: 1.7;
            overflow-x: hidden;
        }

        /* Tropical gradient background */
        .tropical-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(ellipse at 20% 80%, rgba(255, 140, 0, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 20%, rgba(255, 215, 0, 0.08) 0%, transparent 50%),
                var(--deep-void);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 60px 40px;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 80px;
            animation: fadeInDown 1s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .series-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: var(--glow-orange);
            margin-bottom: 20px;
            display: inline-block;
            padding: 8px 16px;
            border: 1px solid rgba(255, 140, 0, 0.3);
            background: rgba(255, 140, 0, 0.05);
        }

        h1 {
            font-size: clamp(2.5rem, 6vw, 4rem);
            font-weight: 400;
            margin-bottom: 24px;
            background: linear-gradient(135deg, var(--glow-gold) 0%, var(--glow-orange) 50%, var(--glow-magenta) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.4rem;
            font-style: italic;
            color: var(--text-secondary);
            max-width: 680px;
            margin: 0 auto;
        }

        section { margin-bottom: 100px; }

        h2 {
            font-size: 2rem;
            font-weight: 400;
            margin-bottom: 30px;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        h2::before {
            content: '';
            width: 40px;
            height: 2px;
            background: linear-gradient(90deg, var(--glow-orange), transparent);
        }

        p {
            font-size: 1.2rem;
            margin-bottom: 24px;
            max-width: 800px;
        }

        .highlight { color: var(--glow-cyan); font-weight: 600; }
        .highlight-orange { color: var(--glow-orange); font-weight: 600; }
        .highlight-gold { color: var(--glow-gold); font-weight: 600; }

        .formula {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            background: rgba(255, 140, 0, 0.08);
            padding: 4px 12px;
            border-radius: 4px;
            border-left: 3px solid var(--glow-orange);
            display: inline-block;
        }

        .canvas-container {
            background: linear-gradient(180deg, rgba(13, 17, 23, 0.9) 0%, rgba(26, 26, 46, 0.9) 100%);
            border: 1px solid rgba(255, 140, 0, 0.2);
            border-radius: 12px;
            padding: 30px;
            margin: 40px 0;
            position: relative;
        }

        .canvas-container::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--glow-orange), transparent);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 8px;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 200px;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 140, 0, 0.2);
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--glow-orange);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 15px var(--glow-orange);
        }

        button {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            padding: 12px 24px;
            background: transparent;
            border: 1px solid var(--glow-orange);
            color: var(--glow-orange);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            background: var(--glow-orange);
            color: var(--deep-void);
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.4);
        }

        .quote-block {
            border-left: 3px solid var(--glow-gold);
            padding: 20px 30px;
            margin: 40px 0;
            background: rgba(255, 215, 0, 0.05);
            font-style: italic;
            font-size: 1.3rem;
        }

        .quote-attribution {
            font-style: normal;
            font-size: 0.95rem;
            color: var(--text-secondary);
            margin-top: 15px;
        }

        /* Tropical arithmetic demonstration */
        .arithmetic-demo {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 40px;
            margin: 40px 0;
        }

        .arithmetic-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 25px;
            border: 1px solid rgba(136, 136, 160, 0.2);
        }

        .arithmetic-panel h3 {
            font-size: 1.3rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .arithmetic-panel.classical h3 { color: var(--glow-cyan); }
        .arithmetic-panel.tropical h3 { color: var(--glow-orange); }

        .operation {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.2rem;
        }

        .op-symbol {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 1.5rem;
        }

        .classical .op-symbol { background: rgba(0, 212, 255, 0.2); color: var(--glow-cyan); }
        .tropical .op-symbol { background: rgba(255, 140, 0, 0.2); color: var(--glow-orange); }

        /* Key insight boxes */
        .insight-box {
            background: linear-gradient(135deg, rgba(255, 140, 0, 0.1) 0%, rgba(255, 215, 0, 0.05) 100%);
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
        }

        .insight-box h4 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--glow-gold);
            margin-bottom: 15px;
            letter-spacing: 0.1em;
        }

        /* Recursion visualization */
        .recursion-tree {
            display: flex;
            justify-content: center;
            padding: 30px;
        }

        /* Timeline */
        .timeline {
            position: relative;
            padding-left: 30px;
            border-left: 2px solid rgba(255, 140, 0, 0.3);
        }

        .timeline-item {
            position: relative;
            padding-bottom: 30px;
        }

        .timeline-item::before {
            content: '';
            position: absolute;
            left: -36px;
            top: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--glow-orange);
            box-shadow: 0 0 15px var(--glow-orange);
        }

        .timeline-year {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--glow-gold);
            margin-bottom: 5px;
        }

        .timeline-title {
            font-size: 1.2rem;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .timeline-desc {
            color: var(--text-secondary);
            font-size: 1rem;
        }

        .nav-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 100px;
            padding-top: 40px;
            border-top: 1px solid rgba(136, 136, 160, 0.2);
        }

        .nav-link {
            color: var(--glow-orange);
            text-decoration: none;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .nav-link:hover {
            text-shadow: 0 0 20px var(--glow-orange);
        }

        @media (max-width: 800px) {
            .arithmetic-demo { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="tropical-bg"></div>

    <div class="container">
        <header class="header">
            <div class="series-tag">Essay IV of V ‚Ä¢ The Tropical Limit</div>
            <h1>The Tropical Revolution</h1>
            <p class="subtitle">How replacing ordinary arithmetic with "max" and "+" transforms intractable problems into exactly solvable ones‚Äîand reveals deep connections to Mirzakhani's work</p>
        </header>

        <section>
            <h2>A Different Kind of Arithmetic</h2>
            <p>
                Tropical geometry begins with a radical idea: <span class="highlight-orange">replace addition with 
                maximum</span>, and <span class="highlight-orange">replace multiplication with addition</span>. 
                This seemingly strange substitution has profound consequences.
            </p>
            <p>
                In the <span class="highlight-gold">tropical semiring</span> (named after Brazilian computer scientist 
                Imre Simon), the operations are:
            </p>

            <div class="arithmetic-demo">
                <div class="arithmetic-panel classical">
                    <h3>üìê Classical Arithmetic</h3>
                    <div class="operation">
                        <span class="op-symbol">+</span>
                        <span>3 + 5 = 8</span>
                    </div>
                    <div class="operation">
                        <span class="op-symbol">√ó</span>
                        <span>3 √ó 5 = 15</span>
                    </div>
                    <div class="operation">
                        <span class="op-symbol">x¬≤</span>
                        <span>x¬≤ = x √ó x</span>
                    </div>
                </div>
                <div class="arithmetic-panel tropical">
                    <h3>üå¥ Tropical Arithmetic</h3>
                    <div class="operation">
                        <span class="op-symbol">‚äï</span>
                        <span>3 ‚äï 5 = max(3,5) = 5</span>
                    </div>
                    <div class="operation">
                        <span class="op-symbol">‚äô</span>
                        <span>3 ‚äô 5 = 3 + 5 = 8</span>
                    </div>
                    <div class="operation">
                        <span class="op-symbol">x¬≤</span>
                        <span>x¬≤ = x ‚äô x = 2x</span>
                    </div>
                </div>
            </div>

            <p>
                Under tropical arithmetic, polynomials become <span class="highlight">piecewise linear functions</span>. 
                Smooth curves become sharp, crystalline structures. The complex becomes tractable.
            </p>
        </section>

        <section>
            <h2>Tropicalization: The Œæ ‚Üí 0 Limit</h2>
            <p>
                How do we connect tropical geometry to quantum field theory? Borinsky introduces a 
                <span class="highlight-orange">deformation parameter Œæ</span>. As Œæ approaches zero, 
                the "tropical limit" emerges:
            </p>

            <div class="canvas-container">
                <canvas id="tropicalLimit" width="800" height="400"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Deformation Parameter Œæ</label>
                        <input type="range" id="xiSlider" min="1" max="100" value="100">
                        <span id="xiValue" style="color: var(--glow-gold); font-family: 'JetBrains Mono'; margin-left: 10px;">Œæ = 1.00</span>
                    </div>
                    <button id="animateXi">Animate Limit</button>
                </div>
            </div>

            <p>
                Watch how a smooth curve "crystallizes" into piecewise linear segments as Œæ ‚Üí 0. 
                This is the essence of tropicalization: smooth ‚Üí sharp, continuous ‚Üí combinatorial.
            </p>

            <div class="insight-box">
                <h4>üîë Key Insight</h4>
                <p>
                    In the tropical limit, the action functional of scalar QFT becomes:
                </p>
                <p style="text-align: center; margin: 20px 0;">
                    <span class="formula">S<sub>Œæ‚Üí0</sub>[Œ¶] = max over all Feynman graphs</span>
                </p>
                <p>
                    The "max" operation from tropical arithmetic naturally emerges! This transforms the 
                    complicated sum over diagrams into a simpler maximization problem.
                </p>
            </div>
        </section>

        <section>
            <h2>Exact Solvability</h2>
            <p>
                The most remarkable discovery: <span class="highlight-gold">tropicalized massive scalar QFT is 
                exactly solvable</span>. The expansion coefficients of the quantum effective action satisfy 
                a non-linear recursion equation.
            </p>
            <p>
                This recursion computes <span class="highlight">volumes of moduli spaces of metric graphs</span>‚Äîdirectly 
                analogous to Maryam Mirzakhani's celebrated volume recursions for the moduli space of curves.
            </p>

            <div class="canvas-container">
                <canvas id="recursionViz" width="800" height="350"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Recursion Depth</label>
                        <input type="range" id="depthSlider" min="1" max="6" value="3">
                    </div>
                </div>
            </div>

            <div class="quote-block">
                "This exact solution manifests as a non-linear recursion equation fulfilled by the 
                expansion coefficients of the quantum effective action. Geometrically, this recursion 
                computes specific volumes of moduli spaces of metric graphs and is thereby analogous 
                to Mirzakhani's volume recursions on the moduli space of curves."
                <div class="quote-attribution">‚Äî Michael Borinsky, arXiv:2508.14263</div>
            </div>
        </section>

        <section>
            <h2>From Curves to Graphs: The Mirzakhani Connection</h2>
            <p>
                Maryam Mirzakhani, the first woman to win the Fields Medal, discovered recursive 
                formulas for computing volumes of moduli spaces of hyperbolic surfaces. Her work 
                revealed deep structure in how Riemann surfaces are organized.
            </p>
            <p>
                Borinsky's tropical recursion is the <span class="highlight-orange">graph-theoretic 
                analog</span>. Where Mirzakhani computed volumes parametrizing curves, Borinsky 
                computes volumes parametrizing graphs.
            </p>

            <div class="canvas-container">
                <canvas id="curveToGraph" width="800" height="300"></canvas>
                <div class="controls">
                    <button id="showCurve">Riemann Surface</button>
                    <button id="showGraph" class="active">Tropical Graph</button>
                    <button id="showTransition">Show Transition</button>
                </div>
            </div>

            <p>
                Tropical geometry provides the bridge: as algebraic curves degenerate, they become 
                <span class="highlight-gold">metric graphs</span>. The moduli space of tropical curves 
                is closely related to the moduli space of graphs we've been studying.
            </p>
        </section>

        <section>
            <h2>The Three-Layer Cake</h2>
            <p>
                Borinsky's framework introduces an elegant <span class="highlight-orange">three-layer 
                structure</span> for understanding quantum field theory:
            </p>

            <div class="timeline">
                <div class="timeline-item">
                    <div class="timeline-year">Layer 1: Free Theory</div>
                    <div class="timeline-title">No Interactions</div>
                    <div class="timeline-desc">
                        Particles propagate without interacting. Exactly solvable, but physically trivial.
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">Layer 2: Tropicalized Theory</div>
                    <div class="timeline-title">The New Middle Ground</div>
                    <div class="timeline-desc">
                        Interactions exist, but in "crystallized" form. <strong>Exactly solvable</strong> via 
                        recursion! This is Borinsky's breakthrough.
                    </div>
                </div>
                <div class="timeline-item">
                    <div class="timeline-year">Layer 3: Full Interacting Theory</div>
                    <div class="timeline-title">The Real World</div>
                    <div class="timeline-desc">
                        Full quantum field theory. Computationally intractable by direct methods, but 
                        the tropicalized layer provides a scaffold for approximation.
                    </div>
                </div>
            </div>
        </section>

        <section>
            <h2>Tropical Curves in Action</h2>
            <p>
                A tropical curve is a metric graph‚Äîvertices connected by edges with real-valued lengths. 
                Where classical algebraic curves are smooth and continuous, tropical curves are 
                <span class="highlight-gold">piecewise linear</span>.
            </p>

            <div class="canvas-container">
                <canvas id="tropicalCurve" width="800" height="400"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Edge Lengths</label>
                        <input type="range" id="lengthSlider" min="20" max="100" value="60">
                    </div>
                    <div class="control-group">
                        <label>Complexity</label>
                        <input type="range" id="complexitySlider" min="1" max="4" value="2">
                    </div>
                </div>
            </div>

            <p>
                Interactive: drag the slider to morph the tropical curve. Notice how the piecewise 
                linear structure is preserved‚Äîonly the edge lengths change. This is the essence of 
                the moduli space of tropical curves.
            </p>
        </section>

        <section>
            <h2>Why Tropical?</h2>
            <p>
                The name "tropical" honors Imre Simon, a Hungarian-Brazilian computer scientist who 
                worked in S√£o Paulo. (The tropics of Brazil, not tropical beaches!) Simon studied 
                these semiring structures in the context of automata theory in the 1980s.
            </p>
            <p>
                But the ideas go back further‚Äîto <span class="highlight">Maslov's idempotent analysis</span> 
                and the <span class="highlight-orange">Legendre transformation</span> in physics. 
                The tropical limit appears naturally wherever optimization meets geometry.
            </p>

            <div class="insight-box">
                <h4>üå¥ Applications of Tropical Geometry</h4>
                <p>Beyond QFT, tropical methods appear in:</p>
                <p style="margin-top: 15px;">
                    ‚Ä¢ <span class="highlight">Enumerative geometry</span> ‚Äî counting curves on surfaces<br>
                    ‚Ä¢ <span class="highlight-orange">Optimization</span> ‚Äî shortest paths, scheduling<br>
                    ‚Ä¢ <span class="highlight-gold">Phylogenetics</span> ‚Äî evolutionary tree reconstruction<br>
                    ‚Ä¢ <span class="highlight">String theory</span> ‚Äî simplifying amplitudes<br>
                    ‚Ä¢ <span class="highlight-orange">Mirror symmetry</span> ‚Äî connecting different string theories
                </p>
            </div>
        </section>

        <nav class="nav-footer">
            <a href="#" class="nav-link">‚Üê Previous: Feynman Diagrams</a>
            <span style="color: var(--text-secondary);">Essay IV of V</span>
            <a href="#" class="nav-link">Next: Polynomial Sampling ‚Üí</a>
        </nav>
    </div>

    <script>
        // Tropical limit visualization
        const limitCanvas = document.getElementById('tropicalLimit');
        const limitCtx = limitCanvas.getContext('2d');
        const xiSlider = document.getElementById('xiSlider');
        const xiValue = document.getElementById('xiValue');
        let animatingXi = false;

        function smoothMax(a, b, xi) {
            // Smooth approximation to max(a, b) that becomes exact as xi -> 0
            if (xi < 0.01) return Math.max(a, b);
            return xi * Math.log(Math.exp(a/xi) + Math.exp(b/xi));
        }

        function tropicalPoly(x, xi) {
            // Tropical polynomial: x^2 ‚äï 2x ‚äï 3 becomes max(2x, x+2, 3) at xi=0
            const term1 = 2 * x;
            const term2 = x + 2;
            const term3 = 3;
            
            if (xi < 0.01) {
                return Math.max(term1, term2, term3);
            }
            
            // Smooth interpolation
            const classical = 0.05 * x * x + 0.5 * x + 2;
            const tropical = Math.max(term1, term2, term3);
            const blend = xi / 100;
            return classical * blend + tropical * (1 - blend);
        }

        function drawTropicalLimit() {
            const xi = parseFloat(xiSlider.value) / 100;
            xiValue.textContent = `Œæ = ${xi.toFixed(2)}`;
            
            limitCtx.clearRect(0, 0, limitCanvas.width, limitCanvas.height);
            
            // Draw grid
            limitCtx.strokeStyle = 'rgba(136, 136, 160, 0.1)';
            limitCtx.lineWidth = 1;
            for (let i = 0; i <= 8; i++) {
                limitCtx.beginPath();
                limitCtx.moveTo(100 + i * 75, 50);
                limitCtx.lineTo(100 + i * 75, 350);
                limitCtx.stroke();
                limitCtx.beginPath();
                limitCtx.moveTo(100, 50 + i * 37.5);
                limitCtx.lineTo(700, 50 + i * 37.5);
                limitCtx.stroke();
            }
            
            // Draw the curve
            const gradient = limitCtx.createLinearGradient(100, 0, 700, 0);
            gradient.addColorStop(0, '#ff8c00');
            gradient.addColorStop(0.5, '#ffd700');
            gradient.addColorStop(1, '#ff006e');
            
            limitCtx.strokeStyle = gradient;
            limitCtx.lineWidth = 3;
            limitCtx.shadowBlur = 15;
            limitCtx.shadowColor = '#ff8c00';
            limitCtx.beginPath();
            
            for (let px = 100; px <= 700; px++) {
                const x = (px - 100) / 100 - 3; // x from -3 to 3
                const y = tropicalPoly(x, xi);
                const py = 350 - y * 40;
                
                if (px === 100) limitCtx.moveTo(px, py);
                else limitCtx.lineTo(px, py);
            }
            limitCtx.stroke();
            
            // Draw the asymptotic lines when tropical
            if (xi < 0.3) {
                limitCtx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
                limitCtx.lineWidth = 1;
                limitCtx.setLineDash([5, 5]);
                limitCtx.shadowBlur = 0;
                
                // Line: y = 2x
                limitCtx.beginPath();
                limitCtx.moveTo(100, 350 - (-3 * 2) * 40);
                limitCtx.lineTo(700, 350 - (3 * 2) * 40);
                limitCtx.stroke();
                
                // Line: y = x + 2
                limitCtx.beginPath();
                limitCtx.moveTo(100, 350 - (-3 + 2) * 40);
                limitCtx.lineTo(700, 350 - (3 + 2) * 40);
                limitCtx.stroke();
                
                // Line: y = 3
                limitCtx.beginPath();
                limitCtx.moveTo(100, 350 - 3 * 40);
                limitCtx.lineTo(700, 350 - 3 * 40);
                limitCtx.stroke();
                
                limitCtx.setLineDash([]);
            }
            
            // Labels
            limitCtx.shadowBlur = 0;
            limitCtx.fillStyle = xi < 0.3 ? '#ff8c00' : '#00d4ff';
            limitCtx.font = '14px "JetBrains Mono", monospace';
            limitCtx.fillText(xi < 0.3 ? 'TROPICAL (piecewise linear)' : 'CLASSICAL (smooth)', 300, 30);
        }

        xiSlider.addEventListener('input', drawTropicalLimit);

        document.getElementById('animateXi').addEventListener('click', () => {
            if (animatingXi) return;
            animatingXi = true;
            let val = 100;
            const animate = () => {
                val -= 1;
                xiSlider.value = val;
                drawTropicalLimit();
                if (val > 1) {
                    requestAnimationFrame(animate);
                } else {
                    animatingXi = false;
                }
            };
            animate();
        });

        drawTropicalLimit();

        // Recursion visualization
        const recursionCanvas = document.getElementById('recursionViz');
        const recursionCtx = recursionCanvas.getContext('2d');
        const depthSlider = document.getElementById('depthSlider');

        function drawRecursionTree(ctx, x, y, depth, maxDepth, angle, length) {
            if (depth > maxDepth) return;
            
            const endX = x + Math.cos(angle) * length;
            const endY = y + Math.sin(angle) * length;
            
            // Draw branch
            const alpha = 1 - depth / (maxDepth + 1) * 0.5;
            ctx.strokeStyle = `rgba(255, 140, 0, ${alpha})`;
            ctx.lineWidth = Math.max(1, 4 - depth);
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff8c00';
            
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(endX, endY);
            ctx.stroke();
            
            // Node
            ctx.fillStyle = depth === maxDepth ? '#ffd700' : '#ff8c00';
            ctx.beginPath();
            ctx.arc(endX, endY, 6 - depth * 0.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Recurse
            const spread = 0.5;
            const shrink = 0.7;
            drawRecursionTree(ctx, endX, endY, depth + 1, maxDepth, angle - spread, length * shrink);
            drawRecursionTree(ctx, endX, endY, depth + 1, maxDepth, angle + spread, length * shrink);
        }

        function drawRecursion() {
            const depth = parseInt(depthSlider.value);
            recursionCtx.clearRect(0, 0, recursionCanvas.width, recursionCanvas.height);
            
            // Title
            recursionCtx.shadowBlur = 0;
            recursionCtx.fillStyle = '#8888a0';
            recursionCtx.font = '14px "JetBrains Mono", monospace';
            recursionCtx.textAlign = 'center';
            recursionCtx.fillText(`Recursion depth: ${depth}`, 400, 30);
            recursionCtx.fillText('Each branch represents a term in the volume recursion', 400, 50);
            
            // Draw tree
            drawRecursionTree(recursionCtx, 400, 320, 0, depth, -Math.PI/2, 80);
        }

        depthSlider.addEventListener('input', drawRecursion);
        drawRecursion();

        // Curve to Graph transition
        const ctgCanvas = document.getElementById('curveToGraph');
        const ctgCtx = ctgCanvas.getContext('2d');
        let ctgMode = 'graph';
        let transitionProgress = 0;
        let isTransitioning = false;

        document.getElementById('showCurve').addEventListener('click', () => {
            ctgMode = 'curve';
            drawCTG();
        });

        document.getElementById('showGraph').addEventListener('click', () => {
            ctgMode = 'graph';
            drawCTG();
        });

        document.getElementById('showTransition').addEventListener('click', () => {
            if (isTransitioning) return;
            isTransitioning = true;
            transitionProgress = 0;
            const animate = () => {
                transitionProgress += 0.02;
                drawCTG();
                if (transitionProgress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    isTransitioning = false;
                }
            };
            animate();
        });

        function drawCTG() {
            ctgCtx.clearRect(0, 0, ctgCanvas.width, ctgCanvas.height);
            
            const t = isTransitioning ? transitionProgress : (ctgMode === 'curve' ? 0 : 1);
            
            if (t < 0.5) {
                // Draw Riemann surface (genus 2)
                const smoothness = 1 - t * 2;
                
                ctgCtx.strokeStyle = '#00d4ff';
                ctgCtx.lineWidth = 3;
                ctgCtx.shadowBlur = 15;
                ctgCtx.shadowColor = '#00d4ff';
                
                // Draw figure-8 like shape
                ctgCtx.beginPath();
                for (let angle = 0; angle <= Math.PI * 2; angle += 0.05) {
                    const r = 80 + 30 * Math.sin(2 * angle) * smoothness;
                    const x = 300 + r * Math.cos(angle);
                    const y = 150 + r * Math.sin(angle) * 0.6;
                    if (angle === 0) ctgCtx.moveTo(x, y);
                    else ctgCtx.lineTo(x, y);
                }
                ctgCtx.closePath();
                ctgCtx.stroke();
                
                // Second hole
                ctgCtx.beginPath();
                for (let angle = 0; angle <= Math.PI * 2; angle += 0.05) {
                    const r = 80 + 30 * Math.sin(2 * angle + Math.PI) * smoothness;
                    const x = 500 + r * Math.cos(angle);
                    const y = 150 + r * Math.sin(angle) * 0.6;
                    if (angle === 0) ctgCtx.moveTo(x, y);
                    else ctgCtx.lineTo(x, y);
                }
                ctgCtx.closePath();
                ctgCtx.stroke();
                
                ctgCtx.fillStyle = '#00d4ff';
                ctgCtx.font = '16px "JetBrains Mono", monospace';
                ctgCtx.textAlign = 'center';
                ctgCtx.shadowBlur = 0;
                ctgCtx.fillText('Riemann Surface (genus 2)', 400, 280);
            } else {
                // Draw tropical graph
                const sharpness = (t - 0.5) * 2;
                
                ctgCtx.strokeStyle = '#ff8c00';
                ctgCtx.lineWidth = 3;
                ctgCtx.shadowBlur = 15;
                ctgCtx.shadowColor = '#ff8c00';
                
                // Vertices
                const vertices = [
                    [250, 150], [350, 150], [450, 150], [550, 150],
                    [300, 100], [400, 100], [500, 100],
                    [300, 200], [400, 200], [500, 200]
                ];
                
                // Edges (forming two loops)
                const edges = [
                    [0, 1], [1, 2], [2, 3],
                    [0, 4], [4, 1], [1, 5], [5, 2], [2, 6], [6, 3],
                    [0, 7], [7, 1], [1, 8], [8, 2], [2, 9], [9, 3]
                ];
                
                edges.forEach(([i, j]) => {
                    const blend = sharpness;
                    // Interpolate between curved and straight
                    ctgCtx.beginPath();
                    ctgCtx.moveTo(vertices[i][0], vertices[i][1]);
                    
                    if (blend < 1) {
                        const midX = (vertices[i][0] + vertices[j][0]) / 2;
                        const midY = (vertices[i][1] + vertices[j][1]) / 2;
                        const curve = 20 * (1 - blend);
                        ctgCtx.quadraticCurveTo(midX, midY + curve, vertices[j][0], vertices[j][1]);
                    } else {
                        ctgCtx.lineTo(vertices[j][0], vertices[j][1]);
                    }
                    ctgCtx.stroke();
                });
                
                // Draw vertices
                vertices.forEach(v => {
                    ctgCtx.fillStyle = '#ffd700';
                    ctgCtx.beginPath();
                    ctgCtx.arc(v[0], v[1], 5, 0, Math.PI * 2);
                    ctgCtx.fill();
                });
                
                ctgCtx.fillStyle = '#ff8c00';
                ctgCtx.font = '16px "JetBrains Mono", monospace';
                ctgCtx.textAlign = 'center';
                ctgCtx.shadowBlur = 0;
                ctgCtx.fillText('Tropical Curve (metric graph)', 400, 280);
            }
        }

        drawCTG();

        // Tropical curve visualization
        const tcCanvas = document.getElementById('tropicalCurve');
        const tcCtx = tcCanvas.getContext('2d');
        const lengthSlider = document.getElementById('lengthSlider');
        const complexitySlider = document.getElementById('complexitySlider');

        function drawTropicalCurve() {
            tcCtx.clearRect(0, 0, tcCanvas.width, tcCanvas.height);
            
            const length = parseInt(lengthSlider.value);
            const complexity = parseInt(complexitySlider.value);
            
            const cx = 400;
            const cy = 200;
            
            tcCtx.strokeStyle = '#ff8c00';
            tcCtx.lineWidth = 3;
            tcCtx.shadowBlur = 15;
            tcCtx.shadowColor = '#ff8c00';
            
            // Generate vertices based on complexity
            const vertices = [[cx, cy]]; // Center
            const numRays = 3 + complexity;
            
            for (let i = 0; i < numRays; i++) {
                const angle = (i / numRays) * Math.PI * 2;
                const x = cx + Math.cos(angle) * length;
                const y = cy + Math.sin(angle) * length * 0.8;
                vertices.push([x, y]);
                
                // Add secondary vertices for complexity
                if (complexity >= 2 && i % 2 === 0) {
                    const x2 = x + Math.cos(angle) * length * 0.5;
                    const y2 = y + Math.sin(angle) * length * 0.4;
                    vertices.push([x2, y2]);
                }
            }
            
            // Draw edges from center to outer vertices
            for (let i = 1; i < vertices.length; i++) {
                tcCtx.beginPath();
                tcCtx.moveTo(vertices[0][0], vertices[0][1]);
                tcCtx.lineTo(vertices[i][0], vertices[i][1]);
                tcCtx.stroke();
            }
            
            // Connect outer ring if complex enough
            if (complexity >= 3) {
                for (let i = 1; i <= numRays; i++) {
                    const next = i === numRays ? 1 : i + 1;
                    tcCtx.beginPath();
                    tcCtx.moveTo(vertices[i][0], vertices[i][1]);
                    tcCtx.lineTo(vertices[next][0], vertices[next][1]);
                    tcCtx.stroke();
                }
            }
            
            // Draw vertices
            vertices.forEach((v, i) => {
                tcCtx.fillStyle = i === 0 ? '#ffd700' : '#ff8c00';
                tcCtx.shadowBlur = 15;
                tcCtx.shadowColor = i === 0 ? '#ffd700' : '#ff8c00';
                tcCtx.beginPath();
                tcCtx.arc(v[0], v[1], i === 0 ? 8 : 5, 0, Math.PI * 2);
                tcCtx.fill();
            });
            
            // Label edges with lengths
            tcCtx.shadowBlur = 0;
            tcCtx.fillStyle = '#8888a0';
            tcCtx.font = '12px "JetBrains Mono", monospace';
            tcCtx.fillText(`Edge length: ${length}`, 650, 380);
        }

        lengthSlider.addEventListener('input', drawTropicalCurve);
        complexitySlider.addEventListener('input', drawTropicalCurve);
        drawTropicalCurve();
    </script>
</body>
</html>
