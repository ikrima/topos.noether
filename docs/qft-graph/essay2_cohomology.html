<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cohomology and the Hidden Architecture</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --deep-void: #0a0a12;
            --ink-blue: #0d1117;
            --nebula-purple: #1a1a2e;
            --glow-cyan: #00d4ff;
            --glow-magenta: #ff006e;
            --glow-gold: #ffd700;
            --glow-green: #00ff88;
            --text-primary: #e8e8f0;
            --text-secondary: #8888a0;
        }

        body {
            font-family: 'Cormorant Garamond', serif;
            background: var(--deep-void);
            color: var(--text-primary);
            line-height: 1.7;
            overflow-x: hidden;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 60px 40px;
            position: relative;
        }

        .header {
            text-align: center;
            margin-bottom: 80px;
            animation: fadeInDown 1s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .series-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            letter-spacing: 0.3em;
            text-transform: uppercase;
            color: var(--glow-magenta);
            margin-bottom: 20px;
            display: inline-block;
            padding: 8px 16px;
            border: 1px solid rgba(255, 0, 110, 0.3);
            background: rgba(255, 0, 110, 0.05);
        }

        h1 {
            font-size: clamp(2.5rem, 6vw, 4rem);
            font-weight: 400;
            letter-spacing: -0.02em;
            margin-bottom: 24px;
            background: linear-gradient(135deg, var(--text-primary) 0%, var(--glow-magenta) 50%, var(--glow-gold) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 1.4rem;
            font-style: italic;
            color: var(--text-secondary);
            max-width: 650px;
            margin: 0 auto;
        }

        section {
            margin-bottom: 100px;
            animation: fadeIn 1s ease-out;
            animation-fill-mode: both;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        h2 {
            font-size: 2rem;
            font-weight: 400;
            margin-bottom: 30px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 16px;
        }

        h2::before {
            content: '';
            width: 40px;
            height: 2px;
            background: linear-gradient(90deg, var(--glow-magenta), transparent);
        }

        p {
            font-size: 1.2rem;
            margin-bottom: 24px;
            max-width: 800px;
        }

        .highlight {
            color: var(--glow-cyan);
            font-weight: 600;
        }

        .highlight-gold {
            color: var(--glow-gold);
            font-weight: 600;
        }

        .highlight-magenta {
            color: var(--glow-magenta);
            font-weight: 600;
        }

        .formula {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.95rem;
            background: rgba(255, 0, 110, 0.08);
            padding: 4px 12px;
            border-radius: 4px;
            border-left: 3px solid var(--glow-magenta);
            display: inline-block;
        }

        .canvas-container {
            background: linear-gradient(180deg, rgba(13, 17, 23, 0.9) 0%, rgba(26, 26, 46, 0.9) 100%);
            border: 1px solid rgba(255, 0, 110, 0.2);
            border-radius: 12px;
            padding: 30px;
            margin: 40px 0;
            position: relative;
            overflow: hidden;
        }

        .canvas-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--glow-magenta), transparent);
        }

        canvas {
            display: block;
            width: 100%;
            border-radius: 8px;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--text-secondary);
        }

        input[type="range"] {
            width: 180px;
            height: 6px;
            -webkit-appearance: none;
            background: rgba(255, 0, 110, 0.2);
            border-radius: 3px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--glow-magenta);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 15px var(--glow-magenta);
        }

        button {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            padding: 12px 24px;
            background: transparent;
            border: 1px solid var(--glow-magenta);
            color: var(--glow-magenta);
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.05em;
        }

        button:hover {
            background: var(--glow-magenta);
            color: var(--deep-void);
            box-shadow: 0 0 30px rgba(255, 0, 110, 0.4);
        }

        button.active {
            background: var(--glow-magenta);
            color: var(--deep-void);
        }

        .button-group {
            display: flex;
            gap: 10px;
        }

        .quote-block {
            border-left: 3px solid var(--glow-gold);
            padding: 20px 30px;
            margin: 40px 0;
            background: rgba(255, 215, 0, 0.05);
            font-style: italic;
            font-size: 1.3rem;
        }

        .quote-attribution {
            font-style: normal;
            font-size: 0.95rem;
            color: var(--text-secondary);
            margin-top: 15px;
        }

        /* Legend */
        .legend {
            display: flex;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 20px;
            height: 4px;
            border-radius: 2px;
        }

        /* Info box */
        .info-box {
            background: rgba(0, 212, 255, 0.08);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 8px;
            padding: 20px;
            margin: 30px 0;
        }

        .info-box h4 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--glow-cyan);
            margin-bottom: 10px;
            letter-spacing: 0.1em;
        }

        /* Euler characteristic display */
        .euler-display {
            text-align: center;
            padding: 40px;
            background: linear-gradient(135deg, rgba(255, 0, 110, 0.1) 0%, rgba(0, 212, 255, 0.1) 100%);
            border-radius: 12px;
            margin: 40px 0;
        }

        .euler-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 4rem;
            background: linear-gradient(135deg, var(--glow-magenta), var(--glow-cyan));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .euler-label {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-top: 10px;
        }

        .euler-formula {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            color: var(--text-secondary);
            margin-top: 20px;
        }

        /* Metal detector metaphor */
        .detector-viz {
            position: relative;
            height: 200px;
            background: linear-gradient(180deg, transparent, rgba(0, 212, 255, 0.1));
            border-radius: 8px;
            overflow: hidden;
            margin: 30px 0;
        }

        .buried-treasure {
            position: absolute;
            bottom: 20px;
            width: 30px;
            height: 30px;
            background: var(--glow-gold);
            border-radius: 50%;
            opacity: 0.3;
            box-shadow: 0 0 30px var(--glow-gold);
        }

        .detector-beam {
            position: absolute;
            top: 0;
            width: 60px;
            height: 100%;
            background: linear-gradient(180deg, var(--glow-cyan), transparent);
            opacity: 0.3;
            animation: scanBeam 4s ease-in-out infinite;
        }

        @keyframes scanBeam {
            0%, 100% { left: 10%; }
            50% { left: 80%; }
        }

        .nav-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 100px;
            padding-top: 40px;
            border-top: 1px solid rgba(136, 136, 160, 0.2);
        }

        .nav-link {
            color: var(--glow-magenta);
            text-decoration: none;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            text-shadow: 0 0 20px var(--glow-magenta);
        }

        @media (max-width: 768px) {
            .container { padding: 40px 20px; }
            .controls { flex-direction: column; }
            input[type="range"] { width: 100%; }
            .button-group { flex-wrap: wrap; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="series-tag">Essay II of V • Topology & Detection</div>
            <h1>Cohomology and the Hidden Architecture</h1>
            <p class="subtitle">How mathematicians peer into the invisible structure of spaces using algebraic tools—and why the Euler characteristic acts as a "metal detector" for hidden treasures</p>
        </header>

        <section>
            <h2>Loops on a Doughnut</h2>
            <p>
                To understand the hidden architecture of the moduli space of graphs, we need a tool called 
                <span class="highlight">cohomology</span>. The idea is beautifully simple: we study a space 
                by examining the loops that can be drawn on it.
            </p>
            <p>
                Consider a <span class="highlight-gold">torus</span>—the mathematical name for a doughnut shape. 
                On its surface, you can draw many kinds of loops. Some can shrink down to a point (these are 
                <span class="highlight">trivial</span>). Others cannot shrink without breaking—these reveal 
                the <span class="highlight-magenta">essential structure</span> of the space.
            </p>

            <div class="canvas-container">
                <canvas id="torusCanvas" width="800" height="500"></canvas>
                <div class="controls">
                    <div class="button-group">
                        <button id="loopABtn" class="active">Loop A (Around Hole)</button>
                        <button id="loopBBtn">Loop B (Through Hole)</button>
                        <button id="trivialBtn">Trivial Loop</button>
                    </div>
                    <div class="control-group">
                        <label>Rotate View</label>
                        <input type="range" id="rotateSlider" min="0" max="360" value="30">
                    </div>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: var(--glow-cyan);"></div>
                        <span>Loop A: Nontrivial (encircles hole)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: var(--glow-magenta);"></div>
                        <span>Loop B: Nontrivial (threads through)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: var(--glow-gold);"></div>
                        <span>Trivial: Can shrink to a point</span>
                    </div>
                </div>
            </div>

            <div class="info-box">
                <h4>Key Insight</h4>
                <p>
                    A genus-1 torus (single hole) has exactly <strong>two</strong> independent nontrivial 
                    cohomology classes: Loop A and Loop B. These loops must always intersect each other—they 
                    cannot be slid apart while staying on the surface. This intersection property is what 
                    makes them "nontrivial."
                </p>
            </div>
        </section>

        <section>
            <h2>Higher Genus: More Holes, More Structure</h2>
            <p>
                A torus with two holes (genus 2) has <span class="highlight">four</span> independent nontrivial 
                cohomology classes. With three holes, there are six. The pattern is: a genus-<em>g</em> surface 
                has <span class="formula">2g</span> independent cohomology classes.
            </p>
            <p>
                Each pair of loops (one going "around" a hole, one going "through") reveals the presence of 
                that hole. Cohomology is essentially <span class="highlight-magenta">hole-detection</span>.
            </p>

            <div class="canvas-container">
                <canvas id="genusCanvas" width="800" height="400"></canvas>
                <div class="controls">
                    <div class="control-group">
                        <label>Genus (Number of Holes)</label>
                        <input type="range" id="genusSlider" min="1" max="4" value="2">
                    </div>
                </div>
            </div>
        </section>

        <section>
            <h2>The Euler Characteristic: A Numerical Signature</h2>
            <p>
                For simple shapes like tori, we can count cohomology classes directly. But for the 
                moduli space of graphs—with its billions of graphs and bizarre self-intersections—direct 
                counting is impossible.
            </p>
            <p>
                Enter the <span class="highlight-gold">Euler characteristic</span>, denoted χ (chi). 
                This single number encodes information about all the cohomology of a space at once:
            </p>
            <p style="text-align: center; margin: 30px 0;">
                <span class="formula">χ = β₀ - β₁ + β₂ - β₃ + ...</span>
            </p>
            <p>
                where β<sub>k</sub> (Betti numbers) count the k-dimensional cohomology classes. 
                For a torus: β₀ = 1, β₁ = 2, β₂ = 1, so χ = 1 - 2 + 1 = <span class="highlight">0</span>.
            </p>

            <div class="euler-display">
                <div class="euler-value" id="eulerValue">0</div>
                <div class="euler-label">Euler Characteristic of Torus</div>
                <div class="euler-formula">χ = V - E + F = 0 (for any triangulation)</div>
            </div>

            <p>
                The key insight: if χ is large and negative, there must be many cohomology classes 
                in odd dimensions. Borinsky and Vogtmann proved that for the moduli space of rank-n graphs:
            </p>
            <p style="text-align: center; margin: 30px 0;">
                <span class="formula">χ(MG<sub>n</sub>) ~ -e<sup>-1/4</sup> · (n/e)<sup>n</sup> / (n log n)²</span>
            </p>
            <p>
                This grows super-exponentially negative—proving that <span class="highlight-magenta">enormous 
                amounts of odd-dimensional cohomology</span> must exist.
            </p>
        </section>

        <section>
            <h2>The Metal Detector Metaphor</h2>
            <p>
                The Borinsky-Vogtmann result is like a <span class="highlight">metal detector</span> 
                sweeping over a beach. It beeps wildly, telling us there's treasure buried 
                below—<span class="highlight-gold">lots of it</span>. But it doesn't tell us exactly 
                where the treasure is or what it looks like.
            </p>

            <div class="canvas-container">
                <div class="detector-viz" id="detectorViz">
                    <div class="detector-beam"></div>
                </div>
                <p style="text-align: center; color: var(--text-secondary); margin-top: 15px;">
                    The Euler characteristic detects hidden structure we cannot yet see
                </p>
            </div>

            <div class="quote-block">
                "The proof demonstrates that certain structures exist in the moduli space, but it does 
                not explicitly reveal what those structures are. In that way, their new result is more 
                like a metal detector than a camera—it alerts them that something interesting is hiding, 
                even though they can't fully describe it."
                <div class="quote-attribution">— Leila Sloman, Quanta Magazine</div>
            </div>

            <p>
                Only <span class="highlight-magenta">one</span> odd-dimensional cohomology class has ever 
                been explicitly found (by Laurent Bartholdi in 2015, in dimension 11). Yet the Euler 
                characteristic proves that infinitely many more exist. Finding them remains one of 
                topology's great challenges.
            </p>
        </section>

        <section>
            <h2>Why Does This Matter?</h2>
            <p>
                The moduli space of graphs MG<sub>n</sub> is not just an abstract curiosity. It connects to:
            </p>
            <p>
                <span class="highlight">Out(F<sub>n</sub>)</span>: The outer automorphism group of the 
                free group of rank n—a fundamental object in geometric group theory.
            </p>
            <p>
                <span class="highlight-magenta">Kontsevich's Lie Graph Complex</span>: A structure that 
                appears in deformation quantization and mathematical physics.
            </p>
            <p>
                <span class="highlight-gold">String Theory</span>: Graphs describe how strings interact, 
                and moduli spaces parametrize these interactions.
            </p>
            <p>
                The fact that all three share the same rational cohomology is a deep and surprising 
                connection—and understanding this cohomology illuminates all three subjects at once.
            </p>
        </section>

        <nav class="nav-footer">
            <a href="#" class="nav-link">← Previous: The Moduli Sea of Graphs</a>
            <span style="color: var(--text-secondary);">Essay II of V</span>
            <a href="#" class="nav-link">Next: Feynman Diagrams & Physics →</a>
        </nav>
    </div>

    <script>
        // Torus visualization with cohomology loops
        const torusCanvas = document.getElementById('torusCanvas');
        const torusCtx = torusCanvas.getContext('2d');
        const rotateSlider = document.getElementById('rotateSlider');

        let currentLoopType = 'A';
        let rotation = 30;

        // Button handlers
        document.getElementById('loopABtn').addEventListener('click', function() {
            currentLoopType = 'A';
            document.querySelectorAll('.button-group button').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
        });

        document.getElementById('loopBBtn').addEventListener('click', function() {
            currentLoopType = 'B';
            document.querySelectorAll('.button-group button').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
        });

        document.getElementById('trivialBtn').addEventListener('click', function() {
            currentLoopType = 'trivial';
            document.querySelectorAll('.button-group button').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
        });

        rotateSlider.addEventListener('input', (e) => {
            rotation = parseFloat(e.target.value);
        });

        function drawTorus(ctx, centerX, centerY, R, r, rotation, showLoop) {
            const angle = rotation * Math.PI / 180;
            ctx.clearRect(0, 0, torusCanvas.width, torusCanvas.height);

            // Draw torus surface (simplified projection)
            const segments = 50;
            const rings = 30;

            // Draw back surface first
            ctx.strokeStyle = 'rgba(136, 136, 160, 0.2)';
            ctx.lineWidth = 1;

            for (let i = 0; i < rings; i++) {
                const u = (i / rings) * Math.PI * 2;
                ctx.beginPath();
                for (let j = 0; j <= segments; j++) {
                    const v = (j / segments) * Math.PI * 2;
                    const x = (R + r * Math.cos(v)) * Math.cos(u);
                    const y = (R + r * Math.cos(v)) * Math.sin(u);
                    const z = r * Math.sin(v);

                    // Rotate around Y axis
                    const xRot = x * Math.cos(angle) - z * Math.sin(angle);
                    const zRot = x * Math.sin(angle) + z * Math.cos(angle);

                    // Project to 2D
                    const px = centerX + xRot;
                    const py = centerY + y * 0.6 - zRot * 0.4;

                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            }

            // Draw radial lines
            for (let j = 0; j < segments; j += 5) {
                const v = (j / segments) * Math.PI * 2;
                ctx.beginPath();
                for (let i = 0; i <= rings; i++) {
                    const u = (i / rings) * Math.PI * 2;
                    const x = (R + r * Math.cos(v)) * Math.cos(u);
                    const y = (R + r * Math.cos(v)) * Math.sin(u);
                    const z = r * Math.sin(v);

                    const xRot = x * Math.cos(angle) - z * Math.sin(angle);
                    const zRot = x * Math.sin(angle) + z * Math.cos(angle);

                    const px = centerX + xRot;
                    const py = centerY + y * 0.6 - zRot * 0.4;

                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            }

            // Draw the selected loop
            if (showLoop === 'A') {
                // Loop A: Goes around the central hole (meridian)
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#00d4ff';
                ctx.beginPath();

                const loopR = R; // radius of loop
                for (let i = 0; i <= 60; i++) {
                    const u = (i / 60) * Math.PI * 2;
                    const x = loopR * Math.cos(u);
                    const y = loopR * Math.sin(u);
                    const z = 0;

                    const xRot = x * Math.cos(angle) - z * Math.sin(angle);
                    const zRot = x * Math.sin(angle) + z * Math.cos(angle);

                    const px = centerX + xRot;
                    const py = centerY + y * 0.6;

                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();

                // Label
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#00d4ff';
                ctx.font = '16px "JetBrains Mono", monospace';
                ctx.fillText('Loop A', centerX + R + 30, centerY);

            } else if (showLoop === 'B') {
                // Loop B: Goes through the hole (longitudinal)
                ctx.strokeStyle = '#ff006e';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ff006e';
                ctx.beginPath();

                const u0 = 0; // Fixed position on major circle
                for (let j = 0; j <= 60; j++) {
                    const v = (j / 60) * Math.PI * 2;
                    const x = (R + r * Math.cos(v)) * Math.cos(u0);
                    const y = (R + r * Math.cos(v)) * Math.sin(u0);
                    const z = r * Math.sin(v);

                    const xRot = x * Math.cos(angle) - z * Math.sin(angle);
                    const zRot = x * Math.sin(angle) + z * Math.cos(angle);

                    const px = centerX + xRot;
                    const py = centerY + y * 0.6 - zRot * 0.4;

                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();

                // Label
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ff006e';
                ctx.font = '16px "JetBrains Mono", monospace';
                ctx.fillText('Loop B', centerX + R + r + 20, centerY - 50);

            } else if (showLoop === 'trivial') {
                // Trivial loop: sits on the surface, can shrink to a point
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 4;
                ctx.shadowBlur = 20;
                ctx.shadowColor = '#ffd700';
                ctx.beginPath();

                const u0 = Math.PI / 4;
                const v0 = Math.PI / 4;
                const loopSize = 30;

                for (let i = 0; i <= 60; i++) {
                    const theta = (i / 60) * Math.PI * 2;
                    const du = Math.cos(theta) * 0.3;
                    const dv = Math.sin(theta) * 0.3;

                    const x = (R + r * Math.cos(v0 + dv)) * Math.cos(u0 + du);
                    const y = (R + r * Math.cos(v0 + dv)) * Math.sin(u0 + du);
                    const z = r * Math.sin(v0 + dv);

                    const xRot = x * Math.cos(angle) - z * Math.sin(angle);
                    const zRot = x * Math.sin(angle) + z * Math.cos(angle);

                    const px = centerX + xRot;
                    const py = centerY + y * 0.6 - zRot * 0.4;

                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();

                // Label
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffd700';
                ctx.font = '16px "JetBrains Mono", monospace';
                ctx.fillText('Trivial (can shrink)', centerX + 120, centerY - 100);
            }

            ctx.shadowBlur = 0;
        }

        function animateTorus() {
            drawTorus(torusCtx, 400, 250, 150, 60, rotation, currentLoopType);
            requestAnimationFrame(animateTorus);
        }

        animateTorus();

        // Genus visualization
        const genusCanvas = document.getElementById('genusCanvas');
        const genusCtx = genusCanvas.getContext('2d');
        const genusSlider = document.getElementById('genusSlider');

        function drawGenusShape(ctx, genus) {
            ctx.clearRect(0, 0, genusCanvas.width, genusCanvas.height);
            
            const centerY = 200;
            const spacing = 160;
            const startX = 400 - (genus - 1) * spacing / 2;

            // Draw connected tori
            ctx.fillStyle = 'rgba(136, 136, 160, 0.1)';
            ctx.strokeStyle = 'rgba(136, 136, 160, 0.4)';
            ctx.lineWidth = 2;

            for (let g = 0; g < genus; g++) {
                const cx = startX + g * spacing;
                
                // Draw torus cross-section (oval with hole)
                ctx.beginPath();
                ctx.ellipse(cx, centerY, 60, 40, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Draw hole
                ctx.fillStyle = 'var(--deep-void)';
                ctx.beginPath();
                ctx.ellipse(cx, centerY, 25, 15, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'rgba(136, 136, 160, 0.1)';

                // Connect to next
                if (g < genus - 1) {
                    ctx.beginPath();
                    ctx.moveTo(cx + 60, centerY - 20);
                    ctx.lineTo(cx + spacing - 60, centerY - 20);
                    ctx.lineTo(cx + spacing - 60, centerY + 20);
                    ctx.lineTo(cx + 60, centerY + 20);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }

                // Draw Loop A for this hole
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 3;
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00d4ff';
                ctx.beginPath();
                ctx.ellipse(cx, centerY, 45, 30, 0, 0, Math.PI * 2);
                ctx.stroke();

                // Draw Loop B for this hole
                ctx.strokeStyle = '#ff006e';
                ctx.shadowColor = '#ff006e';
                ctx.beginPath();
                ctx.ellipse(cx + 40, centerY, 15, 30, 0, 0, Math.PI * 2);
                ctx.stroke();

                ctx.strokeStyle = 'rgba(136, 136, 160, 0.4)';
                ctx.shadowBlur = 0;
            }

            // Labels
            ctx.fillStyle = 'var(--text-secondary)';
            ctx.font = '14px "JetBrains Mono", monospace';
            ctx.textAlign = 'center';
            ctx.fillText(`Genus ${genus}: ${2 * genus} cohomology classes`, 400, 350);

            ctx.fillStyle = 'var(--glow-cyan)';
            ctx.fillText(`${genus} "around" loops`, 300, 380);
            ctx.fillStyle = 'var(--glow-magenta)';
            ctx.fillText(`${genus} "through" loops`, 500, 380);
        }

        genusSlider.addEventListener('input', (e) => {
            drawGenusShape(genusCtx, parseInt(e.target.value));
        });

        drawGenusShape(genusCtx, 2);

        // Detector visualization - add buried treasures
        const detectorViz = document.getElementById('detectorViz');
        for (let i = 0; i < 8; i++) {
            const treasure = document.createElement('div');
            treasure.className = 'buried-treasure';
            treasure.style.left = (10 + Math.random() * 80) + '%';
            treasure.style.bottom = (10 + Math.random() * 40) + 'px';
            treasure.style.width = (15 + Math.random() * 20) + 'px';
            treasure.style.height = treasure.style.width;
            detectorViz.appendChild(treasure);
        }

        // Animate Euler value
        const eulerValue = document.getElementById('eulerValue');
        let eulerDisplay = 0;
        
        function animateEuler() {
            // Cycle through different Euler characteristics
            const values = [0, 2, -2, 0, -24, 0];
            const labels = ['Torus', 'Sphere', 'Double Torus', 'Torus', 'Moduli Space (n=3)', 'Torus'];
            const idx = Math.floor(Date.now() / 3000) % values.length;
            eulerValue.textContent = values[idx];
            document.querySelector('.euler-label').textContent = `Euler Characteristic of ${labels[idx]}`;
            requestAnimationFrame(animateEuler);
        }
        // Keep it static for now
        // animateEuler();
    </script>
</body>
</html>
