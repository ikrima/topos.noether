<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Limits &amp; Colimits Explorer</title>
  <style>
    /* General styles */
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      line-height: 1.6;
      color: #333;
    }
    h1, h2, h3 {
      margin-top: 1.5rem;
    }
    .section {
      padding: 1rem 2rem;
      max-width: 900px;
      margin: auto;
    }
    .section:nth-child(odd) {
      background: #f7f7f7;
    }
    .diagram {
      margin-top: 1rem;
      text-align: center;
    }
    .diagram svg {
      border: 1px solid #ccc;
      background: white;
    }
    .footnote {
      font-size: 0.8rem;
      color: #555;
    }
    .controls {
      margin-top: 0.5rem;
      text-align: center;
    }
    button {
      padding: 0.4rem 0.8rem;
      margin: 0.2rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #2d72d9;
      color: white;
      font-size: 0.9rem;
    }
    button:active {
      background: #1e4e99;
    }
    .note {
      font-size: 0.9rem;
      color: #555;
      margin-top: 0.5rem;
    }
  </style>
  <!-- Load D3.js from CDN -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
  <header class="section" style="background:#1e3a8a;color:white;text-align:center;padding-top:2rem;padding-bottom:2rem;">
    <h1>Exploring Limits &amp; Colimits</h1>
    <p>A guided, interactive journey through the universal properties that define products and coproducts.</p>
  </header>

  <!-- Introduction section -->
  <section class="section">
    <h2>Universal Properties: A Prelude</h2>
    <p>
      In category theory, <strong>limits</strong> and <strong>colimits</strong> generalise familiar notions like products, sums
      and suprema.  Rather than describing an object directly, they characterise it by how other objects map
      to or from it.  For instance, the supremum of a family of elements \(\{a_i\}\) in a poset
      can be characterised by the condition
      \(\sup_i a_i \leq a\) if and only if \(a_i \leq a\) for each \(i\)【273994938861256†L650-L674】.  This is a
      universal property: any element satisfying the same inequalities must be at least as large as the
      supremum.  Limits and colimits encapsulate this philosophy for arbitrary diagrams.
    </p>
    <p>
      A <em>limit</em> of a diagram collects the data of a cone: a family of morphisms from a single object
      into each component of the diagram, subject to compatibility.  Dually, a <em>colimit</em> glues a diagram
      together via a cocone: a family of morphisms from each component into a single object.  The
      uniqueness (up to unique isomorphism) of such universal cones and cocones is what makes limits
      and colimits so powerful.
    </p>
  </section>

  <!-- Product (limit) explorer -->
  <section class="section">
    <h2>Products as Limits: Build Your Own</h2>
    <p>
      Consider two sets \(X\) and \(Y\).  Their <em>product</em> \(X\times Y\) comes equipped with
      projection maps \(\pi_X : X\times Y \to X\) and \(\pi_Y : X\times Y \to Y\).  The universal property of
      the product states that given any set \(Z\) and maps \(f : Z \to X\), \(g : Z \to Y\), there exists
      a unique map \(\langle f,g \rangle : Z \to X\times Y\) such that
      \(\pi_X \circ \langle f,g \rangle = f\) and \(\pi_Y \circ \langle f,g \rangle = g\).  This map pairs
      each element \(z\in Z\) with the pair \((f(z), g(z))\).
    </p>
    <p>
      Use the interactive diagram below to witness this universal property in action.  The set \(Z\)
      consists of three draggable red points.  For each point \(z\), assign its
      images under \(f\) and \(g\) by dragging the endpoints on the blue and green axes.  The
      product plane shows the unique point \((f(z), g(z))\) in \(X\times Y\).
    </p>
    <div class="diagram" id="product-diagram"></div>
    <div class="note">Drag the red points along the X and Y axes to define \(f\) and \(g\). The product point updates automatically.</div>
  </section>

  <!-- Coproduct (colimit) explorer -->
  <section class="section">
    <h2>Coproducts as Colimits: Gluing Worlds Together</h2>
    <p>
      The dual notion to a product is a <em>coproduct</em>.  Given sets \(X\) and \(Y\), their coproduct
      \(X \sqcup Y\) (sometimes written \(X\amalg Y\)) comes with injection maps \(\iota_X : X \to
      X\sqcup Y\) and \(\iota_Y : Y \to X\sqcup Y\).  The universal property of the coproduct says that
      for any set \(Z\) and maps \(f : X \to Z\), \(g : Y \to Z\), there is a unique map
      \([f,g] : X\sqcup Y \to Z\) such that \([f,g] \circ \iota_X = f\) and \([f,g] \circ \iota_Y = g\).
      Intuitively, \(X\sqcup Y\) is a disjoint union: it remembers which component an element came
      from.
    </p>
    <p>
      In the interactive diagram below, \(X\) is a set of three blue points and \(Y\) a set of three
      green points.  You can assign a colour to each point in \(Z\) by clicking it.  These colours
      represent the values of \(f\) and \(g\) on \(X\) and \(Y\).  The coproduct point shows which colour
      each element of the disjoint union inherits.  Observe that the assignment on the coproduct is
      entirely determined by \(f\) and \(g\).
    </p>
    <div class="diagram" id="coproduct-diagram"></div>
    <div class="controls" id="coproduct-controls"></div>
    <div class="note">Click the circles in \(Z\) to change their colours. Colours propagate to the disjoint union.</div>
  </section>

  <!-- Conclusion -->
  <section class="section">
    <h2>Reflecting on Limits &amp; Colimits</h2>
    <p>
      Limits and colimits distil the essence of many constructions in mathematics and computer
      science.  By specifying how an object relates to the rest of a diagram, one can define it
      uniquely (up to unique isomorphism).  In computer vision, for instance, building a 3D model from
      overlapping camera images is a kind of colimit: each photograph contributes local data, and
      these are glued together into a global whole.  Dually, combining measurement results from
      different instruments might be understood as a limit.  These perspectives echo the
      philosophical idea that understanding is often achieved not by direct inspection but by
      examining how an object interacts with everything around it.
    </p>
  </section>

  <script>
    // Product diagram: interactive product demonstration
    (function() {
      const width = 600;
      const height = 400;
      const margin = {top: 20, right: 20, bottom: 40, left: 40};
      const svg = d3.select('#product-diagram')
        .append('svg')
        .attr('width', width)
        .attr('height', height);

      // Define scales for X and Y axes; simple linear scales from 0 to 10
      const xScale = d3.scaleLinear().domain([0, 10]).range([margin.left, width/2 - margin.right]);
      const yScale = d3.scaleLinear().domain([0, 10]).range([height - margin.bottom, margin.top]);
      const prodXScale = d3.scaleLinear().domain([0, 10]).range([width/2 + margin.left, width - margin.right]);
      const prodYScale = d3.scaleLinear().domain([0, 10]).range([height - margin.bottom, margin.top]);

      // Draw axes
      const xAxis = d3.axisBottom(xScale).ticks(5);
      const yAxis = d3.axisLeft(yScale).ticks(5);
      const prodXAxis = d3.axisBottom(prodXScale).ticks(5);
      const prodYAxis = d3.axisLeft(prodYScale).ticks(5);
      // X axis and Y axis
      svg.append('g')
        .attr('transform', `translate(0,${height - margin.bottom})`)
        .call(xAxis);
      svg.append('g')
        .attr('transform', `translate(${margin.left},0)`)
        .call(yAxis);
      // Product axes
      svg.append('g')
        .attr('transform', `translate(0,${height - margin.bottom})`)
        .call(prodXAxis);
      svg.append('g')
        .attr('transform', `translate(${width/2 + margin.left},0)`)
        .call(prodYAxis);
      // Labels
      svg.append('text')
        .attr('x', (width/4))
        .attr('y', height - 5)
        .attr('text-anchor', 'middle')
        .attr('fill', '#1e3a8a')
        .text('X axis');
      svg.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -height/2)
        .attr('y', 15)
        .attr('text-anchor', 'middle')
        .attr('fill', '#1e3a8a')
        .text('Y axis');
      svg.append('text')
        .attr('x', width*0.75)
        .attr('y', height - 5)
        .attr('text-anchor', 'middle')
        .attr('fill', '#1e3a8a')
        .text('Product X');
      svg.append('text')
        .attr('transform', 'rotate(-90)')
        .attr('x', -height/2)
        .attr('y', width/2 + 15)
        .attr('text-anchor', 'middle')
        .attr('fill', '#1e3a8a')
        .text('Product Y');

      // Create three draggable red points representing elements of Z.
      const points = [
        {id: 0, fx: 2, gx: 8, fy: 2, gy: 8},
        {id: 1, fx: 5, gx: 3, fy: 4, gy: 6},
        {id: 2, fx: 7, gx: 1, fy: 8, gy: 3}
      ];

      // For each point, we'll create two small circles on X-axis and Y-axis representing f(z) and g(z), and
      // a circle on the product plane representing the pair.
      const dragX = d3.drag()
        .on('drag', function(event, d) {
          // Constrain to X-axis region on left half
          let newX = Math.max(margin.left, Math.min(width/2 - margin.right, event.x));
          d.fx = xScale.invert(newX);
          d3.select(this)
            .attr('cx', xScale(d.fx));
          updateProduct();
        });
      const dragY = d3.drag()
        .on('drag', function(event, d) {
          // Constrain to Y-axis region on left half
          let newY = Math.max(margin.top, Math.min(height - margin.bottom, event.y));
          d.fy = yScale.invert(newY);
          d3.select(this)
            .attr('cy', yScale(d.fy));
          updateProduct();
        });
      const dragGX = d3.drag()
        .on('drag', function(event, d) {
          // Constrain to X-axis region on right half
          let newX = Math.max(width/2 + margin.left, Math.min(width - margin.right, event.x));
          d.gx = prodXScale.invert(newX);
          d3.select(this)
            .attr('cx', prodXScale(d.gx));
          updateProduct();
        });
      const dragGY = d3.drag()
        .on('drag', function(event, d) {
          // Constrain to Y-axis region on right half
          let newY = Math.max(margin.top, Math.min(height - margin.bottom, event.y));
          d.gy = prodYScale.invert(newY);
          d3.select(this)
            .attr('cy', prodYScale(d.gy));
          updateProduct();
        });

      // Add lines connecting f(z) and g(z) to product point for each element
      const lines = svg.append('g').selectAll('line').data(points)
        .enter().append('line')
        .attr('stroke', '#999')
        .attr('stroke-dasharray', '3,3');

      // f(z) on X-axis (left)
      const circlesF = svg.append('g').selectAll('circle.f').data(points)
        .enter().append('circle')
        .attr('class', 'f')
        .attr('r', 6)
        .attr('fill', '#d32f2f')
        .attr('cx', d => xScale(d.fx))
        .attr('cy', height - margin.bottom)
        .call(dragX);
      // f(z) on Y-axis (left)
      const circlesFY = svg.append('g').selectAll('circle.fy').data(points)
        .enter().append('circle')
        .attr('class', 'fy')
        .attr('r', 6)
        .attr('fill', '#d32f2f')
        .attr('cx', margin.left)
        .attr('cy', d => yScale(d.fy))
        .call(dragY);
      // g(z) on X-axis (right)
      const circlesGX = svg.append('g').selectAll('circle.gx').data(points)
        .enter().append('circle')
        .attr('class', 'gx')
        .attr('r', 6)
        .attr('fill', '#1976d2')
        .attr('cx', d => prodXScale(d.gx))
        .attr('cy', height - margin.bottom)
        .call(dragGX);
      // g(z) on Y-axis (right)
      const circlesGY = svg.append('g').selectAll('circle.gy').data(points)
        .enter().append('circle')
        .attr('class', 'gy')
        .attr('r', 6)
        .attr('fill', '#1976d2')
        .attr('cx', width/2 + margin.left)
        .attr('cy', d => prodYScale(d.gy))
        .call(dragGY);
      // product points
      const circlesProd = svg.append('g').selectAll('circle.prod').data(points)
        .enter().append('circle')
        .attr('class', 'prod')
        .attr('r', 7)
        .attr('fill', '#388e3c');

      function updateProduct() {
        // update lines connecting projection points to product
        lines
          .attr('x1', d => xScale(d.fx))
          .attr('y1', d => height - margin.bottom)
          .attr('x2', d => prodXScale(d.fx))
          .attr('y2', d => prodYScale(d.fy));
        lines
          .attr('stroke', '#bbb');
        // update product points
        circlesProd
          .attr('cx', d => prodXScale(d.fx))
          .attr('cy', d => prodYScale(d.fy));
      }
      updateProduct();
    })();

    // Coproduct diagram: interactive coproduct demonstration
    (function() {
      const width = 600;
      const height = 350;
      const svg = d3.select('#coproduct-diagram')
        .append('svg')
        .attr('width', width)
        .attr('height', height);
      const radius = 15;
      // Define sets X and Y as sets of nodes with positions
      const X = [
        {id: 0, x: 100, y: 100},
        {id: 1, x: 80, y: 200},
        {id: 2, x: 120, y: 300}
      ];
      const Y = [
        {id: 3, x: 500, y: 100},
        {id: 4, x: 520, y: 200},
        {id: 5, x: 480, y: 300}
      ];
      const coproduct = X.concat(Y);
      // Define codomain Z as three positions along the middle
      const Z = [
        {id: 0, x: 300, y: 100, color: '#f44336'},
        {id: 1, x: 300, y: 200, color: '#ffeb3b'},
        {id: 2, x: 300, y: 300, color: '#4caf50'}
      ];
      // Draw X and Y nodes
      svg.selectAll('circle.X')
        .data(X)
        .enter().append('circle')
        .attr('class', 'X')
        .attr('r', radius)
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('fill', '#42a5f5');
      svg.selectAll('text.X')
        .data(X)
        .enter().append('text')
        .attr('x', d => d.x)
        .attr('y', d => d.y - radius - 4)
        .attr('text-anchor', 'middle')
        .attr('font-size', '0.8rem')
        .text(d => 'X' + d.id);
      svg.selectAll('circle.Y')
        .data(Y)
        .enter().append('circle')
        .attr('class', 'Y')
        .attr('r', radius)
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('fill', '#66bb6a');
      svg.selectAll('text.Y')
        .data(Y)
        .enter().append('text')
        .attr('x', d => d.x)
        .attr('y', d => d.y - radius - 4)
        .attr('text-anchor', 'middle')
        .attr('font-size', '0.8rem')
        .text(d => 'Y' + (d.id - 3));
      // Draw Z nodes
      const zNodes = svg.selectAll('circle.Z')
        .data(Z)
        .enter().append('circle')
        .attr('class', 'Z')
        .attr('r', radius)
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('fill', d => d.color)
        .attr('stroke', '#444')
        .attr('stroke-width', 1.5)
        .style('cursor', 'pointer')
        .on('click', function(event, d) {
          // Cycle through colours on click
          const colours = ['#f44336','#ffeb3b','#4caf50','#9c27b0'];
          const index = colours.indexOf(d.color);
          d.color = colours[(index + 1) % colours.length];
          d3.select(this).attr('fill', d.color);
          updateCoproductColours();
        });
      svg.selectAll('text.Z')
        .data(Z)
        .enter().append('text')
        .attr('x', d => d.x)
        .attr('y', d => d.y - radius - 4)
        .attr('text-anchor', 'middle')
        .attr('font-size', '0.8rem')
        .text(d => 'Z' + d.id);
      // Draw coproduct nodes and keep a mapping from each element to its colour
      const copNodes = svg.selectAll('circle.co')
        .data(coproduct)
        .enter().append('circle')
        .attr('class', 'co')
        .attr('r', radius)
        .attr('cx', d => d.x)
        .attr('cy', d => d.y)
        .attr('fill', '#e0e0e0')
        .attr('stroke', '#555')
        .attr('stroke-width', 1.5);
      svg.selectAll('text.co')
        .data(coproduct)
        .enter().append('text')
        .attr('x', d => d.x)
        .attr('y', d => d.y - radius - 4)
        .attr('text-anchor', 'middle')
        .attr('font-size', '0.8rem')
        .text(function(d) {
          return d.id < 3 ? 'in_X(' + d.id + ')' : 'in_Y(' + (d.id - 3) + ')';
        });

      function updateCoproductColours() {
        // Each element of X maps via f to Z0, Z1, Z2 depending on X mapping; similarly Y maps via g.
        // We'll assign colours by alternating: X points map to Z[0]; Y points map to Z[2], etc.
        // For a richer experience, randomly assign or allow custom mapping via colours: here, cycle mapping on click.
        copNodes
          .attr('fill', function(d) {
            // Determine index of codomain mapping: for simplicity, map by position (0-2) but we allow user to click Z nodes to change colours.
            // We'll map X's points to Z[0].color, Y's to Z[1].color for demonstration.
            if (d.id < 3) {
              return Z[0].color;
            } else {
              return Z[1].color;
            }
          });
      }
      updateCoproductColours();
    })();
  </script>
</body>
</html>