<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Monads and Free Monoids</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      color: #333;
      line-height: 1.6;
    }
    h1, h2 {
      margin-top: 1.5rem;
    }
    .section {
      padding: 1rem 2rem;
      max-width: 900px;
      margin: auto;
    }
    .section:nth-child(odd) {
      background: #f3f4f6;
    }
    .intro {
      background: #002f5f;
      color: white;
      padding-top: 2rem;
      padding-bottom: 2rem;
      text-align: center;
    }
    .note {
      font-size: 0.9rem;
      color: #555;
      margin-top: 0.5rem;
    }
    button {
      padding: 0.4rem 0.8rem;
      margin: 0.2rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #2d72d9;
      color: white;
      font-size: 0.9rem;
    }
    button:active {
      background: #1e4e99;
    }
    .diagram {
      margin-top: 1rem;
    }
    .array-display {
      font-family: monospace;
      background: #f5f5f5;
      padding: 0.5rem;
      border-radius: 4px;
      margin-top: 0.5rem;
    }
  </style>
</head>
<body>
  <header class="intro">
    <h1>Monads: Encoding Algebraic Structure</h1>
    <p>Discover how the free–forgetful adjunction generates the list monad, and play with list operations.</p>
  </header>

  <!-- Intro section -->
  <section class="section">
    <h2>What is a Monad?</h2>
    <p>
      In category theory, a <strong>monad</strong> on a category \(\mathcal{C}\) is an endofunctor \(T : \mathcal{C} \to
      \mathcal{C}\) equipped with two natural transformations: a <em>unit</em> \(\eta : 1_\mathcal{C} \Rightarrow T\) and a
      <em>multiplication</em> \(\mu : T^2 \Rightarrow T\).  These must satisfy associativity and unit
      axioms: \(\mu \circ T\mu = \mu \circ \mu_T\) and \(\mu \circ T\eta = \mu \circ \eta_T = 1_T\).  Monads
      package algebraic structure in a purely categorical way.  The book notes that a monad
      "provides a syntactic encoding of algebraic structure that may be borne by objects"
      of the underlying category【273994938861256†L734-L739】.
    </p>
    <p>
      One example arises from the adjunction between sets and monoids.  The <em>free monoid</em>
      functor \(F : \mathbf{Set} \to \mathbf{Mon}\) sends a set \(X\) to the monoid of finite lists of
      elements of \(X\) under concatenation.  Its right adjoint \(U : \mathbf{Mon} \to \mathbf{Set}\) forgets the
      monoid structure.  The composite \(UF\) is an endofunctor on \(\mathbf{Set}\), sending a set to its
      set of lists.  The unit \(\eta_X : X \to UF(X)\) wraps an element into a singleton list, and the
      multiplication \(\mu_X : UFUF(X) \to UF(X)\) concatenates a list of lists into a single list.
      This is precisely the <em>list monad</em>, ubiquitous in functional programming.
    </p>
  </section>

  <!-- Interactive section for list monad -->
  <section class="section">
    <h2>The List Monad Playground</h2>
    <p>
      Use the controls below to create nested lists of numbers.  The <strong>unit</strong> operation
      wraps each element in a singleton list, and the <strong>multiplication</strong> flattens nested lists.  You
      can visualise how the two operations satisfy the monad laws: wrapping followed by flattening
      leaves the list unchanged, and flattening nested lists two different ways yields the same
      result.
    </p>
    <div id="list-controls">
      <button id="unit-btn">Wrap Elements (η)</button>
      <button id="multiply-btn">Flatten (μ)</button>
      <button id="reset-btn">Reset</button>
    </div>
    <div class="diagram" id="list-diagram">
      <p><strong>Current list structure:</strong></p>
      <div id="list-display" class="array-display"></div>
    </div>
    <div class="note">Click "Wrap Elements" to apply \(\eta\), "Flatten" to apply \(\mu\), and reset to start over.</div>
  </section>

  <!-- Section on free monoids -->
  <section class="section">
    <h2>From Free Monoids to Monads</h2>
    <p>
      The free–forgetful adjunction not only generates the list monad but also illuminates why
      monads capture algebraic structure.  The free functor \(F\) assigns to a set \(X\) the monoid
      \(F(X)\) of all finite words in the alphabet \(X\).  Given a function \(f : X \to M\) into a monoid \(M\),
      there is a unique monoid homomorphism \(\tilde f : F(X) \to M\) extending \(f\).  This universal
      property makes \(F(X)\) the “most general” monoid built from \(X\).  The forgetful functor \(U\)
      simply remembers the underlying set of a monoid.  The list monad arises because lists encode
      the free monoid structure on a set.
    </p>
    <p>
      To see this in action, choose a finite set \(X = \{a,b,c\}\).  Select values of \(f\) on \(a,b,c\) in a
      monoid \(M\) (here, we take the two-element monoid \(\{0,1\}\) under addition modulo 2).  The
      induced homomorphism \(\tilde f\) maps a word to the sum of its letters’ images.  Try different
      assignments and observe how \(\tilde f\) behaves on sample words.
    </p>
    <div id="free-monoid-diagram"></div>
    <div class="note">Click buttons next to letters to toggle their images.  The table updates the induced homomorphism.</div>
  </section>

  <section class="section">
    <h2>Reflections</h2>
    <p>
      Monads provide a versatile language for capturing patterns of composition.  In programming,
      they model effects like nondeterminism (the powerset monad), state, exceptions, or I/O.  In
      mathematics, they organise algebraic structures and define categories of algebras.  This
      playground has shown how the list monad arises from the simplest of adjunctions and how the
      monad laws manifest as familiar operations on lists.  You can imagine more exotic monads
      generated by other adjunctions, each encoding its own flavour of structure.
    </p>
  </section>

  <script>
    // Interactive list monad demonstration
    (function() {
      // The list will start as a simple array of numbers. We'll represent nested lists as arrays of arrays.
      let list = [1, 2, 3];
      const display = document.getElementById('list-display');
      const unitBtn = document.getElementById('unit-btn');
      const multiplyBtn = document.getElementById('multiply-btn');
      const resetBtn = document.getElementById('reset-btn');
      function render() {
        display.textContent = JSON.stringify(list);
      }
      function wrapElements() {
        // η: wrap each element into a singleton list
        list = list.map(x => [x]);
        render();
      }
      function flattenOnce(arr) {
        // μ: flatten a nested array by one level
        return arr.reduce((acc, x) => acc.concat(x), []);
      }
      function flattenList() {
        // flatten once if the elements are arrays; flatten deeper if necessary
        // We'll flatten only one level for clarity
        list = flattenOnce(list);
        render();
      }
      function reset() {
        list = [1, 2, 3];
        render();
      }
      unitBtn.addEventListener('click', wrapElements);
      multiplyBtn.addEventListener('click', flattenList);
      resetBtn.addEventListener('click', reset);
      render();
    })();

    // Free monoid and induced homomorphism demonstration
    (function() {
      const container = d3.select('#free-monoid-diagram');
      const setX = ['a', 'b', 'c'];
      // We'll use a two-element monoid under addition mod 2: values 0 and 1
      let assignment = { a: 0, b: 0, c: 0 };
      // Sample words in F(X)
      const words = ['a', 'b', 'c', 'ab', 'ac', 'ba', 'bc', 'cab', 'abc'];
      // Build interface
      const controlsDiv = container.append('div');
      controlsDiv.append('p').text('Set assignments f: {a,b,c} → {0,1}:');
      const buttons = controlsDiv.selectAll('button.assign')
        .data(setX)
        .enter()
        .append('button')
        .text(d => `${d}: 0`)
        .on('click', function(event, d) {
          assignment[d] = (assignment[d] + 1) % 2;
          d3.select(this).text(`${d}: ${assignment[d]}`);
          updateTable();
        });
      // Table for induced homomorphism values
      const table = container.append('table')
        .style('border-collapse', 'collapse')
        .style('margin-top', '1rem');
      const header = table.append('tr');
      header.append('th').text('Word').style('border', '1px solid #ccc').style('padding', '4px');
      header.append('th').text('Image under \u03C6').style('border', '1px solid #ccc').style('padding', '4px');
      // Rows for words
      const rows = table.selectAll('tr.row')
        .data(words)
        .enter().append('tr');
      rows.append('td').text(d => d).style('border', '1px solid #ccc').style('padding', '4px');
      const valueCells = rows.append('td').style('border', '1px solid #ccc').style('padding', '4px');
      function computeImage(word) {
        // Compute the sum modulo 2 of the images of letters in the word
        return word.split('').reduce((sum, ch) => (sum + assignment[ch]) % 2, 0);
      }
      function updateTable() {
        valueCells.text(d => computeImage(d));
      }
      updateTable();
    })();
  </script>
</body>
</html>