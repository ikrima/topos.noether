<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Yoneda Lemma & Photogrammetry: Interactive Infographic</title>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r146/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146/examples/js/controls/OrbitControls.js"></script>
<style>
  body {
    margin: 0;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #f9f9fb;
    color: #333;
  }
  main {
    max-width: 1000px;
    margin: auto;
    padding: 1rem;
    line-height: 1.6;
  }
  h1, h2 {
    text-align: center;
    color: #2a4373;
  }
  h2 {
    margin-top: 2rem;
  }
  section {
    margin-bottom: 3rem;
  }
  .content {
    display: flex;
    flex-direction: row;
    flex-wrap: wrap;
    gap: 1.5rem;
  }
  .text-block {
    flex: 1 1 300px;
    min-width: 280px;
  }
  .viz-block {
    flex: 1 1 300px;
    min-width: 300px;
    position: relative;
  }
  svg {
    width: 100%;
    height: 100%;
  }
  #section1 svg, #section2 svg {
    border: 1px solid #ddd;
    background: white;
  }
  #photo-diagram-controls {
    margin-top: 0.5rem;
    text-align: center;
  }
  #photo-diagram-controls label {
    margin-right: 0.5rem;
  }
  #threeContainer {
    width: 100%;
    height: 500px;
    border: 1px solid #ddd;
    background: white;
  }
  #three-controls {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.5rem;
  }
  button {
    padding: 0.5rem 1rem;
    background: #2a4373;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
  }
  button:hover {
    background: #1b2d4d;
  }
  .highlight {
    stroke: #e45756;
    stroke-width: 3px;
  }
</style>
</head>
<body>
<main>
  <h1>Yoneda Lemma & Photogrammetry</h1>

  <section id="section1">
    <h2>1. The Yoneda Lemma</h2>
    <div class="content">
      <div class="text-block">
        <p>
          The Yoneda lemma states that an object \(X\) in a locally small category \(C\) is fully determined by the set of morphisms into it: for any functor \(F : C \to \textbf{Set}\) and any object \(c\), there is a natural bijection
          \(\operatorname{Hom}(\operatorname{Hom}(c, -), F) \cong F(c)\)【607663452290599†L4120-L4125】.
        </p>
        <p>
          To illustrate this, imagine several simple <em>probes</em> (objects \(A\), \(B\), \(C\)) sending arrows into a hidden object \(X\). Each arrow corresponds to a morphism in \(C\). The collection of all such arrows forms the representable functor \(\operatorname{Hom}(A, X)\), \(\operatorname{Hom}(B, X)\), etc. The Yoneda lemma tells us that knowing these hom-sets completely characterizes \(X\).
        </p>
      </div>
      <div class="viz-block">
        <svg id="yoneda-diagram" viewBox="0 0 500 300"></svg>
      </div>
    </div>
  </section>

  <section id="section2">
    <h2>2. Photogrammetry Analogy</h2>
    <div class="content">
      <div class="text-block">
        <p>
          Photogrammetry reconstructs a 3D object by combining many 2D projections. A camera acts as a <em>probe</em>, projecting the scene onto its image plane. Each photograph records how light rays from the object land on the flat sensor. By capturing enough views from different positions and angles, we can recover the original shape. This is analogous to using the hom-sets \(\operatorname{Hom}(A, X)\) to reconstruct \(X\)【607663452290599†L4120-L4125】.
        </p>
        <p>
          Use the slider to rotate the camera around the hidden object. Each angle corresponds to a different projection, and the silhouette in the camera window shows the 2D image recorded from that angle.
        </p>
      </div>
      <div class="viz-block">
        <svg id="photo-diagram" viewBox="0 0 500 300"></svg>
        <div id="photo-diagram-controls">
          <label for="angleSlider">Camera angle:</label>
          <input type="range" id="angleSlider" min="-90" max="90" value="-30" />
        </div>
      </div>
    </div>
  </section>

  <section id="section3">
    <h2>3. Building the Object from Views</h2>
    <div class="content">
      <div class="text-block">
        <p>
          In this final interactive, you can experience the reconstruction process directly. The hidden torus knot \(X\) is invisible at first. Move the camera around to choose a viewpoint and press <strong>Capture View</strong> to project “splats” back into 3D along the view rays. Each capture adds more data, and as you accumulate projections from multiple angles, the object gradually appears. This process embodies the idea that an object is the colimit of its representable functors—it is reconstructed from how other objects map into it【607663452290599†L4120-L4125】.
        </p>
      </div>
      <div class="viz-block">
        <div id="threeContainer"></div>
        <div id="three-controls">
          <button id="captureBtn">Capture View</button>
          <button id="resetBtn">Reset</button>
        </div>
      </div>
    </div>
  </section>
</main>

<script>
// Section 1: Yoneda diagram interactive
(function() {
  const svg = d3.select('#yoneda-diagram');
  const width = 500, height = 300;

  // positions for objects
  const X = { x: 350, y: 150 };
  const probes = [
    { id: 'A', x: 100, y: 80 },
    { id: 'B', x: 80, y: 220 },
    { id: 'C', x: 170, y: 170 }
  ];

  // draw hidden object X
  svg.append('circle')
    .attr('cx', X.x)
    .attr('cy', X.y)
    .attr('r', 50)
    .attr('fill', 'none')
    .attr('stroke', '#4b8bbe')
    .attr('stroke-dasharray', '6,3');

  svg.append('text')
    .attr('x', X.x)
    .attr('y', X.y + 5)
    .attr('text-anchor','middle')
    .attr('font-size', 14)
    .attr('font-weight','bold')
    .attr('fill', '#4b8bbe')
    .text('X');

  // arrow marker
  svg.append('defs').append('marker')
    .attr('id','arrow1')
    .attr('viewBox','0 -5 10 10')
    .attr('refX',10)
    .attr('refY',0)
    .attr('markerWidth',6)
    .attr('markerHeight',6)
    .attr('orient','auto')
    .append('path')
      .attr('d','M0,-5L10,0L0,5')
      .attr('fill','#666');

  // draw probes and arrows
  probes.forEach(p => {
    // line
    svg.append('line')
      .attr('x1', p.x)
      .attr('y1', p.y)
      .attr('x2', X.x - 45)
      .attr('y2', X.y)
      .attr('stroke','#666')
      .attr('stroke-width',2)
      .attr('marker-end','url(#arrow1)')
      .attr('class','arrow-line');

    // probe circle
    svg.append('circle')
      .attr('cx', p.x)
      .attr('cy', p.y)
      .attr('r', 18)
      .attr('fill','#f37736')
      .attr('stroke','#b25c26')
      .attr('stroke-width',2)
      .on('mouseover', function() {
        // highlight arrow
        d3.select(this).attr('fill','#e45756');
        svg.selectAll('.arrow-line').filter((d,i,n) => i === probes.indexOf(p)).attr('class','arrow-line highlight');
      })
      .on('mouseout', function() {
        d3.select(this).attr('fill','#f37736');
        svg.selectAll('.arrow-line').attr('class','arrow-line');
      });

    svg.append('text')
      .attr('x', p.x)
      .attr('y', p.y + 5)
      .attr('text-anchor','middle')
      .attr('font-size', 14)
      .attr('font-weight','bold')
      .attr('fill','#fff')
      .text(p.id);
  });
})();

// Section 2: Photogrammetry diagram interactive
(function() {
  const svg = d3.select('#photo-diagram');
  const width = 500;
  const height = 300;
  const centerX = 150;
  const centerY = height / 2;
  const cameraX = 380;
  const cameraY = height / 2;

  // define object shape (torus-like silhouette)
  const R = 80;
  const r = 25;
  const objectPoints = [];
  for (let t = 0; t < Math.PI * 2; t += Math.PI / 50) {
    const x = (R + r * Math.cos(3 * t)) * Math.cos(t);
    const y = (R + r * Math.cos(3 * t)) * Math.sin(t);
    objectPoints.push({ x: x, y: y });
  }

  // draw object outline
  const objectGroup = svg.append('g').attr('transform', `translate(${centerX}, ${centerY})`);
  objectGroup.append('path')
    .datum(objectPoints)
    .attr('fill', '#9a8c98')
    .attr('fill-opacity', 0.15)
    .attr('stroke', '#9a8c98')
    .attr('stroke-width', 2)
    .attr('d', d3.line().x(d => d.x).y(d => d.y).curve(d3.curveCardinalClosed));

  // camera body
  const cameraGroup = svg.append('g').attr('transform', `translate(${cameraX}, ${cameraY - 40})`);
  cameraGroup.append('rect')
    .attr('width', 60)
    .attr('height', 80)
    .attr('fill', '#4b8bbe')
    .attr('stroke', '#003f5c')
    .attr('stroke-width', 2);
  // camera lens rectangle representing screen
  cameraGroup.append('rect')
    .attr('x', 5)
    .attr('y', 20)
    .attr('width', 50)
    .attr('height', 40)
    .attr('fill', '#fff')
    .attr('stroke', '#003f5c')
    .attr('stroke-width', 1)
    .attr('id', 'camera-screen');

  // label
  cameraGroup.append('text')
    .attr('x', 30)
    .attr('y', 15)
    .attr('text-anchor','middle')
    .attr('font-size', 12)
    .attr('fill','#fff')
    .text('Camera');

  // initial angle
  let angle = -30 * Math.PI / 180;

  function updateProjection() {
    // rotate object points and project onto camera screen
    const rotated = objectPoints.map(pt => {
      const x = pt.x * Math.cos(angle) - pt.y * Math.sin(angle);
      const y = pt.x * Math.sin(angle) + pt.y * Math.cos(angle);
      return { x: x, y: y };
    });
    // projection onto screen: scale to fit inside 50x40
    const xExtent = d3.extent(rotated, d => d.x);
    const yExtent = d3.extent(rotated, d => d.y);
    const widthScale = 50 / (xExtent[1] - xExtent[0]);
    const heightScale = 40 / (yExtent[1] - yExtent[0]);
    const s = Math.min(widthScale, heightScale);
    const x0 = (xExtent[0] + xExtent[1]) / 2;
    const y0 = (yExtent[0] + yExtent[1]) / 2;
    const proj = rotated.map(pt => {
      const px = (pt.x - x0) * s + 30; // 30 = 5 + 50/2
      const py = (pt.y - y0) * s + 40; // 40 = 20 + 40/2
      return { x: px, y: py };
    });
    // update projection path
    let projectionPath = cameraGroup.select('#projection-path');
    if (projectionPath.empty()) {
      projectionPath = cameraGroup.append('path').attr('id','projection-path');
    }
    projectionPath
      .datum(proj)
      .attr('fill', '#f37736')
      .attr('fill-opacity', 0.2)
      .attr('stroke', '#f37736')
      .attr('stroke-width', 1)
      .attr('d', d3.line().x(d => d.x).y(d => d.y).curve(d3.curveCardinalClosed));
  }

  updateProjection();

  // draw a few rays from camera to object for illustration
  const rays = [ { angle: -0.3 }, { angle: 0 }, { angle: 0.3 } ];
  rays.forEach(ray => {
    const rayX = cameraX + 30;
    const rayY = cameraY;
    const targetX = centerX + R * Math.cos(ray.angle);
    const targetY = centerY + R * Math.sin(ray.angle);
    svg.append('line')
      .attr('x1', rayX)
      .attr('y1', rayY)
      .attr('x2', targetX)
      .attr('y2', targetY)
      .attr('stroke','#aaaaaa')
      .attr('stroke-dasharray','4,3');
  });

  d3.select('#angleSlider').on('input', function() {
    const val = +this.value;
    angle = val * Math.PI / 180;
    updateProjection();
  });
})();

// Section 3: Three.js splatting engine
(function(){
  const container = document.getElementById('threeContainer');
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf9f9fb);
  const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
  camera.position.set(0, 0, 6);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(container.clientWidth, container.clientHeight);
  container.appendChild(renderer.domElement);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // Hidden object: Torus Knot
  const knotGeometry = new THREE.TorusKnotGeometry(1.0, 0.4, 200, 32);
  const knotMaterial = new THREE.MeshPhongMaterial({ color: 0x9a8c98, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
  const knot = new THREE.Mesh(knotGeometry, knotMaterial);
  scene.add(knot);

  // Lights
  const ambient = new THREE.AmbientLight(0xffffff, 0.6);
  scene.add(ambient);
  const pointLight = new THREE.PointLight(0xffffff, 0.8);
  pointLight.position.set(5, 5, 5);
  scene.add(pointLight);

  // Splats: Points representing captured projections
  let splatGeometry = new THREE.BufferGeometry();
  let splatPositions = [];
  let splatColors = [];
  const splatMaterial = new THREE.PointsMaterial({ size: 0.05, vertexColors: true });
  let splatPoints = new THREE.Points(splatGeometry, splatMaterial);
  scene.add(splatPoints);

  function captureView() {
    // Sample a subset of vertices on the knot that are in front of the camera
    const positions = knotGeometry.attributes.position;
    const worldPosition = new THREE.Vector3();
    const localPosition = new THREE.Vector3();
    const matrixWorld = knot.matrixWorld;
    const cameraDir = new THREE.Vector3();
    camera.getWorldDirection(cameraDir);

    const color = new THREE.Color(Math.random(), Math.random(), Math.random());

    for (let i = 0; i < positions.count; i += 5) {
      localPosition.fromBufferAttribute(positions, i);
      worldPosition.copy(localPosition).applyMatrix4(matrixWorld);
      // Vector from camera to point
      const vectorToPoint = new THREE.Vector3().subVectors(worldPosition, camera.position);
      // Check if point is roughly in front of the camera (angle < 90°)
      if (vectorToPoint.dot(cameraDir) > 0) {
        // jitter point along ray to simulate splat thickness
        const jitter = worldPosition.clone().add(cameraDir.clone().multiplyScalar(0.02 * Math.random()));
        splatPositions.push(jitter.x, jitter.y, jitter.z);
        splatColors.push(color.r, color.g, color.b);
      }
    }
    updateSplats();
  }

  function updateSplats() {
    splatGeometry.dispose();
    splatGeometry = new THREE.BufferGeometry();
    const positionAttr = new THREE.Float32BufferAttribute(splatPositions, 3);
    const colorAttr = new THREE.Float32BufferAttribute(splatColors, 3);
    splatGeometry.setAttribute('position', positionAttr);
    splatGeometry.setAttribute('color', colorAttr);
    scene.remove(splatPoints);
    splatPoints = new THREE.Points(splatGeometry, splatMaterial);
    scene.add(splatPoints);
  }

  function resetSplats() {
    splatPositions = [];
    splatColors = [];
    updateSplats();
  }

  document.getElementById('captureBtn').addEventListener('click', captureView);
  document.getElementById('resetBtn').addEventListener('click', resetSplats);

  // Render loop
  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // Responsive
  window.addEventListener('resize', function() {
    const width = container.clientWidth;
    const height = container.clientHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize(width, height);
  });
})();
</script>

</body>
</html>
