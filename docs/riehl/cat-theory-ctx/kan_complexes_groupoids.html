<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kan Complexes & ∞-Groupoids: All Morphisms Invertible</title>
  
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #333;
    }
    
    #root {
      width: 100%;
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1800px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    
    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 40px;
      text-align: center;
      border-radius: 12px 12px 0 0;
    }
    
    .header h1 {
      font-size: 3em;
      margin-bottom: 15px;
      font-weight: 300;
      letter-spacing: 2px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }
    
    .subtitle {
      font-size: 1.2em;
      opacity: 0.95;
      font-weight: 300;
    }
    
    .tabs {
      display: flex;
      background: #f8f9fa;
      border-bottom: 2px solid #dee2e6;
    }
    
    .tab {
      flex: 1;
      padding: 20px;
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 1em;
      font-weight: 500;
      color: #666;
      transition: all 0.3s ease;
      border-bottom: 4px solid transparent;
    }
    
    .tab:hover {
      background: #e9ecef;
    }
    
    .tab.active {
      color: #667eea;
      background: white;
      border-bottom-color: #667eea;
    }
    
    .content {
      display: grid;
      grid-template-columns: 2fr 1fr;
      gap: 30px;
      padding: 40px;
      min-height: 700px;
    }
    
    .main-viz {
      background: #f8f9fa;
      border-radius: 16px;
      padding: 30px;
    }
    
    .sidebar {
      background: white;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .canvas-container {
      width: 100%;
      height: 500px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      margin-bottom: 25px;
    }
    
    .theorem-box {
      background: linear-gradient(135deg, #e8eaf6 0%, #c5cae9 100%);
      border: 3px solid #5c6bc0;
      border-radius: 16px;
      padding: 30px;
      margin: 30px 0;
    }
    
    .theorem-box h3 {
      color: #3949ab;
      margin-bottom: 20px;
      font-size: 1.5em;
    }
    
    .definition-box {
      background: linear-gradient(135deg, #fff9c4 0%, #fff59d 100%);
      border: 3px solid #fbc02d;
      border-radius: 16px;
      padding: 30px;
      margin: 30px 0;
    }
    
    .definition-box h3 {
      color: #f57c00;
      margin-bottom: 20px;
      font-size: 1.5em;
    }
    
    .comparison-table {
      width: 100%;
      margin: 30px 0;
      border-collapse: collapse;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .comparison-table th,
    .comparison-table td {
      padding: 18px;
      text-align: left;
      border-bottom: 1px solid #dee2e6;
    }
    
    .comparison-table th {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      font-weight: 600;
      font-size: 1.05em;
    }
    
    .comparison-table tr:last-child td {
      border-bottom: none;
    }
    
    .comparison-table tr:hover {
      background: #f8f9fa;
    }
    
    .info-box {
      background: #e3f2fd;
      border-left: 4px solid #2196f3;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
      line-height: 1.7;
    }
    
    .info-box.success {
      background: #e8f5e9;
      border-left-color: #4caf50;
    }
    
    .info-box.warning {
      background: #fff3e0;
      border-left-color: #ff9800;
    }
    
    .info-box.insight {
      background: #fce4ec;
      border-left-color: #e91e63;
    }
    
    .math-formula {
      background: white;
      padding: 20px;
      margin: 20px 0;
      border-radius: 12px;
      border: 2px solid #dee2e6;
      font-family: 'Times New Roman', serif;
      text-align: center;
      font-size: 1.2em;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    
    .horn-selector {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin: 20px 0;
    }
    
    .horn-button {
      flex: 1;
      min-width: 100px;
      padding: 15px;
      border: 3px solid #dee2e6;
      background: white;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      text-align: center;
      font-weight: 600;
    }
    
    .horn-button:hover {
      border-color: #667eea;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    
    .horn-button.selected {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-color: #764ba2;
    }
    
    .horn-button.fillable {
      border-color: #4caf50;
    }
    
    .horn-button.not-fillable {
      border-color: #f44336;
    }
    
    button {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      cursor: pointer;
      font-size: 0.95em;
      font-weight: 600;
      transition: all 0.2s ease;
      width: 100%;
      margin-bottom: 10px;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }
    
    button.success {
      background: linear-gradient(135deg, #4caf50 0%, #388e3c 100%);
    }
    
    button.danger {
      background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
    }
    
    .homotopy-group-display {
      background: white;
      border-radius: 12px;
      padding: 25px;
      margin: 20px 0;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .homotopy-group-display h4 {
      color: #667eea;
      margin-bottom: 15px;
      font-size: 1.2em;
    }
    
    .group-item {
      padding: 12px 15px;
      margin: 8px 0;
      background: #f8f9fa;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      font-family: 'Courier New', monospace;
    }
    
    .inverse-demo {
      background: white;
      border-radius: 12px;
      padding: 30px;
      margin: 25px 0;
      border: 3px solid #667eea;
    }
    
    .inverse-demo h4 {
      color: #667eea;
      margin-bottom: 20px;
      text-align: center;
    }
    
    .path-display {
      display: flex;
      justify-content: space-around;
      align-items: center;
      margin: 25px 0;
    }
    
    .path-node {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 700;
      font-size: 1.3em;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
    
    .path-arrow {
      font-size: 2.5em;
      color: #667eea;
      font-weight: 300;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .path-arrow .label {
      font-size: 0.5em;
      font-weight: 600;
      margin-top: 5px;
    }
    
    .legend {
      background: #f8f9fa;
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
    }
    
    .legend h4 {
      margin-bottom: 15px;
      color: #666;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 12px;
      margin: 10px 0;
    }
    
    .legend-color {
      width: 30px;
      height: 30px;
      border-radius: 6px;
      border: 2px solid #333;
    }
    
    .control-section {
      margin-bottom: 25px;
    }
    
    .control-section h4 {
      color: #667eea;
      margin-bottom: 15px;
      font-size: 1.1em;
    }
    
    select {
      width: 100%;
      padding: 12px;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      margin-bottom: 10px;
    }
    
    select:focus {
      outline: none;
      border-color: #667eea;
    }
    
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 10px 0;
    }
    
    .checkbox-group input {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }
    
    .checkbox-group label {
      cursor: pointer;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useRef } = React;
    
    // ============================================================================
    // MATHEMATICAL CORE: Kan Complexes
    // ============================================================================
    
    // Horn types
    function createHorn(n, k) {
      return {
        dimension: n,
        missingFace: k,
        isInner: k > 0 && k < n,
        isOuter: k === 0 || k === n,
        fillable: true // All horns fill in Kan complexes!
      };
    }
    
    const KAN_EXAMPLES = {
      simplicialSet: {
        name: 'Arbitrary Simplicial Set',
        description: 'Not necessarily Kan',
        hasAllHornFillers: false,
        isKan: false,
        isGroupoid: false
      },
      quasiCategory: {
        name: 'Quasi-Category',
        description: 'Only inner horns fill',
        hasAllHornFillers: false,
        hasInnerHornFillers: true,
        isKan: false,
        isGroupoid: false
      },
      kanComplex: {
        name: 'Kan Complex',
        description: 'ALL horns fill',
        hasAllHornFillers: true,
        isKan: true,
        isGroupoid: true
      },
      singularSet: {
        name: 'Singular Set of Space',
        description: 'Sing(X) for topological space X',
        hasAllHornFillers: true,
        isKan: true,
        isGroupoid: true,
        concrete: 'e.g., Sing(S¹)'
      }
    };
    
    // Fundamental groupoid
    function fundamentalGroupoid(kanComplex) {
      return {
        objects: "0-simplices (points)",
        morphisms: "1-simplices (paths) modulo homotopy",
        composition: "Path concatenation",
        inverses: "Path reversal (guaranteed by Kan condition)"
      };
    }
    
    // ============================================================================
    // THREE.JS RENDERING
    // ============================================================================
    
    function useThreeScene(canvasRef, state) {
      const sceneRef = useRef(null);
      const rendererRef = useRef(null);
      const cameraRef = useRef(null);
      
      useEffect(() => {
        if (!canvasRef.current) return;
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfafbfc);
        sceneRef.current = scene;
        
        const camera = new THREE.PerspectiveCamera(
          50,
          canvasRef.current.clientWidth / canvasRef.current.clientHeight,
          0.1,
          1000
        );
        camera.position.set(5, 5, 8);
        camera.lookAt(0, 0, 0);
        cameraRef.current = camera;
        
        const renderer = new THREE.WebGLRenderer({
          canvas: canvasRef.current,
          antialias: true
        });
        renderer.setSize(canvasRef.current.clientWidth, canvasRef.current.clientHeight);
        rendererRef.current = renderer;
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);
        
        let animationId;
        const animate = () => {
          animationId = requestAnimationFrame(animate);
          
          if (state.autoRotate) {
            camera.position.x = 8 * Math.cos(Date.now() * 0.0005);
            camera.position.z = 8 * Math.sin(Date.now() * 0.0005);
            camera.lookAt(0, 0, 0);
          }
          
          renderer.render(scene, camera);
        };
        animate();
        
        return () => {
          cancelAnimationFrame(animationId);
          renderer.dispose();
        };
      }, []);
      
      useEffect(() => {
        if (!sceneRef.current) return;
        
        const scene = sceneRef.current;
        const objectsToRemove = scene.children.filter(
          child => child.type === 'Mesh' || child.type === 'Line' || child.type === 'Group'
        );
        objectsToRemove.forEach(obj => scene.remove(obj));
        
        drawHornVisualization(scene, state);
      }, [state]);
      
      return { scene: sceneRef.current, camera: cameraRef.current };
    }
    
    function drawHornVisualization(scene, state) {
      const { selectedHorn, showFiller } = state;
      if (!selectedHorn) return;
      
      const n = selectedHorn.dimension;
      const k = selectedHorn.missingFace;
      
      // Draw simplex vertices
      const vertices = [];
      for (let i = 0; i <= n; i++) {
        const angle = (i / (n + 1)) * Math.PI * 2;
        const radius = 2;
        vertices.push({
          x: Math.cos(angle) * radius,
          y: Math.sin(angle) * radius,
          z: n === 3 && i === 3 ? 2 : 0
        });
      }
      
      // Draw vertices
      vertices.forEach((v, i) => {
        const geometry = new THREE.SphereGeometry(0.15, 16, 16);
        const material = new THREE.MeshPhongMaterial({ 
          color: i === k ? 0xff6b6b : 0x667eea 
        });
        const sphere = new THREE.Mesh(geometry, material);
        sphere.position.set(v.x, v.y, v.z);
        scene.add(sphere);
      });
      
      // Draw edges
      for (let i = 0; i < vertices.length; i++) {
        for (let j = i + 1; j < vertices.length; j++) {
          if (i === k || j === k) continue; // Skip edges involving missing vertex
          
          const points = [
            new THREE.Vector3(vertices[i].x, vertices[i].y, vertices[i].z),
            new THREE.Vector3(vertices[j].x, vertices[j].y, vertices[j].z)
          ];
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          const material = new THREE.LineBasicMaterial({ color: 0x333333, linewidth: 2 });
          const line = new THREE.Line(geometry, material);
          scene.add(line);
        }
      }
      
      // Draw filler if requested
      if (showFiller && n === 2) {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array([
          vertices[0].x, vertices[0].y, vertices[0].z,
          vertices[1].x, vertices[1].y, vertices[1].z,
          vertices[2].x, vertices[2].y, vertices[2].z
        ]);
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.computeVertexNormals();
        
        const material = new THREE.MeshPhongMaterial({
          color: 0x4caf50,
          transparent: true,
          opacity: 0.4,
          side: THREE.DoubleSide
        });
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);
      }
    }
    
    // ============================================================================
    // REACT COMPONENTS
    // ============================================================================
    
    function App() {
      const [state, setState] = useState({
        currentTab: 0,
        selectedHorn: createHorn(2, 0),
        showFiller: false,
        autoRotate: false,
        selectedExample: 'kanComplex',
        showInverses: false
      });
      
      const tabs = [
        { id: 0, name: 'Kan Complexes' },
        { id: 1, name: 'All Horns Fill' },
        { id: 2, name: '∞-Groupoids' },
        { id: 3, name: 'Homotopy Theory' },
        { id: 4, name: 'Examples' }
      ];
      
      return (
        <div className="container">
          <div className="header">
            <h1>Kan Complexes & ∞-Groupoids</h1>
            <div className="subtitle">
              When All Morphisms Are Invertible
            </div>
          </div>
          
          <div className="tabs">
            {tabs.map(tab => (
              <button
                key={tab.id}
                className={`tab ${state.currentTab === tab.id ? 'active' : ''}`}
                onClick={() => setState(prev => ({ ...prev, currentTab: tab.id }))}
              >
                {tab.name}
              </button>
            ))}
          </div>
          
          <TabContent state={state} setState={setState} />
        </div>
      );
    }
    
    function TabContent({ state, setState }) {
      const TabComponent = [
        KanComplexTab,
        AllHornsTab,
        GroupoidTab,
        HomotopyTheoryTab,
        ExamplesTab
      ][state.currentTab];
      
      return <TabComponent state={state} setState={setState} />;
    }
    
    function KanComplexTab({ state, setState }) {
      return (
        <div className="content">
          <div className="main-viz">
            <div className="definition-box">
              <h3>Definition: Kan Complex</h3>
              <p style={{ lineHeight: '1.8', fontSize: '1.05em', marginTop: '15px' }}>
                A simplicial set X is a <strong>Kan complex</strong> if <em>every</em> horn has a filler.
              </p>
              <div className="math-formula">
                Λᵏₙ → X &nbsp; extends to &nbsp; Δⁿ → X &nbsp; for all n, k
              </div>
              <p style={{ lineHeight: '1.8', marginTop: '15px' }}>
                This includes both inner horns (0 &lt; k &lt; n) AND outer horns (k = 0 or k = n).
              </p>
            </div>
            
            <table className="comparison-table">
              <thead>
                <tr>
                  <th>Structure</th>
                  <th>Inner Horns</th>
                  <th>Outer Horns</th>
                  <th>Result</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>Simplicial Set</strong></td>
                  <td>❌ May not fill</td>
                  <td>❌ May not fill</td>
                  <td>General structure</td>
                </tr>
                <tr>
                  <td><strong>Quasi-Category</strong></td>
                  <td>✓ Always fill</td>
                  <td>❌ May not fill</td>
                  <td>∞-Category</td>
                </tr>
                <tr>
                  <td><strong>Kan Complex</strong></td>
                  <td>✓ Always fill</td>
                  <td>✓ Always fill</td>
                  <td>∞-Groupoid</td>
                </tr>
              </tbody>
            </table>
            
            <div className="info-box insight">
              <strong>The Key Difference:</strong> Outer horns filling means you can "extend paths backwards" - 
              this is exactly what gives you inverses! Every morphism has an inverse (up to homotopy).
            </div>
          </div>
          
          <div className="sidebar">
            <div className="control-section">
              <h4>Why Kan Complexes?</h4>
              <div className="info-box" style={{ fontSize: '0.9em' }}>
                <strong>Historical Context:</strong> Daniel Kan introduced these in 1955 to study 
                homotopy theory combinatorially. They're the "correct" simplicial analogue of topological spaces.
              </div>
              
              <div className="info-box success" style={{ fontSize: '0.9em', marginTop: '15px' }}>
                <strong>Key Fact:</strong> For any topological space X, the singular set Sing(X) 
                is always a Kan complex. This gives us a functor:<br/>
                <div style={{ textAlign: 'center', marginTop: '10px', fontFamily: 'monospace' }}>
                  Sing : Top → KanCplx
                </div>
              </div>
            </div>
            
            <div className="legend">
              <h4>Key Properties</h4>
              <ul className="property-list" style={{ listStyle: 'none', padding: 0 }}>
                <li style={{ padding: '10px', background: '#f8f9fa', margin: '8px 0', borderRadius: '6px' }}>
                  <strong>All horns fill</strong>
                </li>
                <li style={{ padding: '10px', background: '#f8f9fa', margin: '8px 0', borderRadius: '6px' }}>
                  <strong>Every morphism invertible</strong>
                </li>
                <li style={{ padding: '10px', background: '#f8f9fa', margin: '8px 0', borderRadius: '6px' }}>
                  <strong>Fundamental groupoid</strong>
                </li>
                <li style={{ padding: '10px', background: '#f8f9fa', margin: '8px 0', borderRadius: '6px' }}>
                  <strong>Homotopy groups πₙ(X,x)</strong>
                </li>
              </ul>
            </div>
          </div>
        </div>
      );
    }
    
    function AllHornsTab({ state, setState }) {
      const canvasRef = useRef(null);
      useThreeScene(canvasRef, state);
      
      return (
        <div className="content">
          <div className="main-viz">
            <div className="canvas-container">
              <canvas ref={canvasRef}></canvas>
            </div>
            
            <div className="horn-selector">
              {[0, 1, 2].map(k => (
                <div
                  key={k}
                  className={`horn-button fillable ${
                    state.selectedHorn?.missingFace === k ? 'selected' : ''
                  }`}
                  onClick={() => setState(prev => ({ 
                    ...prev, 
                    selectedHorn: createHorn(2, k),
                    showFiller: false
                  }))}
                >
                  Λ²_{k}<br/>
                  <span style={{ fontSize: '0.8em' }}>
                    {k === 0 ? 'Outer' : k === 2 ? 'Outer' : 'Inner'}
                  </span>
                </div>
              ))}
            </div>
            
            <button 
              className="success"
              onClick={() => setState(prev => ({ ...prev, showFiller: !prev.showFiller }))}
            >
              {state.showFiller ? 'Hide' : 'Show'} Filler
            </button>
            
            {state.selectedHorn && (
              <div className="info-box">
                <strong>Horn Λ²_{state.selectedHorn.missingFace}</strong><br/>
                Type: {state.selectedHorn.isOuter ? 'Outer horn' : 'Inner horn'}<br/>
                <strong style={{ color: '#4caf50' }}>✓ This horn CAN be filled</strong> (Kan condition)
              </div>
            )}
            
            <div className="theorem-box">
              <h3>Why Outer Horns Matter</h3>
              <p style={{ lineHeight: '1.8', marginTop: '15px' }}>
                Filling Λ²₀ and Λ²₂ (outer horns) is what gives us <strong>inverses</strong>:
              </p>
              <ul style={{ marginLeft: '30px', marginTop: '15px', lineHeight: '2' }}>
                <li><strong>Λ²₀:</strong> Given g∘f, produce f (right inverse direction)</li>
                <li><strong>Λ²₂:</strong> Given g∘f, produce g (left inverse direction)</li>
              </ul>
              <div className="info-box insight" style={{ marginTop: '20px' }}>
                In a quasi-category, only Λ²₁ fills, so you get composition but not necessarily inverses. 
                In a Kan complex, ALL horns fill, so every morphism is invertible!
              </div>
            </div>
          </div>
          
          <div className="sidebar">
            <div className="control-section">
              <h4>Controls</h4>
              <div className="checkbox-group">
                <input
                  type="checkbox"
                  checked={state.autoRotate}
                  onChange={e => setState(prev => ({ ...prev, autoRotate: e.target.checked }))}
                />
                <label>Auto-rotate</label>
              </div>
            </div>
            
            <div className="info-box warning" style={{ fontSize: '0.9em' }}>
              <strong>Exercise:</strong> Try to understand why outer horn filling forces invertibility. 
              If you have a morphism f: x → y, can you construct an inverse g: y → x using horn filling?
            </div>
            
            <div className="homotopy-group-display">
              <h4>What Horns Give You</h4>
              <div className="group-item">Λ²₁: Composition</div>
              <div className="group-item">Λ²₀, Λ²₂: Inverses</div>
              <div className="group-item">Λ³ₖ: Associativity</div>
              <div className="group-item">Higher Λⁿₖ: Coherence</div>
            </div>
          </div>
        </div>
      );
    }
    
    function GroupoidTab({ state, setState }) {
      return (
        <div className="content">
          <div className="main-viz">
            <div className="theorem-box">
              <h3>Kan Complex = ∞-Groupoid</h3>
              <p style={{ lineHeight: '1.8', fontSize: '1.05em', marginTop: '15px' }}>
                A Kan complex is the <strong>∞-categorical version of a groupoid</strong> - 
                a category where all morphisms are invertible.
              </p>
              <div className="math-formula">
                Kan Complex ≅ ∞-Groupoid
              </div>
            </div>
            
            <div className="inverse-demo">
              <h4>Invertibility in Action</h4>
              <div className="path-display">
                <div className="path-node">x</div>
                <div className="path-arrow">
                  <div>→</div>
                  <div className="label">f</div>
                </div>
                <div className="path-node">y</div>
                <div className="path-arrow">
                  <div>→</div>
                  <div className="label">f⁻¹</div>
                </div>
                <div className="path-node">x</div>
              </div>
              <p style={{ textAlign: 'center', marginTop: '20px', lineHeight: '1.7' }}>
                For every morphism f: x → y, there exists an inverse f⁻¹: y → x such that 
                f⁻¹ ∘ f ≃ id_x (homotopic to identity).
              </p>
            </div>
            
            <button onClick={() => setState(prev => ({ ...prev, showInverses: !prev.showInverses }))}>
              {state.showInverses ? 'Hide' : 'Show'} Inverse Construction
            </button>
            
            {state.showInverses && (
              <div className="info-box success">
                <strong>How to construct f⁻¹:</strong>
                <ol style={{ marginLeft: '25px', marginTop: '10px', lineHeight: '2' }}>
                  <li>Start with f: x → y</li>
                  <li>Form the outer horn Λ²₀ with edges: id_y, f</li>
                  <li>Fill this horn to get a 2-simplex</li>
                  <li>The missing edge is f⁻¹: y → x</li>
                  <li>The 2-simplex witnesses f⁻¹ ∘ f ≃ id_x</li>
                </ol>
              </div>
            )}
            
            <div className="definition-box">
              <h3>Fundamental ∞-Groupoid</h3>
              <p style={{ lineHeight: '1.8', marginTop: '15px' }}>
                For a Kan complex X, we can extract its fundamental ∞-groupoid π_∞(X):
              </p>
              <ul style={{ marginLeft: '30px', marginTop: '15px', lineHeight: '2' }}>
                <li><strong>Objects:</strong> 0-simplices (points)</li>
                <li><strong>Morphisms:</strong> 1-simplices (paths) modulo homotopy</li>
                <li><strong>2-Morphisms:</strong> Homotopies between paths</li>
                <li><strong>3-Morphisms:</strong> Homotopies between homotopies</li>
                <li><strong>n-Morphisms:</strong> Keep going infinitely!</li>
              </ul>
            </div>
          </div>
          
          <div className="sidebar">
            <div className="homotopy-group-display">
              <h4>Examples of ∞-Groupoids</h4>
              <div className="group-item">
                <strong>Fundamental groupoid:</strong><br/>
                π_∞(X) of a space X
              </div>
              <div className="group-item">
                <strong>Loop space:</strong><br/>
                Ω(X, x) = paths starting and ending at x
              </div>
              <div className="group-item">
                <strong>Classifying space:</strong><br/>
                BG for a group G
              </div>
            </div>
            
            <div className="info-box" style={{ fontSize: '0.9em', marginTop: '20px' }}>
              <strong>Connection to Topology:</strong> Every topological space X gives rise to a 
              Kan complex Sing(X), and every Kan complex X can be "geometrically realized" to give 
              a topological space |X|. These processes are inverse up to homotopy equivalence!
            </div>
          </div>
        </div>
      );
    }
    
    function HomotopyTheoryTab({ state, setState }) {
      return (
        <div className="content" style={{ gridTemplateColumns: '1fr' }}>
          <div>
            <div className="theorem-box">
              <h3>Kan Complexes and Homotopy Theory</h3>
              <p style={{ lineHeight: '1.8', fontSize: '1.05em', marginTop: '15px' }}>
                Kan complexes are the foundation of <strong>simplicial homotopy theory</strong> - 
                a purely combinatorial approach to studying topological spaces.
              </p>
            </div>
            
            <div className="definition-box">
              <h3>Homotopy Groups</h3>
              <p style={{ lineHeight: '1.8', marginTop: '15px' }}>
                For a Kan complex X and basepoint x ∈ X₀, we can define homotopy groups:
              </p>
              <div className="homotopy-group-display">
                <div className="group-item">
                  <strong>π₀(X):</strong> Connected components (0-simplices modulo path equivalence)
                </div>
                <div className="group-item">
                  <strong>π₁(X, x):</strong> Fundamental group (loops at x modulo homotopy)
                </div>
                <div className="group-item">
                  <strong>π₂(X, x):</strong> Second homotopy group (2-spheres at x)
                </div>
                <div className="group-item">
                  <strong>πₙ(X, x):</strong> Higher homotopy groups
                </div>
              </div>
              <div className="info-box success" style={{ marginTop: '20px' }}>
                <strong>Amazing Fact:</strong> These combinatorially-defined groups agree with the 
                classical topological homotopy groups for Sing(X) of a space X!
              </div>
            </div>
            
            <div className="theorem-box">
              <h3>Quillen's Model Category</h3>
              <p style={{ lineHeight: '1.8', marginTop: '15px' }}>
                The category of simplicial sets with:
              </p>
              <ul style={{ marginLeft: '30px', marginTop: '15px', lineHeight: '2' }}>
                <li><strong>Weak equivalences:</strong> Maps inducing isomorphisms on πₙ</li>
                <li><strong>Fibrations:</strong> Kan fibrations (lifting property)</li>
                <li><strong>Cofibrations:</strong> Monomorphisms</li>
              </ul>
              <p style={{ lineHeight: '1.8', marginTop: '15px' }}>
                forms a <strong>model category</strong> that's Quillen equivalent to the model category of 
                topological spaces!
              </p>
            </div>
            
            <table className="comparison-table">
              <thead>
                <tr>
                  <th>Topology</th>
                  <th>Simplicial Sets</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Topological space X</td>
                  <td>Kan complex Sing(X)</td>
                </tr>
                <tr>
                  <td>Continuous map f: X → Y</td>
                  <td>Simplicial map Sing(f)</td>
                </tr>
                <tr>
                  <td>Homotopy equivalence</td>
                  <td>Weak equivalence</td>
                </tr>
                <tr>
                  <td>Fibration</td>
                  <td>Kan fibration</td>
                </tr>
                <tr>
                  <td>Path space</td>
                  <td>Simplicial path space</td>
                </tr>
                <tr>
                  <td>Loop space Ω(X)</td>
                  <td>Simplicial loop space</td>
                </tr>
              </tbody>
            </table>
            
            <div className="info-box insight">
              <strong>Why This Matters:</strong> Kan complexes let us do homotopy theory entirely 
              combinatorially, without any topology! This is incredibly powerful for computation and 
              for extending ideas to contexts where we don't have classical topology.
            </div>
          </div>
        </div>
      );
    }
    
    function ExamplesTab({ state, setState }) {
      const example = KAN_EXAMPLES[state.selectedExample];
      
      return (
        <div className="content" style={{ gridTemplateColumns: '1fr' }}>
          <div>
            <h2 style={{ fontSize: '2em', marginBottom: '30px', color: '#667eea' }}>
              Gallery of Examples
            </h2>
            
            <div className="control-section">
              <select 
                value={state.selectedExample}
                onChange={e => setState(prev => ({ ...prev, selectedExample: e.target.value }))}
              >
                {Object.entries(KAN_EXAMPLES).map(([key, ex]) => (
                  <option key={key} value={key}>{ex.name}</option>
                ))}
              </select>
            </div>
            
            <div className="theorem-box">
              <h3>{example.name}</h3>
              <p style={{ lineHeight: '1.8', fontSize: '1.05em', marginTop: '15px' }}>
                {example.description}
              </p>
              {example.concrete && (
                <div className="info-box" style={{ marginTop: '15px' }}>
                  <strong>Concrete Example:</strong> {example.concrete}
                </div>
              )}
              
              <div style={{ marginTop: '25px' }}>
                <div style={{ 
                  padding: '15px',
                  background: example.isKan ? '#e8f5e9' : '#ffebee',
                  borderRadius: '8px',
                  marginBottom: '10px'
                }}>
                  <strong>Is Kan Complex:</strong> {example.isKan ? '✓ Yes' : '✗ No'}
                </div>
                <div style={{ 
                  padding: '15px',
                  background: example.isGroupoid ? '#e8f5e9' : '#ffebee',
                  borderRadius: '8px',
                  marginBottom: '10px'
                }}>
                  <strong>Is ∞-Groupoid:</strong> {example.isGroupoid ? '✓ Yes' : '✗ No'}
                </div>
                <div style={{ 
                  padding: '15px',
                  background: example.hasAllHornFillers ? '#e8f5e9' : '#ffebee',
                  borderRadius: '8px'
                }}>
                  <strong>All Horns Fill:</strong> {example.hasAllHornFillers ? '✓ Yes' : '✗ No'}
                </div>
              </div>
            </div>
            
            <div className="definition-box">
              <h3>Classic Examples in Detail</h3>
              
              <div style={{ marginTop: '25px' }}>
                <h4 style={{ color: '#f57c00', marginBottom: '15px' }}>1. Sing(S¹)</h4>
                <p style={{ lineHeight: '1.7' }}>
                  The singular complex of the circle. This is a Kan complex with:
                </p>
                <ul style={{ marginLeft: '25px', marginTop: '10px', lineHeight: '2' }}>
                  <li>π₀ = single point (connected)</li>
                  <li>π₁ = ℤ (fundamental group of circle)</li>
                  <li>πₙ = 0 for n ≥ 2</li>
                </ul>
              </div>
              
              <div style={{ marginTop: '25px' }}>
                <h4 style={{ color: '#f57c00', marginBottom: '15px' }}>2. Nerve of a Groupoid</h4>
                <p style={{ lineHeight: '1.7' }}>
                  For any ordinary groupoid G, its nerve N(G) is a Kan complex where:
                </p>
                <ul style={{ marginLeft: '25px', marginTop: '10px', lineHeight: '2' }}>
                  <li>N(G)₀ = objects of G</li>
                  <li>N(G)₁ = morphisms of G</li>
                  <li>N(G)ₙ = composable chains of n morphisms</li>
                </ul>
              </div>
              
              <div style={{ marginTop: '25px' }}>
                <h4 style={{ color: '#f57c00', marginBottom: '15px' }}>3. Classifying Space BG</h4>
                <p style={{ lineHeight: '1.7' }}>
                  For a group G (viewed as one-object groupoid), BG is a Kan complex with:
                </p>
                <ul style={{ marginLeft: '25px', marginTop: '10px', lineHeight: '2' }}>
                  <li>π₀ = single point</li>
                  <li>π₁ = G</li>
                  <li>πₙ = 0 for n ≥ 2</li>
                </ul>
              </div>
            </div>
            
            <div className="info-box">
              <strong>Key Takeaway:</strong> Kan complexes are everywhere in homotopy theory. 
              Any time you have a space, you get a Kan complex via Sing(−). Any time you have 
              a groupoid, you get a Kan complex via N(−). They're the "right" combinatorial 
              model for spaces up to homotopy!
            </div>
          </div>
        </div>
      );
    }
    
    // ============================================================================
    // RENDER
    // ============================================================================
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
  
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</body>
</html>