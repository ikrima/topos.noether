<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>∞-Category Models: The Grand Unification</title>
  
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react.production.min.js"></script>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #141e30 0%, #243b55 100%);
      color: #333;
    }
    
    #root { width: 100%; min-height: 100vh; padding: 20px; }
    
    .container {
      max-width: 1900px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }
    
    .header {
      background: linear-gradient(135deg, #141e30 0%, #243b55 100%);
      color: white;
      padding: 50px;
      text-align: center;
      border-radius: 12px 12px 0 0;
    }
    
    .header h1 {
      font-size: 3.5em;
      margin-bottom: 15px;
      font-weight: 200;
      letter-spacing: 3px;
    }
    
    .subtitle { font-size: 1.3em; opacity: 0.9; font-weight: 300; font-style: italic; }
    
    .content { padding: 50px; }
    
    .model-selector {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
      margin: 40px 0;
    }
    
    .model-option {
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      border-radius: 16px;
      padding: 30px;
      cursor: pointer;
      border: 4px solid transparent;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .model-option:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 24px rgba(0,0,0,0.2);
    }
    
    .model-option.selected {
      border-color: #667eea;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }
    
    .model-option h3 {
      font-size: 1.5em;
      margin-bottom: 15px;
      font-weight: 600;
    }
    
    .model-option p {
      line-height: 1.7;
      opacity: 0.9;
    }
    
    .equivalence-web {
      background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%);
      border-radius: 20px;
      padding: 50px;
      margin: 40px 0;
      position: relative;
    }
    
    .equivalence-title {
      text-align: center;
      font-size: 2em;
      font-weight: 600;
      color: #ff6b6b;
      margin-bottom: 40px;
    }
    
    .model-graph {
      position: relative;
      width: 100%;
      height: 500px;
      background: white;
      border-radius: 16px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    }
    
    .node {
      position: absolute;
      width: 140px;
      height: 140px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      color: white;
      font-weight: 700;
      font-size: 1em;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
      z-index: 10;
    }
    
    .node:hover {
      transform: scale(1.15);
      box-shadow: 0 10px 30px rgba(102, 126, 234, 0.6);
    }
    
    .node.active {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      transform: scale(1.2);
    }
    
    .comparison-panel {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 40px;
      margin: 40px 0;
    }
    
    .model-detail {
      background: white;
      border-radius: 16px;
      padding: 35px;
      border: 4px solid #667eea;
      box-shadow: 0 6px 20px rgba(0,0,0,0.1);
    }
    
    .model-detail h3 {
      color: #667eea;
      font-size: 1.8em;
      margin-bottom: 25px;
      padding-bottom: 15px;
      border-bottom: 3px solid #667eea;
    }
    
    .section {
      margin: 25px 0;
    }
    
    .section h4 {
      color: #444;
      margin-bottom: 12px;
      font-size: 1.2em;
    }
    
    .section p {
      line-height: 1.8;
      color: #666;
    }
    
    .property-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin: 20px 0;
    }
    
    .property-card {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 12px;
      border-left: 4px solid #667eea;
    }
    
    .property-card strong {
      color: #667eea;
      display: block;
      margin-bottom: 8px;
      font-size: 1.05em;
    }
    
    .theorem-box {
      background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
      border: 4px solid #ff9800;
      border-radius: 20px;
      padding: 40px;
      margin: 40px 0;
    }
    
    .theorem-box h3 {
      color: #e65100;
      font-size: 2em;
      margin-bottom: 25px;
    }
    
    .info-box {
      background: #e3f2fd;
      border-left: 5px solid #2196f3;
      padding: 25px;
      margin: 25px 0;
      border-radius: 10px;
      line-height: 1.8;
    }
    
    .info-box.success { background: #e8f5e9; border-left-color: #4caf50; }
    .info-box.warning { background: #fff3e0; border-left-color: #ff9800; }
    .info-box.insight { background: #f3e5f5; border-left-color: #9c27b0; }
    
    .timeline {
      position: relative;
      padding: 30px 0;
      margin: 40px 0;
    }
    
    .timeline::before {
      content: '';
      position: absolute;
      left: 50%;
      top: 0;
      bottom: 0;
      width: 4px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    
    .timeline-item {
      position: relative;
      margin: 40px 0;
      padding-left: calc(50% + 40px);
    }
    
    .timeline-item:nth-child(even) {
      padding-left: 0;
      padding-right: calc(50% + 40px);
      text-align: right;
    }
    
    .timeline-marker {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #667eea;
      border: 5px solid white;
      box-shadow: 0 0 0 4px #667eea;
    }
    
    .timeline-content {
      background: white;
      padding: 25px;
      border-radius: 12px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.1);
    }
    
    .timeline-content h4 {
      color: #667eea;
      font-size: 1.3em;
      margin-bottom: 10px;
    }
    
    button {
      padding: 14px 30px;
      border: none;
      border-radius: 10px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      cursor: pointer;
      font-size: 1em;
      font-weight: 600;
      transition: all 0.2s ease;
      margin: 8px;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }
    
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
    }
    
    .functor-chain {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 25px;
      margin: 30px 0;
      flex-wrap: wrap;
      padding: 30px;
      background: linear-gradient(135deg, #e0f7fa 0%, #e1f5fe 100%);
      border-radius: 16px;
    }
    
    .functor-box {
      background: white;
      padding: 20px 30px;
      border-radius: 12px;
      font-weight: 600;
      font-size: 1.1em;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      border: 3px solid #2196f3;
    }
    
    .functor-arrow {
      font-size: 2.5em;
      color: #2196f3;
      font-weight: 300;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState } = React;
    
    const MODELS = {
      quasicat: {
        name: 'Quasi-Categories',
        short: 'qCat',
        description: 'Simplicial sets with inner horn fillers',
        data: 'Simplicial set X : Δᵒᵖ → Set',
        condition: 'Every inner horn Λₖⁿ (0 < k < n) has a filler',
        pros: ['Combinatorial and concrete', 'Easy to compute with', 'Geometric intuition', 'Direct constructions'],
        cons: ['Hom-spaces not immediately visible', 'Composition witnesses implicit', 'Higher coherences hidden'],
        examples: ['Nerve of a category', 'Δ¹ (interval)', 'Joyal's quasi-category of spaces'],
        yearIntroduced: '2002',
        inventor: 'André Joyal'
      },
      css: {
        name: 'Complete Segal Spaces',
        short: 'CSS',
        description: 'Bisimplicial sets satisfying Segal + completeness',
        data: 'Bisimplicial set X : Δᵒᵖ × Δᵒᵖ → Set',
        condition: 'Segal maps are equivalences + completeness map is equivalence',
        pros: ['Homotopy-theoretic', 'Hom-spaces explicit', 'Flexible for enrichment', 'Natural mapping spaces'],
        cons: ['More abstract', 'Harder to compute', 'Requires bisimplicial machinery'],
        examples: ['Nerve of a topological category', 'Classifying diagram of groupoids'],
        yearIntroduced: '2001',
        inventor: 'Charles Rezk'
      },
      segalcat: {
        name: 'Segal Categories',
        short: 'SeCat',
        description: 'Simplicial spaces with Segal property',
        data: 'Simplicial space X : Δᵒᵖ → sSet',
        condition: 'Segal maps Xₙ → X₁ ×_{X₀} ⋯ ×_{X₀} X₁ are weak equivalences',
        pros: ['Enriched category theory', 'Good for model categories', 'Natural composition'],
        cons: ['Requires fibrant replacement', 'Technical conditions'],
        examples: ['Nerve of a simplicially enriched category'],
        yearIntroduced: '1998',
        inventor: 'Hirschowitz & Simpson'
      },
      complicial: {
        name: '1-Complicial Sets',
        short: '1-Comp',
        description: 'Stratified simplicial sets',
        data: 'Stratified simplicial set with thin simplices',
        condition: 'Saturated, 1-trivial, weak complicial',
        pros: ['Algebraic flavor', 'Direct notion of equivalence'],
        cons: ['Less commonly used', 'Stratification technical'],
        examples: ['Verity\'s construction'],
        yearIntroduced: '2006',
        inventor: 'Dominic Verity'
      },
      relcat: {
        name: 'Relative Categories',
        short: 'RelCat',
        description: 'Categories with weak equivalences',
        data: 'Category C with subcategory W of weak equivalences',
        condition: 'W satisfies 2-out-of-3',
        pros: ['Most concrete', 'Direct from model categories', 'Easy to define'],
        cons: ['Not homotopy-invariant', 'Requires localization'],
        examples: ['(C, W) where W are isomorphisms', 'Model category (C, W)'],
        yearIntroduced: '1967',
        inventor: 'Quillen (implicitly)'
      },
      topcat: {
        name: 'Topological Categories',
        short: 'TopCat',
        description: 'Categories enriched over topological spaces',
        data: 'Category enriched in Top',
        condition: 'Composition continuous',
        pros: ['Classical', 'Direct topology', 'Intuitive'],
        cons: ['Strict composition', 'Not homotopy-invariant', 'Point-set issues'],
        examples: ['Category of topological spaces', 'Fundamental groupoid'],
        yearIntroduced: '1960s',
        inventor: 'Classical topology'
      }
    };
    
    function App() {
      const [selected, setSelected] = useState(['quasicat', 'css']);
      const [view, setView] = useState('overview');
      
      return (
        <div className="container">
          <div className="header">
            <h1>∞-Category Models</h1>
            <div className="subtitle">The Grand Unification: All Roads Lead to ∞-Categories</div>
          </div>
          
          <div className="content">
            {view === 'overview' && <Overview setView={setView} />}
            {view === 'models' && <ModelsView selected={selected} setSelected={setSelected} />}
            {view === 'compare' && <CompareView selected={selected} />}
            {view === 'history' && <HistoryView />}
            
            <div style={{ display: 'flex', gap: '15px', marginTop: '40px', justifyContent: 'center' }}>
              <button onClick={() => setView('overview')}>Overview</button>
              <button onClick={() => setView('models')}>All Models</button>
              <button onClick={() => setView('compare')}>Compare</button>
              <button onClick={() => setView('history')}>History</button>
            </div>
          </div>
        </div>
      );
    }
    
    function Overview({ setView }) {
      return (
        <>
          <div className="theorem-box">
            <h3>The Model Independence Theorem</h3>
            <p style={{ fontSize: '1.2em', lineHeight: '2', marginTop: '20px' }}>
              There are multiple models of ∞-categories, and they are all <strong>Quillen equivalent</strong>. 
              This means they all describe the "same" mathematical structure, just from different perspectives.
            </p>
          </div>
          
          <div className="equivalence-web">
            <div className="equivalence-title">Web of Equivalences</div>
            <div className="model-graph" style={{ position: 'relative', height: '400px' }}>
              <svg style={{ position: 'absolute', width: '100%', height: '100%', zIndex: 1 }}>
                <line x1="200" y1="200" x2="400" y2="100" stroke="#667eea" strokeWidth="3" opacity="0.5" />
                <line x1="200" y1="200" x2="600" y2="200" stroke="#667eea" strokeWidth="3" opacity="0.5" />
                <line x1="200" y1="200" x2="400" y2="300" stroke="#667eea" strokeWidth="3" opacity="0.5" />
                <line x1="400" y1="100" x2="600" y2="200" stroke="#667eea" strokeWidth="3" opacity="0.5" />
                <line x1="400" y1="300" x2="600" y2="200" stroke="#667eea" strokeWidth="3" opacity="0.5" />
              </svg>
              
              <div className="node" style={{ left: '130px', top: '130px' }}>
                Quasi-<br/>Categories
              </div>
              <div className="node" style={{ left: '330px', top: '30px' }}>
                Complete<br/>Segal<br/>Spaces
              </div>
              <div className="node" style={{ left: '530px', top: '130px' }}>
                Segal<br/>Categories
              </div>
              <div className="node" style={{ left: '330px', top: '230px' }}>
                1-Complicial<br/>Sets
              </div>
            </div>
          </div>
          
          <div className="info-box insight">
            <strong>What This Means:</strong> You can prove a theorem using any model, and it will be true 
            in all other models. The choice of model is a matter of convenience, not correctness.
          </div>
          
          <div className="functor-chain">
            <div className="functor-box">Choose Model A</div>
            <div className="functor-arrow">→</div>
            <div className="functor-box">Prove Theorem</div>
            <div className="functor-arrow">→</div>
            <div className="functor-box">True in Model B</div>
          </div>
          
          <button 
            style={{ width: '100%', padding: '20px', fontSize: '1.2em', marginTop: '30px' }}
            onClick={() => setView('models')}
          >
            Explore All Models →
          </button>
        </>
      );
    }
    
    function ModelsView({ selected, setSelected }) {
      const toggleSelect = (id) => {
        if (selected.includes(id)) {
          setSelected(selected.filter(x => x !== id));
        } else if (selected.length < 2) {
          setSelected([...selected, id]);
        } else {
          setSelected([selected[1], id]);
        }
      };
      
      return (
        <>
          <h2 style={{ fontSize: '2.5em', marginBottom: '30px', textAlign: 'center', color: '#667eea' }}>
            Six Models of ∞-Categories
          </h2>
          
          <p style={{ textAlign: 'center', fontSize: '1.1em', marginBottom: '40px', color: '#666' }}>
            Select up to two models to compare (currently selected: {selected.length}/2)
          </p>
          
          <div className="model-selector">
            {Object.entries(MODELS).map(([id, model]) => (
              <div
                key={id}
                className={`model-option ${selected.includes(id) ? 'selected' : ''}`}
                onClick={() => toggleSelect(id)}
              >
                <h3>{model.name}</h3>
                <p><strong>{model.inventor}</strong> ({model.yearIntroduced})</p>
                <p style={{ marginTop: '15px' }}>{model.description}</p>
              </div>
            ))}
          </div>
          
          {selected.length === 2 && (
            <div className="info-box success" style={{ textAlign: 'center' }}>
              ✓ Two models selected! Click "Compare" to see detailed comparison.
            </div>
          )}
        </>
      );
    }
    
    function CompareView({ selected }) {
      if (selected.length !== 2) {
        return (
          <div className="info-box warning">
            Please select exactly two models to compare (go to "All Models" tab).
          </div>
        );
      }
      
      const [m1, m2] = selected.map(id => MODELS[id]);
      
      return (
        <>
          <h2 style={{ fontSize: '2.5em', marginBottom: '40px', textAlign: 'center', color: '#667eea' }}>
            Comparing Models
          </h2>
          
          <div className="comparison-panel">
            <div className="model-detail">
              <h3>{m1.name}</h3>
              
              <div className="section">
                <h4>Data</h4>
                <p>{m1.data}</p>
              </div>
              
              <div className="section">
                <h4>Condition</h4>
                <p>{m1.condition}</p>
              </div>
              
              <div className="section">
                <h4>Advantages</h4>
                <ul style={{ marginLeft: '20px', lineHeight: '2' }}>
                  {m1.pros.map((pro, i) => <li key={i}>{pro}</li>)}
                </ul>
              </div>
              
              <div className="section">
                <h4>Disadvantages</h4>
                <ul style={{ marginLeft: '20px', lineHeight: '2' }}>
                  {m1.cons.map((con, i) => <li key={i}>{con}</li>)}
                </ul>
              </div>
            </div>
            
            <div className="model-detail">
              <h3>{m2.name}</h3>
              
              <div className="section">
                <h4>Data</h4>
                <p>{m2.data}</p>
              </div>
              
              <div className="section">
                <h4>Condition</h4>
                <p>{m2.condition}</p>
              </div>
              
              <div className="section">
                <h4>Advantages</h4>
                <ul style={{ marginLeft: '20px', lineHeight: '2' }}>
                  {m2.pros.map((pro, i) => <li key={i}>{pro}</li>)}
                </ul>
              </div>
              
              <div className="section">
                <h4>Disadvantages</h4>
                <ul style={{ marginLeft: '20px', lineHeight: '2' }}>
                  {m2.cons.map((con, i) => <li key={i}>{con}</li>)}
                </ul>
              </div>
            </div>
          </div>
          
          <div className="theorem-box">
            <h3>Quillen Equivalence</h3>
            <p style={{ lineHeight: '2', fontSize: '1.1em' }}>
              The model categories of {m1.short} and {m2.short} are <strong>Quillen equivalent</strong>, 
              meaning there exist adjoint functors that induce an equivalence on the homotopy categories.
            </p>
          </div>
          
          <div className="functor-chain">
            <div className="functor-box">{m1.short}</div>
            <div className="functor-arrow">⇄</div>
            <div className="functor-box">{m2.short}</div>
          </div>
          
          <div className="info-box insight">
            <strong>Practical Impact:</strong> When working with {m1.short}, you can "port" results to {m2.short} 
            automatically. Choose whichever is more convenient for your specific problem.
          </div>
        </>
      );
    }
    
    function HistoryView() {
      return (
        <>
          <h2 style={{ fontSize: '2.5em', marginBottom: '40px', textAlign: 'center', color: '#667eea' }}>
            Historical Development
          </h2>
          
          <div className="timeline">
            <div className="timeline-item">
              <div className="timeline-marker"></div>
              <div className="timeline-content">
                <h4>1960s: Topological Categories</h4>
                <p>Classical enriched category theory over topological spaces. Strict composition, no higher homotopy.</p>
              </div>
            </div>
            
            <div className="timeline-item">
              <div className="timeline-marker"></div>
              <div className="timeline-content">
                <h4>1967: Model Categories (Quillen)</h4>
                <p>Relative categories emerge as the natural setting. Weak equivalences identified as key structure.</p>
              </div>
            </div>
            
            <div className="timeline-item">
              <div className="timeline-marker"></div>
              <div className="timeline-content">
                <h4>1980s: Weak Kan Complexes</h4>
                <p>Boardman & Vogt introduce simplicial sets with horn fillers (later called quasi-categories).</p>
              </div>
            </div>
            
            <div className="timeline-item">
              <div className="timeline-marker"></div>
              <div className="timeline-content">
                <h4>1998: Segal Categories</h4>
                <p>Hirschowitz & Simpson develop Segal categories as simplicial spaces with composition.</p>
              </div>
            </div>
            
            <div className="timeline-item">
              <div className="timeline-marker"></div>
              <div className="timeline-content">
                <h4>2001: Complete Segal Spaces</h4>
                <p>Rezk adds completeness condition, creating "Rezk spaces" - a fully homotopy-theoretic model.</p>
              </div>
            </div>
            
            <div className="timeline-item">
              <div className="timeline-marker"></div>
              <div className="timeline-content">
                <h4>2002: Quasi-Categories (Joyal)</h4>
                <p>Joyal develops comprehensive theory of quasi-categories, proving key results.</p>
              </div>
            </div>
            
            <div className="timeline-item">
              <div className="timeline-marker"></div>
              <div className="timeline-content">
                <h4>2006: 1-Complicial Sets (Verity)</h4>
                <p>Verity introduces stratified simplicial sets with algebraic flavor.</p>
              </div>
            </div>
            
            <div className="timeline-item">
              <div className="timeline-marker"></div>
              <div className="timeline-content">
                <h4>2009: Model Independence</h4>
                <p>Joyal, Tierney, Lurie prove all models are Quillen equivalent. ∞-category theory becomes model-independent!</p>
              </div>
            </div>
          </div>
          
          <div className="theorem-box">
            <h3>The Grand Synthesis</h3>
            <p style={{ lineHeight: '2', fontSize: '1.1em' }}>
              By 2010, it was clear that all approaches describe the same mathematical structure. 
              ∞-Category theory emerged as a unified framework, with multiple equivalent models providing 
              different computational and conceptual tools.
            </p>
          </div>
          
          <div className="info-box success">
            <strong>Modern Practice:</strong> Today, mathematicians freely switch between models based on 
            convenience. Quasi-categories dominate for concrete constructions, while Complete Segal Spaces 
            are preferred for homotopy-theoretic arguments.
          </div>
        </>
      );
    }
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
  
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</body>
</html>