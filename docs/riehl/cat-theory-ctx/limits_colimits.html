<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Limits & Colimits: Universal Properties Explorer</title>
  
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react.production.min.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      color: #333;
    }
    
    #root {
      width: 100%;
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1800px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }
    
    .header {
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      color: white;
      padding: 40px;
      text-align: center;
      border-radius: 12px 12px 0 0;
    }
    
    .header h1 {
      font-size: 3em;
      margin-bottom: 15px;
      font-weight: 300;
      letter-spacing: 2px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
    }
    
    .subtitle {
      font-size: 1.2em;
      opacity: 0.95;
      font-weight: 300;
    }
    
    .tabs {
      display: flex;
      background: #f8f9fa;
      border-bottom: 2px solid #dee2e6;
    }
    
    .tab {
      flex: 1;
      padding: 20px;
      border: none;
      background: transparent;
      cursor: pointer;
      font-size: 1em;
      font-weight: 500;
      color: #666;
      transition: all 0.3s ease;
      border-bottom: 4px solid transparent;
    }
    
    .tab:hover {
      background: #e9ecef;
    }
    
    .tab.active {
      color: #fa709a;
      background: white;
      border-bottom-color: #fa709a;
    }
    
    .content {
      padding: 40px;
    }
    
    .split-view {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 40px;
      margin: 30px 0;
    }
    
    .panel {
      background: #f8f9fa;
      border-radius: 16px;
      padding: 30px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }
    
    .panel-title {
      font-size: 1.8em;
      font-weight: 600;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 3px solid;
      text-align: center;
    }
    
    .panel.limit {
      background: linear-gradient(135deg, #e0f7fa 0%, #f1f8e9 100%);
    }
    
    .panel.limit .panel-title {
      color: #00796b;
      border-bottom-color: #00796b;
    }
    
    .panel.colimit {
      background: linear-gradient(135deg, #fff3e0 0%, #fce4ec 100%);
    }
    
    .panel.colimit .panel-title {
      color: #d32f2f;
      border-bottom-color: #d32f2f;
    }
    
    .diagram-canvas {
      background: white;
      border-radius: 12px;
      padding: 40px;
      min-height: 400px;
      position: relative;
      margin: 20px 0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .cone-display {
      margin: 25px 0;
      padding: 25px;
      background: white;
      border-radius: 12px;
      border: 3px solid;
    }
    
    .cone-display.limit-cone {
      border-color: #00796b;
    }
    
    .cone-display.colimit-cone {
      border-color: #d32f2f;
    }
    
    .cone-display h4 {
      margin-bottom: 15px;
      font-size: 1.2em;
    }
    
    .universal-property {
      background: linear-gradient(135deg, #fff9c4 0%, #fff59d 100%);
      border: 3px solid #f57c00;
      border-radius: 12px;
      padding: 25px;
      margin: 25px 0;
    }
    
    .universal-property h3 {
      color: #e65100;
      margin-bottom: 15px;
      font-size: 1.3em;
    }
    
    .shape-node {
      position: absolute;
      width: 70px;
      height: 70px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 700;
      font-size: 1.1em;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 10;
    }
    
    .shape-node:hover {
      transform: scale(1.15);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }
    
    .shape-node.limit-apex {
      background: linear-gradient(135deg, #00796b 0%, #004d40 100%);
      border: 4px solid #004d40;
    }
    
    .shape-node.colimit-apex {
      background: linear-gradient(135deg, #d32f2f 0%, #b71c1c 100%);
      border: 4px solid #b71c1c;
    }
    
    .shape-node.diagram-object {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }
    
    .shape-node.test-object {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      border: 3px dashed #fff;
    }
    
    button {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      color: white;
      cursor: pointer;
      font-size: 0.95em;
      font-weight: 600;
      transition: all 0.2s ease;
      margin: 5px;
      box-shadow: 0 4px 12px rgba(250, 112, 154, 0.3);
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(250, 112, 154, 0.4);
    }
    
    button.limit-style {
      background: linear-gradient(135deg, #00796b 0%, #004d40 100%);
    }
    
    button.colimit-style {
      background: linear-gradient(135deg, #d32f2f 0%, #b71c1c 100%);
    }
    
    .info-box {
      background: #e3f2fd;
      border-left: 4px solid #2196f3;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
      line-height: 1.7;
    }
    
    .info-box.success {
      background: #e8f5e9;
      border-left-color: #4caf50;
    }
    
    .info-box.warning {
      background: #fff3e0;
      border-left-color: #ff9800;
    }
    
    .math-formula {
      background: white;
      padding: 20px;
      margin: 20px 0;
      border-radius: 12px;
      border: 2px solid #dee2e6;
      font-family: 'Times New Roman', serif;
      text-align: center;
      font-size: 1.2em;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
    }
    
    .example-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      margin: 30px 0;
    }
    
    .example-card {
      background: white;
      border-radius: 12px;
      padding: 25px;
      cursor: pointer;
      border: 3px solid transparent;
      transition: all 0.2s ease;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    
    .example-card:hover {
      border-color: #fa709a;
      transform: translateY(-4px);
      box-shadow: 0 6px 20px rgba(250, 112, 154, 0.3);
    }
    
    .example-card.active {
      border-color: #fee140;
      background: linear-gradient(135deg, #fa709a10 0%, #fee14010 100%);
    }
    
    .example-card h4 {
      color: #fa709a;
      margin-bottom: 12px;
      font-size: 1.2em;
    }
    
    .example-card p {
      font-size: 0.95em;
      color: #666;
      line-height: 1.6;
    }
    
    .comparison-table {
      width: 100%;
      margin: 30px 0;
      border-collapse: collapse;
      background: white;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    
    .comparison-table th,
    .comparison-table td {
      padding: 18px;
      text-align: left;
      border-bottom: 1px solid #dee2e6;
    }
    
    .comparison-table th {
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      color: white;
      font-weight: 600;
      font-size: 1.05em;
    }
    
    .comparison-table tr:last-child td {
      border-bottom: none;
    }
    
    .comparison-table tr:hover {
      background: #f8f9fa;
    }
    
    .construction-steps {
      background: white;
      border-radius: 12px;
      padding: 25px;
      margin: 25px 0;
    }
    
    .construction-steps h4 {
      color: #fa709a;
      margin-bottom: 15px;
      font-size: 1.2em;
    }
    
    .step {
      padding: 15px 20px;
      margin: 10px 0;
      background: #f8f9fa;
      border-left: 4px solid #fa709a;
      border-radius: 6px;
      position: relative;
      padding-left: 60px;
    }
    
    .step::before {
      content: attr(data-step);
      position: absolute;
      left: 15px;
      top: 50%;
      transform: translateY(-50%);
      width: 30px;
      height: 30px;
      background: #fa709a;
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
    }
    
    .duality-indicator {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
      color: white;
      padding: 15px 25px;
      border-radius: 50px;
      box-shadow: 0 6px 20px rgba(250, 112, 154, 0.4);
      font-weight: 600;
      z-index: 1000;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .duality-indicator:hover {
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState } = React;
    
    // ============================================================================
    // MATHEMATICAL CORE: Limits & Colimits
    // ============================================================================
    
    const LIMIT_EXAMPLES = {
      product: {
        name: 'Product',
        description: 'Limit of discrete diagram',
        type: 'limit',
        diagram: [
          { id: 'A', label: 'A', x: 100, y: 200 },
          { id: 'B', label: 'B', x: 300, y: 200 }
        ],
        morphisms: [],
        apex: { id: 'A√óB', label: 'A √ó B', x: 200, y: 80 },
        projections: [
          { source: 'A√óB', target: 'A', label: 'œÄ‚ÇÅ' },
          { source: 'A√óB', target: 'B', label: 'œÄ‚ÇÇ' }
        ],
        universalProperty: 'For any object X with morphisms f: X ‚Üí A and g: X ‚Üí B, there exists a unique h: X ‚Üí A√óB making the diagram commute.'
      },
      equalizer: {
        name: 'Equalizer',
        description: 'Limit of parallel pair',
        type: 'limit',
        diagram: [
          { id: 'A', label: 'A', x: 120, y: 200 },
          { id: 'B', label: 'B', x: 300, y: 200 }
        ],
        morphisms: [
          { source: 'A', target: 'B', label: 'f', offset: -15 },
          { source: 'A', target: 'B', label: 'g', offset: 15 }
        ],
        apex: { id: 'E', label: 'Eq(f,g)', x: 200, y: 80 },
        projections: [
          { source: 'E', target: 'A', label: 'e' }
        ],
        universalProperty: 'E is the largest subobject of A where f and g agree: f‚àòe = g‚àòe'
      },
      pullback: {
        name: 'Pullback',
        description: 'Limit of cospan',
        type: 'limit',
        diagram: [
          { id: 'A', label: 'A', x: 100, y: 200 },
          { id: 'C', label: 'C', x: 200, y: 280 },
          { id: 'B', label: 'B', x: 300, y: 200 }
        ],
        morphisms: [
          { source: 'A', target: 'C', label: 'f' },
          { source: 'B', target: 'C', label: 'g' }
        ],
        apex: { id: 'P', label: 'P', x: 200, y: 80 },
        projections: [
          { source: 'P', target: 'A', label: 'p‚ÇÅ' },
          { source: 'P', target: 'B', label: 'p‚ÇÇ' }
        ],
        universalProperty: 'P consists of pairs (a,b) where f(a) = g(b), with the universal property for commutative squares.'
      }
    };
    
    const COLIMIT_EXAMPLES = {
      coproduct: {
        name: 'Coproduct',
        description: 'Colimit of discrete diagram',
        type: 'colimit',
        diagram: [
          { id: 'A', label: 'A', x: 100, y: 80 },
          { id: 'B', label: 'B', x: 300, y: 80 }
        ],
        morphisms: [],
        apex: { id: 'A+B', label: 'A ‚äî B', x: 200, y: 220 },
        projections: [
          { source: 'A', target: 'A+B', label: 'i‚ÇÅ' },
          { source: 'B', target: 'A+B', label: 'i‚ÇÇ' }
        ],
        universalProperty: 'For any object X with morphisms f: A ‚Üí X and g: B ‚Üí X, there exists a unique h: A‚äîB ‚Üí X making the diagram commute.'
      },
      coequalizer: {
        name: 'Coequalizer',
        description: 'Colimit of parallel pair',
        type: 'colimit',
        diagram: [
          { id: 'A', label: 'A', x: 100, y: 100 },
          { id: 'B', label: 'B', x: 280, y: 100 }
        ],
        morphisms: [
          { source: 'A', target: 'B', label: 'f', offset: -15 },
          { source: 'A', target: 'B', label: 'g', offset: 15 }
        ],
        apex: { id: 'Q', label: 'Coeq(f,g)', x: 200, y: 240 },
        projections: [
          { source: 'B', target: 'Q', label: 'q' }
        ],
        universalProperty: 'Q is the quotient of B that identifies f and g: q‚àòf = q‚àòg'
      },
      pushout: {
        name: 'Pushout',
        description: 'Colimit of span',
        type: 'colimit',
        diagram: [
          { id: 'C', label: 'C', x: 200, y: 60 },
          { id: 'A', label: 'A', x: 100, y: 140 },
          { id: 'B', label: 'B', x: 300, y: 140 }
        ],
        morphisms: [
          { source: 'C', target: 'A', label: 'f' },
          { source: 'C', target: 'B', label: 'g' }
        ],
        apex: { id: 'P', label: 'P', x: 200, y: 250 },
        projections: [
          { source: 'A', target: 'P', label: 'i‚ÇÅ' },
          { source: 'B', target: 'P', label: 'i‚ÇÇ' }
        ],
        universalProperty: 'P glues A and B together along C, with the universal property for cocones.'
      }
    };
    
    // ============================================================================
    // REACT COMPONENTS
    // ============================================================================
    
    function App() {
      const [state, setState] = useState({
        currentTab: 0,
        selectedLimit: 'product',
        selectedColimit: 'coproduct',
        showUniversalProperty: false,
        dualityMode: false
      });
      
      const tabs = [
        { id: 0, name: 'Limits vs Colimits' },
        { id: 1, name: 'Products & Coproducts' },
        { id: 2, name: 'Equalizers & Coequalizers' },
        { id: 3, name: 'Pullbacks & Pushouts' },
        { id: 4, name: 'Duality' }
      ];
      
      return (
        <div className="container">
          <div className="header">
            <h1>Limits & Colimits</h1>
            <div className="subtitle">
              Universal Properties and Categorical Duality
            </div>
          </div>
          
          <div className="tabs">
            {tabs.map(tab => (
              <button
                key={tab.id}
                className={`tab ${state.currentTab === tab.id ? 'active' : ''}`}
                onClick={() => setState(prev => ({ ...prev, currentTab: tab.id }))}
              >
                {tab.name}
              </button>
            ))}
          </div>
          
          <div className="content">
            <TabContent state={state} setState={setState} />
          </div>
          
          {state.dualityMode && (
            <div 
              className="duality-indicator"
              onClick={() => setState(prev => ({ ...prev, dualityMode: false }))}
            >
              üîÑ Duality Mode Active
            </div>
          )}
        </div>
      );
    }
    
    function TabContent({ state, setState }) {
      switch(state.currentTab) {
        case 0:
          return <IntroTab />;
        case 1:
          return <ProductCoproductTab state={state} setState={setState} />;
        case 2:
          return <EqualizerCoequalizerTab state={state} setState={setState} />;
        case 3:
          return <PullbackPushoutTab state={state} setState={setState} />;
        case 4:
          return <DualityTab state={state} setState={setState} />;
        default:
          return <IntroTab />;
      }
    }
    
    function IntroTab() {
      return (
        <>
          <div className="universal-property">
            <h3>What are Limits and Colimits?</h3>
            <p style={{ lineHeight: '1.8', fontSize: '1.05em', marginTop: '15px' }}>
              Limits and colimits are <strong>universal constructions</strong> that capture 
              the essence of "putting things together" and "taking things apart" in categories.
            </p>
            <div className="math-formula" style={{ marginTop: '20px' }}>
              Limit = "Best Cone" &nbsp;&nbsp;&nbsp;&nbsp; Colimit = "Best Cocone"
            </div>
          </div>
          
          <div className="split-view">
            <div className="panel limit">
              <div className="panel-title">Limit</div>
              <div style={{ padding: '20px' }}>
                <p style={{ lineHeight: '1.8', marginBottom: '15px' }}>
                  A limit is an object L with morphisms to each object in a diagram, 
                  such that any other cone factors <strong>uniquely</strong> through L.
                </p>
                <div className="construction-steps">
                  <h4>How to construct:</h4>
                  <div className="step" data-step="1">
                    Start with a diagram D : J ‚Üí C
                  </div>
                  <div className="step" data-step="2">
                    Find object L with morphisms œÄ‚±º : L ‚Üí D(j)
                  </div>
                  <div className="step" data-step="3">
                    For any cone (X, {f‚±º}), get unique u : X ‚Üí L
                  </div>
                  <div className="step" data-step="4">
                    Verify: œÄ‚±º ‚àò u = f‚±º for all j
                  </div>
                </div>
                <div className="info-box success">
                  <strong>Intuition:</strong> The limit is the "most efficient" way to map into all diagram objects simultaneously.
                </div>
              </div>
            </div>
            
            <div className="panel colimit">
              <div className="panel-title">Colimit</div>
              <div style={{ padding: '20px' }}>
                <p style={{ lineHeight: '1.8', marginBottom: '15px' }}>
                  A colimit is an object L with morphisms from each object in a diagram, 
                  such that any other cocone factors <strong>uniquely</strong> through L.
                </p>
                <div className="construction-steps">
                  <h4>How to construct:</h4>
                  <div className="step" data-step="1">
                    Start with a diagram D : J ‚Üí C
                  </div>
                  <div className="step" data-step="2">
                    Find object L with morphisms Œπ‚±º : D(j) ‚Üí L
                  </div>
                  <div className="step" data-step="3">
                    For any cocone (X, {f‚±º}), get unique u : L ‚Üí X
                  </div>
                  <div className="step" data-step="4">
                    Verify: u ‚àò Œπ‚±º = f‚±º for all j
                  </div>
                </div>
                <div className="info-box success">
                  <strong>Intuition:</strong> The colimit is the "most efficient" way to map out of all diagram objects simultaneously.
                </div>
              </div>
            </div>
          </div>
          
          <table className="comparison-table">
            <thead>
              <tr>
                <th>Property</th>
                <th>Limit</th>
                <th>Colimit</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Direction</strong></td>
                <td>Morphisms FROM limit</td>
                <td>Morphisms TO colimit</td>
              </tr>
              <tr>
                <td><strong>Universal Property</strong></td>
                <td>Terminal cone</td>
                <td>Initial cocone</td>
              </tr>
              <tr>
                <td><strong>Empty Diagram</strong></td>
                <td>Terminal object</td>
                <td>Initial object</td>
              </tr>
              <tr>
                <td><strong>Discrete Diagram</strong></td>
                <td>Product</td>
                <td>Coproduct</td>
              </tr>
              <tr>
                <td><strong>Parallel Pair</strong></td>
                <td>Equalizer</td>
                <td>Coequalizer</td>
              </tr>
              <tr>
                <td><strong>Sets</strong></td>
                <td>Cartesian product</td>
                <td>Disjoint union</td>
              </tr>
              <tr>
                <td><strong>Groups</strong></td>
                <td>Direct product</td>
                <td>Free product</td>
              </tr>
            </tbody>
          </table>
        </>
      );
    }
    
    function ProductCoproductTab({ state, setState }) {
      const limitEx = LIMIT_EXAMPLES.product;
      const colimitEx = COLIMIT_EXAMPLES.coproduct;
      
      return (
        <>
          <div className="split-view">
            <DiagramPanel example={limitEx} type="limit" />
            <DiagramPanel example={colimitEx} type="colimit" />
          </div>
          
          <div className="universal-property">
            <h3>Products and Coproducts</h3>
            <div className="split-view">
              <div>
                <h4 style={{ color: '#00796b', marginBottom: '15px' }}>Product (Limit)</h4>
                <p style={{ lineHeight: '1.7' }}>
                  The product A √ó B comes with projection morphisms œÄ‚ÇÅ: A√óB ‚Üí A and œÄ‚ÇÇ: A√óB ‚Üí B.
                </p>
                <p style={{ lineHeight: '1.7', marginTop: '10px' }}>
                  For any object X with morphisms f: X ‚Üí A and g: X ‚Üí B, there's a unique 
                  morphism ‚ü®f,g‚ü©: X ‚Üí A√óB making the diagram commute.
                </p>
              </div>
              <div>
                <h4 style={{ color: '#d32f2f', marginBottom: '15px' }}>Coproduct (Colimit)</h4>
                <p style={{ lineHeight: '1.7' }}>
                  The coproduct A ‚äî B comes with injection morphisms i‚ÇÅ: A ‚Üí A‚äîB and i‚ÇÇ: B ‚Üí A‚äîB.
                </p>
                <p style={{ lineHeight: '1.7', marginTop: '10px' }}>
                  For any object X with morphisms f: A ‚Üí X and g: B ‚Üí X, there's a unique 
                  morphism [f,g]: A‚äîB ‚Üí X making the diagram commute.
                </p>
              </div>
            </div>
          </div>
          
          <div className="info-box">
            <strong>Examples:</strong>
            <ul style={{ marginLeft: '25px', marginTop: '10px', lineHeight: '2' }}>
              <li><strong>Set:</strong> Product = Cartesian product, Coproduct = Disjoint union</li>
              <li><strong>Grp:</strong> Product = Direct product, Coproduct = Free product</li>
              <li><strong>Top:</strong> Product = Product topology, Coproduct = Disjoint union topology</li>
              <li><strong>Vect:</strong> Product = Direct sum, Coproduct = Direct sum (they coincide!)</li>
            </ul>
          </div>
        </>
      );
    }
    
    function EqualizerCoequalizerTab({ state, setState }) {
      const limitEx = LIMIT_EXAMPLES.equalizer;
      const colimitEx = COLIMIT_EXAMPLES.coequalizer;
      
      return (
        <>
          <div className="split-view">
            <DiagramPanel example={limitEx} type="limit" />
            <DiagramPanel example={colimitEx} type="colimit" />
          </div>
          
          <div className="universal-property">
            <h3>Equalizers and Coequalizers</h3>
            <div className="split-view">
              <div>
                <h4 style={{ color: '#00796b', marginBottom: '15px' }}>Equalizer (Limit)</h4>
                <p style={{ lineHeight: '1.7' }}>
                  Given f, g: A ‚áâ B, the equalizer Eq(f,g) is the largest subobject of A on which f and g agree.
                </p>
                <div className="math-formula" style={{ fontSize: '1em' }}>
                  f ‚àò e = g ‚àò e
                </div>
                <p style={{ lineHeight: '1.7', marginTop: '10px' }}>
                  Universal property: Any morphism into A that equalizes f and g factors uniquely through e.
                </p>
              </div>
              <div>
                <h4 style={{ color: '#d32f2f', marginBottom: '15px' }}>Coequalizer (Colimit)</h4>
                <p style={{ lineHeight: '1.7' }}>
                  Given f, g: A ‚áâ B, the coequalizer Coeq(f,g) is the quotient of B that identifies f(a) with g(a) for all a.
                </p>
                <div className="math-formula" style={{ fontSize: '1em' }}>
                  q ‚àò f = q ‚àò g
                </div>
                <p style={{ lineHeight: '1.7', marginTop: '10px' }}>
                  Universal property: Any morphism from B that coequalizes f and g factors uniquely through q.
                </p>
              </div>
            </div>
          </div>
          
          <div className="info-box warning">
            <strong>Application:</strong> Coequalizers are used to construct quotient objects. For example, 
            the quotient group G/N is a coequalizer in the category of groups.
          </div>
        </>
      );
    }
    
    function PullbackPushoutTab({ state, setState }) {
      const limitEx = LIMIT_EXAMPLES.pullback;
      const colimitEx = COLIMIT_EXAMPLES.pushout;
      
      return (
        <>
          <div className="split-view">
            <DiagramPanel example={limitEx} type="limit" />
            <DiagramPanel example={colimitEx} type="colimit" />
          </div>
          
          <div className="universal-property">
            <h3>Pullbacks and Pushouts</h3>
            <div className="split-view">
              <div>
                <h4 style={{ color: '#00796b', marginBottom: '15px' }}>Pullback (Limit)</h4>
                <p style={{ lineHeight: '1.7' }}>
                  The pullback P of f: A ‚Üí C and g: B ‚Üí C consists of pairs (a,b) where f(a) = g(b).
                </p>
                <div className="math-formula" style={{ fontSize: '1em' }}>
                  f ‚àò p‚ÇÅ = g ‚àò p‚ÇÇ
                </div>
                <p style={{ lineHeight: '1.7', marginTop: '10px' }}>
                  Universal property: Any commutative square factors uniquely through P.
                </p>
              </div>
              <div>
                <h4 style={{ color: '#d32f2f', marginBottom: '15px' }}>Pushout (Colimit)</h4>
                <p style={{ lineHeight: '1.7' }}>
                  The pushout P of f: C ‚Üí A and g: C ‚Üí B glues A and B together along their common subobject C.
                </p>
                <div className="math-formula" style={{ fontSize: '1em' }}>
                  i‚ÇÅ ‚àò f = i‚ÇÇ ‚àò g
                </div>
                <p style={{ lineHeight: '1.7', marginTop: '10px' }}>
                  Universal property: Any commutative square factors uniquely through P.
                </p>
              </div>
            </div>
          </div>
          
          <div className="info-box">
            <strong>Examples:</strong>
            <ul style={{ marginLeft: '25px', marginTop: '10px', lineHeight: '2' }}>
              <li><strong>Set:</strong> Pullback = {(a,b) | f(a) = g(b)}, Pushout = (A‚äîB)/~</li>
              <li><strong>Top:</strong> Pullback = Fibered product, Pushout = Gluing spaces</li>
              <li><strong>Groups:</strong> Pullback = Fibered product, Pushout = Amalgamated free product</li>
            </ul>
          </div>
        </>
      );
    }
    
    function DualityTab({ state, setState }) {
      return (
        <>
          <div className="universal-property">
            <h3>Categorical Duality</h3>
            <p style={{ lineHeight: '1.8', fontSize: '1.05em', marginTop: '15px' }}>
              Limits and colimits are <strong>dual</strong> concepts. Every statement about limits 
              has a corresponding dual statement about colimits obtained by reversing all arrows.
            </p>
          </div>
          
          <div style={{ textAlign: 'center', margin: '40px 0' }}>
            <button
              className="highlight"
              style={{ fontSize: '1.2em', padding: '15px 40px' }}
              onClick={() => setState(prev => ({ ...prev, dualityMode: !prev.dualityMode }))}
            >
              {state.dualityMode ? 'Disable' : 'Enable'} Duality Mode
            </button>
          </div>
          
          <div className="construction-steps">
            <h4>How to Dualize:</h4>
            <div className="step" data-step="1">
              Take any statement or diagram about limits
            </div>
            <div className="step" data-step="2">
              Reverse all arrows (f: A ‚Üí B becomes f: B ‚Üí A)
            </div>
            <div className="step" data-step="3">
              Replace "limit" with "colimit", "cone" with "cocone"
            </div>
            <div className="step" data-step="4">
              The resulting statement is automatically true!
            </div>
          </div>
          
          <table className="comparison-table">
            <thead>
              <tr>
                <th>Concept</th>
                <th>Original</th>
                <th>Dual</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Object</strong></td>
                <td>Object</td>
                <td>Object</td>
              </tr>
              <tr>
                <td><strong>Morphism</strong></td>
                <td>f : A ‚Üí B</td>
                <td>f : B ‚Üí A</td>
              </tr>
              <tr>
                <td><strong>Terminal</strong></td>
                <td>Terminal object</td>
                <td>Initial object</td>
              </tr>
              <tr>
                <td><strong>Product</strong></td>
                <td>A √ó B</td>
                <td>A ‚äî B (Coproduct)</td>
              </tr>
              <tr>
                <td><strong>Monomorphism</strong></td>
                <td>Mono</td>
                <td>Epimorphism</td>
              </tr>
              <tr>
                <td><strong>Limit</strong></td>
                <td>lim D</td>
                <td>colim D (Colimit)</td>
              </tr>
              <tr>
                <td><strong>Pullback</strong></td>
                <td>Limit of cospan</td>
                <td>Pushout (Colimit of span)</td>
              </tr>
              <tr>
                <td><strong>Equalizer</strong></td>
                <td>Eq(f,g)</td>
                <td>Coeq(f,g) (Coequalizer)</td>
              </tr>
            </tbody>
          </table>
          
          <div className="info-box success">
            <strong>The Duality Principle:</strong> For every theorem in category theory, 
            the dual theorem (obtained by reversing arrows) is also true. This means we get 
            "two theorems for the price of one"!
          </div>
          
          <div className="info-box warning">
            <strong>Caveat:</strong> While the dual statement is automatically true in the 
            opposite category C·µí·µñ, whether it's true in the original category C depends on 
            whether C has the required colimits.
          </div>
        </>
      );
    }
    
    function DiagramPanel({ example, type }) {
      const isLimit = type === 'limit';
      
      return (
        <div className={`panel ${type}`}>
          <div className="panel-title">{example.name}</div>
          <p style={{ textAlign: 'center', marginBottom: '20px', fontStyle: 'italic' }}>
            {example.description}
          </p>
          
          <div className="diagram-canvas">
            <svg style={{ position: 'absolute', width: '100%', height: '100%', pointerEvents: 'none' }}>
              <defs>
                <marker id={`arrow-${type}`} markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                  <path d="M0,0 L0,6 L9,3 z" fill={isLimit ? '#00796b' : '#d32f2f'} />
                </marker>
              </defs>
              
              {/* Diagram morphisms */}
              {example.morphisms.map((morph, idx) => {
                const source = example.diagram.find(o => o.id === morph.source);
                const target = example.diagram.find(o => o.id === morph.target);
                if (!source || !target) return null;
                
                const dx = target.x - source.x;
                const dy = target.y - source.y + (morph.offset || 0);
                const dist = Math.sqrt(dx * dx + dy * dy);
                const offset = 35;
                
                const x1 = source.x + (dx / dist) * offset;
                const y1 = source.y + (dy / dist) * offset;
                const x2 = target.x - (dx / dist) * offset;
                const y2 = target.y - (dy / dist) * offset;
                
                return (
                  <g key={idx}>
                    <line
                      x1={x1} y1={y1} x2={x2} y2={y2}
                      stroke="#667eea"
                      strokeWidth="3"
                      markerEnd="url(#arrow-limit)"
                    />
                    <text
                      x={(source.x + target.x) / 2}
                      y={(source.y + target.y) / 2 - 10 + (morph.offset || 0)}
                      textAnchor="middle"
                      fontSize="16"
                      fontWeight="600"
                      fill="#333"
                    >
                      {morph.label}
                    </text>
                  </g>
                );
              })}
              
              {/* Cone/Cocone morphisms */}
              {example.projections.map((proj, idx) => {
                const source = isLimit ? example.apex : example.diagram.find(o => o.id === proj.source);
                const target = isLimit ? example.diagram.find(o => o.id === proj.target) : example.apex;
                if (!source || !target) return null;
                
                const dx = target.x - source.x;
                const dy = target.y - source.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const offset = 35;
                
                const x1 = source.x + (dx / dist) * offset;
                const y1 = source.y + (dy / dist) * offset;
                const x2 = target.x - (dx / dist) * offset;
                const y2 = target.y - (dy / dist) * offset;
                
                return (
                  <g key={`proj-${idx}`}>
                    <line
                      x1={x1} y1={y1} x2={x2} y2={y2}
                      stroke={isLimit ? '#00796b' : '#d32f2f'}
                      strokeWidth="3"
                      strokeDasharray="5,5"
                      markerEnd={`url(#arrow-${type})`}
                    />
                    <text
                      x={(source.x + target.x) / 2 - 20}
                      y={(source.y + target.y) / 2}
                      textAnchor="middle"
                      fontSize="16"
                      fontWeight="600"
                      fill={isLimit ? '#00796b' : '#d32f2f'}
                    >
                      {proj.label}
                    </text>
                  </g>
                );
              })}
            </svg>
            
            {/* Diagram objects */}
            {example.diagram.map(obj => (
              <div
                key={obj.id}
                className="shape-node diagram-object"
                style={{ left: obj.x - 35, top: obj.y - 35 }}
              >
                {obj.label}
              </div>
            ))}
            
            {/* Apex */}
            <div
              className={`shape-node ${isLimit ? 'limit-apex' : 'colimit-apex'}`}
              style={{ left: example.apex.x - 35, top: example.apex.y - 35 }}
            >
              {example.apex.label}
            </div>
          </div>
          
          <div className={`cone-display ${isLimit ? 'limit-cone' : 'colimit-cone'}`}>
            <h4 style={{ color: isLimit ? '#00796b' : '#d32f2f' }}>
              Universal Property
            </h4>
            <p style={{ lineHeight: '1.7', fontSize: '0.95em' }}>
              {example.universalProperty}
            </p>
          </div>
        </div>
      );
    }
    
    // ============================================================================
    // RENDER
    // ============================================================================
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
  
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</body>
</html>