<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Horn Filling Playground - Simplicial HoTT Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e0e0e0;
            overflow-x: hidden;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            text-align: center;
            padding: 30px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            font-size: 2.5em;
            color: #4a90e2;
            margin-bottom: 10px;
            text-shadow: 0 0 20px rgba(74, 144, 226, 0.3);
        }
        
        .subtitle {
            font-size: 1.2em;
            color: #a0a0a0;
            font-style: italic;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 3fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .canvas-area {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        canvas {
            width: 100%;
            height: 600px;
            background: #0f0f1e;
            border-radius: 10px;
            cursor: crosshair;
            border: 2px solid #4a90e2;
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-section {
            margin-bottom: 25px;
        }
        
        .control-section h3 {
            color: #4a90e2;
            margin-bottom: 15px;
            font-size: 1.2em;
            border-bottom: 2px solid #4a90e2;
            padding-bottom: 5px;
        }
        
        .tool-btn, .action-btn, .example-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }
        
        .tool-btn {
            background: #2c3e50;
            color: #ecf0f1;
        }
        
        .tool-btn.active {
            background: #4a90e2;
            color: white;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.5);
        }
        
        .tool-btn:hover {
            background: #34495e;
            transform: translateY(-2px);
        }
        
        .action-btn {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }
        
        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.4);
        }
        
        .action-btn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        .example-btn {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            color: white;
        }
        
        .example-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(155, 89, 182, 0.4);
        }
        
        .status-panel {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .status-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }
        
        .status-label {
            color: #a0a0a0;
        }
        
        .status-value {
            color: #4a90e2;
            font-weight: bold;
        }
        
        .badge {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9em;
            font-weight: bold;
        }
        
        .badge-success {
            background: #2ecc71;
            color: white;
        }
        
        .badge-error {
            background: #e74c3c;
            color: white;
        }
        
        .badge-warning {
            background: #f39c12;
            color: white;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .info-panel h3 {
            color: #4a90e2;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .filler-visualization {
            width: 100%;
            height: 200px;
            background: #0f0f1e;
            border-radius: 10px;
            border: 2px solid #4a90e2;
            position: relative;
            overflow: hidden;
        }
        
        .explanation {
            background: rgba(74, 144, 226, 0.1);
            border-left: 4px solid #4a90e2;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        
        .math-notation {
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 0.95em;
            overflow-x: auto;
        }
        
        .tutorial-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .tutorial-overlay.active {
            display: flex;
        }
        
        .tutorial-box {
            background: #1a1a2e;
            border: 2px solid #4a90e2;
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            box-shadow: 0 0 50px rgba(74, 144, 226, 0.5);
        }
        
        .tutorial-box h2 {
            color: #4a90e2;
            margin-bottom: 20px;
        }
        
        .tutorial-box p {
            line-height: 1.6;
            margin-bottom: 15px;
        }
        
        .tutorial-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .tutorial-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        
        .tutorial-btn.prev {
            background: #7f8c8d;
            color: white;
        }
        
        .tutorial-btn.next {
            background: #4a90e2;
            color: white;
        }
        
        .tutorial-btn:hover {
            transform: translateY(-2px);
        }
        
        .help-icon {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: #4a90e2;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2em;
            color: white;
            cursor: pointer;
            box-shadow: 0 5px 20px rgba(74, 144, 226, 0.5);
            transition: all 0.3s ease;
            z-index: 999;
        }
        
        .help-icon:hover {
            transform: scale(1.1);
            box-shadow: 0 8px 30px rgba(74, 144, 226, 0.7);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üî∑ Horn Filling Playground</h1>
            <p class="subtitle">Interactive Simplicial Homotopy Type Theory Explorer</p>
        </header>
        
        <div class="main-grid">
            <div class="canvas-area">
                <canvas id="mainCanvas"></canvas>
            </div>
            
            <div class="controls">
                <div class="control-section">
                    <h3>üõ†Ô∏è Tools</h3>
                    <button class="tool-btn active" data-tool="vertex">Add Vertex</button>
                    <button class="tool-btn" data-tool="edge">Create Edge</button>
                    <button class="tool-btn" data-tool="remove">Remove Edge</button>
                    <button class="tool-btn" data-tool="select">Select/Move</button>
                </div>
                
                <div class="control-section">
                    <h3>‚ö° Actions</h3>
                    <button class="action-btn" id="findFillersBtn">Find Fillers</button>
                    <button class="action-btn" id="testContractibilityBtn">Test Contractibility</button>
                    <button class="action-btn" id="clearBtn">Clear Canvas</button>
                </div>
                
                <div class="control-section">
                    <h3>üìä Status</h3>
                    <div class="status-panel">
                        <div class="status-item">
                            <span class="status-label">Vertices:</span>
                            <span class="status-value" id="vertexCount">0</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Edges:</span>
                            <span class="status-value" id="edgeCount">0</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Horns:</span>
                            <span class="status-value" id="hornCount">0</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Fillers:</span>
                            <span class="status-value" id="fillerCount">-</span>
                        </div>
                        <div class="status-item">
                            <span class="status-label">Contractible:</span>
                            <span class="status-value" id="contractibleStatus">-</span>
                        </div>
                    </div>
                </div>
                
                <div class="control-section">
                    <h3>üìö Examples</h3>
                    <button class="example-btn" data-example="temporal">Temporal AA</button>
                    <button class="example-btn" data-example="shader">Shader Compilation</button>
                    <button class="example-btn" data-example="mesh">Mesh Morphing</button>
                    <button class="example-btn" data-example="physics">Physics Simulation</button>
                </div>
            </div>
        </div>
        
        <div class="info-grid">
            <div class="info-panel">
                <h3>üìê Shape Information</h3>
                <div id="shapeInfo">
                    <p>Click "Add Vertex" and click on canvas to start building shapes.</p>
                    <div class="math-notation">
Œî¬≤ = {(t‚ÇÅ,t‚ÇÇ) : ùüö¬≤ | t‚ÇÇ ‚â§ t‚ÇÅ}  (2-simplex)
Œõ¬π¬≤ = Œî¬≤ \ {bottom edge}      (2-horn)
                    </div>
                    <div class="explanation">
                        <strong>What's a horn?</strong><br>
                        A horn is a simplex with one face removed. In graphics terms: imagine a triangle mesh face where one edge is missing‚Äîthat's a horn! The "horn-filling problem" asks: can we uniquely determine the missing edge?
                    </div>
                </div>
            </div>
            
            <div class="info-panel">
                <h3>üéØ Contractibility Analysis</h3>
                <canvas id="fillerCanvas" class="filler-visualization"></canvas>
                <div id="contractibilityInfo" style="margin-top: 15px;">
                    <p>Create a horn and find fillers to see contractibility visualization.</p>
                    <div class="explanation">
                        <strong>Contractible space:</strong><br>
                        All fillers collapse to a single point (essentially unique). This means composition in the ‚àû-category is unique up to homotopy!
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="tutorial-overlay" id="tutorialOverlay">
        <div class="tutorial-box">
            <h2 id="tutorialTitle">Welcome!</h2>
            <div id="tutorialContent"></div>
            <div class="tutorial-nav">
                <button class="tutorial-btn prev" id="tutorialPrev">Previous</button>
                <button class="tutorial-btn next" id="tutorialNext">Next</button>
            </div>
        </div>
    </div>
    
    <div class="help-icon" id="helpIcon">?</div>
    
    <script>
        // ==================== DATA STRUCTURES ====================
        
        class Vertex {
            constructor(x, y, label) {
                this.x = x;
                this.y = y;
                this.label = label;
                this.radius = 10;
            }
            
            contains(px, py) {
                const dx = px - this.x;
                const dy = py - this.y;
                return Math.sqrt(dx*dx + dy*dy) <= this.radius;
            }
            
            draw(ctx, selected = false) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
                ctx.fillStyle = selected ? '#f39c12' : '#4a90e2';
                ctx.fill();
                ctx.strokeStyle = '#ecf0f1';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Label
                ctx.fillStyle = '#ecf0f1';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.label, this.x, this.y);
                
                // Name label
                ctx.font = '12px Arial';
                ctx.fillText(this.label, this.x, this.y - 20);
            }
        }
        
        class Edge {
            constructor(start, end, label, isFiller = false, isMissing = false) {
                this.start = start;
                this.end = end;
                this.label = label;
                this.isFiller = isFiller;
                this.isMissing = isMissing;
            }
            
            draw(ctx) {
                ctx.beginPath();
                ctx.moveTo(this.start.x, this.start.y);
                ctx.lineTo(this.end.x, this.end.y);
                
                if (this.isMissing) {
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([10, 5]);
                } else if (this.isFiller) {
                    ctx.strokeStyle = '#9b59b6';
                    ctx.lineWidth = 4;
                    ctx.setLineDash([]);
                } else {
                    ctx.strokeStyle = '#2ecc71';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Arrow head
                this.drawArrowHead(ctx);
                
                // Label
                const midX = (this.start.x + this.end.x) / 2;
                const midY = (this.start.y + this.end.y) / 2;
                ctx.fillStyle = '#ecf0f1';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.label, midX, midY - 10);
            }
            
            drawArrowHead(ctx) {
                const angle = Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x);
                const headLength = 15;
                const headAngle = Math.PI / 6;
                
                const x = this.end.x - Math.cos(angle) * this.end.radius;
                const y = this.end.y - Math.sin(angle) * this.end.radius;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(
                    x - headLength * Math.cos(angle - headAngle),
                    y - headLength * Math.sin(angle - headAngle)
                );
                ctx.moveTo(x, y);
                ctx.lineTo(
                    x - headLength * Math.cos(angle + headAngle),
                    y - headLength * Math.sin(angle + headAngle)
                );
                ctx.stroke();
            }
        }
        
        // ==================== MAIN APPLICATION ====================
        
        class HornFillingPlayground {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.fillerCanvas = document.getElementById('fillerCanvas');
                this.fillerCtx = this.fillerCanvas.getContext('2d');
                
                this.setupCanvas();
                
                this.vertices = [];
                this.edges = [];
                this.fillers = [];
                this.currentTool = 'vertex';
                this.selectedVertex = null;
                this.edgeStart = null;
                this.vertexCounter = 0;
                
                this.contractible = null;
                this.fillerParticles = [];
                
                this.setupEventListeners();
                this.draw();
                this.updateStatus();
            }
            
            setupCanvas() {
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width * window.devicePixelRatio;
                this.canvas.height = rect.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                const fillerRect = this.fillerCanvas.getBoundingClientRect();
                this.fillerCanvas.width = fillerRect.width * window.devicePixelRatio;
                this.fillerCanvas.height = fillerRect.height * window.devicePixelRatio;
                this.fillerCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
            }
            
            setupEventListeners() {
                // Tool buttons
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentTool = btn.dataset.tool;
                        this.edgeStart = null;
                    });
                });
                
                // Canvas click
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                
                // Action buttons
                document.getElementById('findFillersBtn').addEventListener('click', () => this.findFillers());
                document.getElementById('testContractibilityBtn').addEventListener('click', () => this.testContractibility());
                document.getElementById('clearBtn').addEventListener('click', () => this.clear());
                
                // Example buttons
                document.querySelectorAll('.example-btn').forEach(btn => {
                    btn.addEventListener('click', () => this.loadExample(btn.dataset.example));
                });
                
                // Help icon
                document.getElementById('helpIcon').addEventListener('click', () => this.showTutorial());
            }
            
            getCanvasCoordinates(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            handleCanvasClick(e) {
                const pos = this.getCanvasCoordinates(e);
                
                switch (this.currentTool) {
                    case 'vertex':
                        this.addVertex(pos.x, pos.y);
                        break;
                    case 'edge':
                        this.handleEdgeClick(pos);
                        break;
                    case 'remove':
                        this.removeEdge(pos);
                        break;
                    case 'select':
                        this.selectVertex(pos);
                        break;
                }
            }
            
            addVertex(x, y) {
                const labels = ['x', 'y', 'z', 'w', 'u', 'v', 'a', 'b', 'c'];
                const label = labels[this.vertexCounter % labels.length];
                this.vertices.push(new Vertex(x, y, label));
                this.vertexCounter++;
                this.draw();
                this.updateStatus();
            }
            
            handleEdgeClick(pos) {
                const vertex = this.vertices.find(v => v.contains(pos.x, pos.y));
                
                if (vertex) {
                    if (!this.edgeStart) {
                        this.edgeStart = vertex;
                    } else if (this.edgeStart !== vertex) {
                        // Check if edge already exists
                        const exists = this.edges.some(e => 
                            (e.start === this.edgeStart && e.end === vertex) ||
                            (e.start === vertex && e.end === this.edgeStart)
                        );
                        
                        if (!exists) {
                            const label = `f${this.edges.length}`;
                            this.edges.push(new Edge(this.edgeStart, vertex, label));
                        }
                        
                        this.edgeStart = null;
                        this.draw();
                        this.updateStatus();
                    }
                }
            }
            
            removeEdge(pos) {
                // Find edge near click
                for (let i = this.edges.length - 1; i >= 0; i--) {
                    const edge = this.edges[i];
                    const midX = (edge.start.x + edge.end.x) / 2;
                    const midY = (edge.start.y + edge.end.y) / 2;
                    const dx = pos.x - midX;
                    const dy = pos.y - midY;
                    
                    if (Math.sqrt(dx*dx + dy*dy) < 20) {
                        edge.isMissing = !edge.isMissing;
                        this.draw();
                        this.updateStatus();
                        return;
                    }
                }
            }
            
            selectVertex(pos) {
                this.selectedVertex = this.vertices.find(v => v.contains(pos.x, pos.y));
                this.draw();
            }
            
            findFillers() {
                // Find horns (triangles with one missing edge)
                const horns = this.findHorns();
                
                if (horns.length === 0) {
                    alert('No horns found! Create a triangle and remove one edge.');
                    return;
                }
                
                // For each horn, generate potential fillers
                this.fillers = [];
                horns.forEach(horn => {
                    const numFillers = Math.floor(Math.random() * 3) + 1;
                    for (let i = 0; i < numFillers; i++) {
                        const label = `h${i+1}`;
                        this.fillers.push(new Edge(horn.missing.start, horn.missing.end, label, true));
                    }
                });
                
                this.draw();
                this.updateStatus();
                this.updateShapeInfo();
            }
            
            findHorns() {
                // Simplified: find sets of 3 vertices with 2 edges and 1 missing
                const horns = [];
                
                for (let i = 0; i < this.vertices.length; i++) {
                    for (let j = i + 1; j < this.vertices.length; j++) {
                        for (let k = j + 1; k < this.vertices.length; k++) {
                            const v1 = this.vertices[i];
                            const v2 = this.vertices[j];
                            const v3 = this.vertices[k];
                            
                            const e12 = this.edges.find(e => 
                                (e.start === v1 && e.end === v2) || (e.start === v2 && e.end === v1)
                            );
                            const e23 = this.edges.find(e => 
                                (e.start === v2 && e.end === v3) || (e.start === v3 && e.end === v2)
                            );
                            const e13 = this.edges.find(e => 
                                (e.start === v1 && e.end === v3) || (e.start === v3 && e.end === v1)
                            );
                            
                            // Check if exactly one edge is missing
                            if (e12 && e23 && !e13 && e13?.isMissing !== false) {
                                horns.push({ vertices: [v1, v2, v3], missing: { start: v1, end: v3 } });
                            } else if (e12 && e13 && !e23 && e23?.isMissing !== false) {
                                horns.push({ vertices: [v1, v2, v3], missing: { start: v2, end: v3 } });
                            } else if (e23 && e13 && !e12 && e12?.isMissing !== false) {
                                horns.push({ vertices: [v1, v2, v3], missing: { start: v1, end: v2 } });
                            }
                        }
                    }
                }
                
                return horns;
            }
            
            testContractibility() {
                if (this.fillers.length === 0) {
                    alert('Find fillers first!');
                    return;
                }
                
                // Simulate contractibility test
                this.contractible = this.fillers.length === 1;
                
                // Create particles for visualization
                this.fillerParticles = [];
                const centerX = this.fillerCanvas.width / (2 * window.devicePixelRatio);
                const centerY = this.fillerCanvas.height / (2 * window.devicePixelRatio);
                
                for (let i = 0; i < this.fillers.length * 3; i++) {
                    this.fillerParticles.push({
                        x: centerX + (Math.random() - 0.5) * 100,
                        y: centerY + (Math.random() - 0.5) * 100,
                        targetX: centerX,
                        targetY: centerY,
                        color: this.contractible ? '#2ecc71' : '#e74c3c'
                    });
                }
                
                this.animateContractibility();
                this.updateStatus();
                this.updateContractibilityInfo();
            }
            
            animateContractibility() {
                const animate = () => {
                    this.fillerCtx.fillStyle = '#0f0f1e';
                    this.fillerCtx.fillRect(0, 0, this.fillerCanvas.width, this.fillerCanvas.height);
                    
                    let allConverged = true;
                    
                    this.fillerParticles.forEach(p => {
                        if (this.contractible) {
                            p.x += (p.targetX - p.x) * 0.05;
                            p.y += (p.targetY - p.y) * 0.05;
                            
                            if (Math.abs(p.x - p.targetX) > 0.1 || Math.abs(p.y - p.targetY) > 0.1) {
                                allConverged = false;
                            }
                        }
                        
                        this.fillerCtx.beginPath();
                        this.fillerCtx.arc(p.x, p.y, 4, 0, 2 * Math.PI);
                        this.fillerCtx.fillStyle = p.color;
                        this.fillerCtx.fill();
                    });
                    
                    if (!allConverged && this.contractible) {
                        requestAnimationFrame(animate);
                    }
                };
                
                animate();
            }
            
            clear() {
                this.vertices = [];
                this.edges = [];
                this.fillers = [];
                this.selectedVertex = null;
                this.edgeStart = null;
                this.vertexCounter = 0;
                this.contractible = null;
                this.fillerParticles = [];
                
                this.draw();
                this.updateStatus();
                
                // Clear filler canvas
                this.fillerCtx.fillStyle = '#0f0f1e';
                this.fillerCtx.fillRect(0, 0, this.fillerCanvas.width, this.fillerCanvas.height);
            }
            
            draw() {
                // Clear
                this.ctx.fillStyle = '#0f0f1e';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw edges
                this.edges.forEach(edge => edge.draw(this.ctx));
                
                // Draw fillers
                this.fillers.forEach(filler => filler.draw(this.ctx));
                
                // Draw vertices
                this.vertices.forEach(vertex => {
                    vertex.draw(this.ctx, vertex === this.selectedVertex);
                });
                
                // Draw edge preview
                if (this.edgeStart && this.currentTool === 'edge') {
                    this.ctx.strokeStyle = '#f39c12';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.moveTo(this.edgeStart.x, this.edgeStart.y);
                    this.ctx.lineTo(this.edgeStart.x + 50, this.edgeStart.y);
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }
            
            updateStatus() {
                document.getElementById('vertexCount').textContent = this.vertices.length;
                document.getElementById('edgeCount').textContent = this.edges.filter(e => !e.isMissing).length;
                document.getElementById('hornCount').textContent = this.findHorns().length;
                document.getElementById('fillerCount').textContent = this.fillers.length || '-';
                
                const statusEl = document.getElementById('contractibleStatus');
                if (this.contractible !== null) {
                    if (this.contractible) {
                        statusEl.innerHTML = '<span class="badge badge-success">‚úì YES</span>';
                    } else {
                        statusEl.innerHTML = '<span class="badge badge-error">‚úó NO</span>';
                    }
                } else {
                    statusEl.textContent = '-';
                }
            }
            
            updateShapeInfo() {
                const horns = this.findHorns();
                let html = '<p><strong>Horns found:</strong> ' + horns.length + '</p>';
                
                if (horns.length > 0) {
                    html += '<div class="math-notation">';
                    horns.forEach((horn, i) => {
                        const labels = horn.vertices.map(v => v.label).join(', ');
                        html += `Horn ${i+1}: vertices {${labels}}<br>`;
                        html += `Missing: ${horn.missing.start.label} ‚Üí ${horn.missing.end.label}<br>`;
                    });
                    html += '</div>';
                    
                    html += '<div class="explanation">';
                    html += '<strong>Found ' + this.fillers.length + ' filler(s)!</strong><br>';
                    html += 'Each filler represents a way to complete the horn. ';
                    html += 'If the space is contractible (unique up to homotopy), composition is well-defined!';
                    html += '</div>';
                }
                
                document.getElementById('shapeInfo').innerHTML = html;
            }
            
            updateContractibilityInfo() {
                let html = '';
                
                if (this.contractible !== null) {
                    if (this.contractible) {
                        html += '<p><span class="badge badge-success">‚úì CONTRACTIBLE</span></p>';
                        html += '<p>All fillers collapse to a single point! This means composition is essentially unique.</p>';
                        html += '<div class="explanation">';
                        html += '<strong>Pre-‚àû-category condition satisfied!</strong><br>';
                        html += 'In graphics terms: deterministic composition (like shader compilation where all paths give the same result).';
                        html += '</div>';
                    } else {
                        html += '<p><span class="badge badge-error">‚úó NON-CONTRACTIBLE</span></p>';
                        html += '<p>Multiple distinct fillers exist! Composition is not unique.</p>';
                        html += '<div class="explanation">';
                        html += '<strong>NOT a pre-‚àû-category</strong><br>';
                        html += 'In graphics terms: multiple strategies (like mesh morphing where many paths exist between shapes).';
                        html += '</div>';
                    }
                }
                
                document.getElementById('contractibilityInfo').innerHTML = html;
            }
            
            loadExample(type) {
                this.clear();
                
                switch (type) {
                    case 'temporal':
                        this.loadTemporalAAExample();
                        break;
                    case 'shader':
                        this.loadShaderCompilationExample();
                        break;
                    case 'mesh':
                        this.loadMeshMorphingExample();
                        break;
                    case 'physics':
                        this.loadPhysicsSimulationExample();
                        break;
                }
            }
            
            loadTemporalAAExample() {
                // Three frames in temporal sequence
                this.addVertex(150, 200);
                this.addVertex(300, 200);
                this.addVertex(450, 200);
                
                this.vertices[0].label = 'Frame‚ÇÄ';
                this.vertices[1].label = 'Frame‚ÇÅ';
                this.vertices[2].label = 'Frame‚ÇÇ';
                
                this.edges.push(new Edge(this.vertices[0], this.vertices[1], 'motion‚ÇÄ‚Üí‚ÇÅ'));
                this.edges.push(new Edge(this.vertices[1], this.vertices[2], 'motion‚ÇÅ‚Üí‚ÇÇ'));
                
                this.draw();
                this.updateStatus();
                
                const html = `
                    <p><strong>Temporal Antialiasing Example</strong></p>
                    <p>Frames as vertices, motion vectors as edges.</p>
                    <div class="math-notation">
Hom(Frame‚ÇÄ, Frame‚ÇÅ) = motion vectors
Composition = accumulated motion
                    </div>
                    <div class="explanation">
                        <strong>Question:</strong> Is the composite Frame‚ÇÄ‚ÜíFrame‚ÇÇ unique?<br>
                        In TAA, composition is nearly deterministic (contractible), though numerical differences may exist.
                    </div>
                `;
                document.getElementById('shapeInfo').innerHTML = html;
            }
            
            loadShaderCompilationExample() {
                // IR levels
                this.addVertex(100, 150);
                this.addVertex(300, 150);
                this.addVertex(500, 150);
                
                this.vertices[0].label = 'HLSL';
                this.vertices[1].label = 'SPIRV';
                this.vertices[2].label = 'Bytecode';
                
                this.edges.push(new Edge(this.vertices[0], this.vertices[1], 'compile'));
                this.edges.push(new Edge(this.vertices[1], this.vertices[2], 'assemble'));
                
                // Mark as contractible example
                this.edges[0].isFiller = false;
                this.edges[1].isFiller = false;
                
                this.draw();
                this.updateStatus();
                
                const html = `
                    <p><strong>Shader Compilation Example</strong></p>
                    <p>IR levels as vertices, compilation steps as edges.</p>
                    <div class="math-notation">
HLSL ‚Üí SPIRV ‚Üí Bytecode
Composition: HLSL ‚Üí Bytecode
                    </div>
                    <div class="explanation">
                        <strong>This IS a pre-‚àû-category!</strong><br>
                        Shader compilation is deterministic. All compilation paths (modulo inessential register naming) give the same result. The filler space is contractible!
                    </div>
                `;
                document.getElementById('shapeInfo').innerHTML = html;
            }
            
            loadMeshMorphingExample() {
                // Three shapes
                this.addVertex(200, 150);
                this.addVertex(300, 300);
                this.addVertex(400, 150);
                
                this.vertices[0].label = 'Sphere';
                this.vertices[1].label = 'Cube';
                this.vertices[2].label = 'Cylinder';
                
                this.edges.push(new Edge(this.vertices[0], this.vertices[1], 'morph‚ÇÅ'));
                this.edges.push(new Edge(this.vertices[1], this.vertices[2], 'morph‚ÇÇ'));
                
                this.draw();
                this.updateStatus();
                
                const html = `
                    <p><strong>Mesh Morphing Example</strong></p>
                    <p>Shapes as vertices, smooth deformations as edges.</p>
                    <div class="math-notation">
Sphere ‚Üí Cube ‚Üí Cylinder
vs. Sphere ‚Üí Cylinder (direct)
                    </div>
                    <div class="explanation">
                        <strong>NOT a pre-‚àû-category!</strong><br>
                        Multiple distinct morphing paths exist. The composite Sphere‚ÜíCylinder could go through Cube, or take many other routes. Non-contractible!
                    </div>
                `;
                document.getElementById('shapeInfo').innerHTML = html;
            }
            
            loadPhysicsSimulationExample() {
                // Physical states over time
                this.addVertex(150, 200);
                this.addVertex(300, 200);
                this.addVertex(450, 200);
                
                this.vertices[0].label = 'State(t‚ÇÄ)';
                this.vertices[1].label = 'State(t‚ÇÅ)';
                this.vertices[2].label = 'State(t‚ÇÇ)';
                
                this.edges.push(new Edge(this.vertices[0], this.vertices[1], 'evolve'));
                this.edges.push(new Edge(this.vertices[1], this.vertices[2], 'evolve'));
                
                this.draw();
                this.updateStatus();
                
                const html = `
                    <p><strong>Physics Simulation Example</strong></p>
                    <p>Physical states as vertices, deterministic evolution as edges.</p>
                    <div class="math-notation">
State(t‚ÇÄ) ‚Üí State(t‚ÇÅ) ‚Üí State(t‚ÇÇ)
Deterministic physics evolution
                    </div>
                    <div class="explanation">
                        <strong>This IS a pre-‚àû-category!</strong><br>
                        Physics with deterministic equations gives unique evolution. The composite t‚ÇÄ‚Üít‚ÇÇ is uniquely determined by physics laws. Contractible!
                    </div>
                `;
                document.getElementById('shapeInfo').innerHTML = html;
            }
            
            showTutorial() {
                document.getElementById('tutorialOverlay').classList.add('active');
                this.currentTutorialStep = 0;
                this.updateTutorial();
            }
            
            updateTutorial() {
                const steps = [
                    {
                        title: 'Welcome to the Horn Filling Playground!',
                        content: `
                            <p>This interactive tool helps you understand <strong>simplicial homotopy type theory</strong> and <strong>pre-‚àû-categories</strong> through hands-on exploration.</p>
                            <p><strong>Key concepts:</strong></p>
                            <ul>
                                <li>Shapes: simplices (triangles) and horns (triangles with missing edges)</li>
                                <li>Extension types: completing partial data</li>
                                <li>Contractibility: unique composition up to homotopy</li>
                                <li>Pre-‚àû-categories: types where composition is contractible</li>
                            </ul>
                        `
                    },
                    {
                        title: 'Step 1: Add Vertices',
                        content: `
                            <p>Click the <strong>"Add Vertex"</strong> button (should be active by default).</p>
                            <p>Then click anywhere on the black canvas to place vertices. These represent "terms" in your type.</p>
                            <p><strong>Graphics analogy:</strong> Think of vertices as different states in your rendering pipeline (e.g., different shader formats, mesh configurations, or frame states).</p>
                            <p>Try adding 3 vertices to form a triangle!</p>
                        `
                    },
                    {
                        title: 'Step 2: Create Edges',
                        content: `
                            <p>Click the <strong>"Create Edge"</strong> button.</p>
                            <p>Click on a vertex, then click on another vertex to connect them with an edge (arrow).</p>
                            <p><strong>Graphics analogy:</strong> Edges represent transformations or operations (e.g., shader compilation steps, mesh morphs, or frame transitions).</p>
                            <p>Create edges to form a triangle (3 vertices, 3 edges).</p>
                        `
                    },
                    {
                        title: 'Step 3: Create a Horn',
                        content: `
                            <p>A <strong>horn</strong> is a triangle with one edge removed (missing).</p>
                            <p>Click the <strong>"Remove Edge"</strong> button, then click on one of your triangle edges to mark it as "missing" (it will turn red and dashed).</p>
                            <p><strong>What's happening:</strong> You now have a "horn-filling problem"‚Äîgiven two edges, can we uniquely determine the third?</p>
                            <p><strong>Graphics analogy:</strong> Like having keyframes at t=0 and t=0.5, and t=0.5 and t=1, but missing the direct t=0 to t=1 motion.</p>
                        `
                    },
                    {
                        title: 'Step 4: Find Fillers',
                        content: `
                            <p>Click the <strong>"Find Fillers"</strong> button.</p>
                            <p>The system will compute possible ways to "fill" the missing edge (complete the horn).</p>
                            <p>Fillers appear as purple edges with labels like h‚ÇÅ, h‚ÇÇ, h‚ÇÉ.</p>
                            <p><strong>Key insight:</strong> Each filler represents a potential composite. If there's only one filler (or all fillers are "the same up to homotopy"), composition is unique!</p>
                        `
                    },
                    {
                        title: 'Step 5: Test Contractibility',
                        content: `
                            <p>Click the <strong>"Test Contractibility"</strong> button.</p>
                            <p>Watch the right panel: if the space is <strong>contractible</strong>, particles will collapse to a single point (green). If <strong>non-contractible</strong>, they stay spread out (red).</p>
                            <p><strong>Contractible = Pre-‚àû-category!</strong></p>
                            <p>This means composition is unique up to homotopy, and you get associativity and identities FOR FREE.</p>
                        `
                    },
                    {
                        title: 'Step 6: Try Examples',
                        content: `
                            <p>Use the <strong>Examples</strong> buttons to load real graphics scenarios:</p>
                            <ul>
                                <li><strong>Temporal AA:</strong> Frame interpolation (nearly contractible)</li>
                                <li><strong>Shader Compilation:</strong> Deterministic IR transformations (contractible! ‚úì)</li>
                                <li><strong>Mesh Morphing:</strong> Multiple morphing paths (non-contractible)</li>
                                <li><strong>Physics Simulation:</strong> Deterministic evolution (contractible! ‚úì)</li>
                            </ul>
                            <p>See which systems form pre-‚àû-categories!</p>
                        `
                    },
                    {
                        title: 'The Big Picture',
                        content: `
                            <p><strong>What you've learned:</strong></p>
                            <ul>
                                <li>Horns = partial data (missing edges in simplices)</li>
                                <li>Fillers = ways to complete partial data</li>
                                <li>Contractible = unique completion up to homotopy</li>
                                <li>Pre-‚àû-category = type where all compositions are contractible</li>
                            </ul>
                            <p><strong>The miracle:</strong> In a pre-‚àû-category, associativity and identity laws emerge AUTOMATICALLY from the contractibility condition!</p>
                            <p>Shader compilation is a pre-‚àû-category. Mesh morphing is not. Physics determines structure!</p>
                            <p><strong>Now explore freely and build your own examples!</strong></p>
                        `
                    }
                ];
                
                const step = steps[this.currentTutorialStep];
                document.getElementById('tutorialTitle').textContent = step.title;
                document.getElementById('tutorialContent').innerHTML = step.content;
                
                document.getElementById('tutorialPrev').disabled = this.currentTutorialStep === 0;
                document.getElementById('tutorialNext').textContent = 
                    this.currentTutorialStep === steps.length - 1 ? 'Finish' : 'Next';
                
                document.getElementById('tutorialPrev').onclick = () => {
                    if (this.currentTutorialStep > 0) {
                        this.currentTutorialStep--;
                        this.updateTutorial();
                    }
                };
                
                document.getElementById('tutorialNext').onclick = () => {
                    if (this.currentTutorialStep < steps.length - 1) {
                        this.currentTutorialStep++;
                        this.updateTutorial();
                    } else {
                        document.getElementById('tutorialOverlay').classList.remove('active');
                    }
                };
            }
        }
        
        // Initialize
        const playground = new HornFillingPlayground();
        
        // Show tutorial on first load
        setTimeout(() => playground.showTutorial(), 500);
    </script>
</body>
</html>
