<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Illustrated Guide to Perverse Sheaves</title>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>

    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Three.js with crossorigin to fix Script Error -->
    <script crossorigin="anonymous" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f8fafc; }
        canvas { outline: none; }
        .hand-drawn {
            border-radius: 2px 255px 3px 25px / 255px 5px 225px 5px;
            border: 2px solid #334155;
        }
        .slide-container input {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #cbd5e1;
            outline: none;
        }
        .slide-container input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, Component } = React;

        // --- Error Boundary ---
        class ErrorBoundary extends Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }

            static getDerivedStateFromError(error) {
                return { hasError: true, error };
            }

            componentDidCatch(error, errorInfo) {
                console.error("ErrorBoundary caught an error", error, errorInfo);
            }

            render() {
                if (this.state.hasError) {
                    return (
                        <div className="p-4 bg-red-50 border border-red-200 rounded text-red-800">
                            <h3 className="font-bold">Something went wrong.</h3>
                            <p className="text-sm font-mono mt-2">{this.state.error && this.state.error.toString()}</p>
                            <button onClick={() => window.location.reload()} className="mt-4 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700">Reload Page</button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }

        // --- Icons ---
        const Icons = {
            Menu: () => <path d="M4 6h16M4 12h16M4 18h16" />,
            Box: () => <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z" />,
            Activity: () => <path d="M22 12h-4l-3 9L9 3l-3 9H2" />,
            Eye: () => <React.Fragment><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"/><circle cx="12" cy="12" r="3"/></React.Fragment>,
            GitMerge: () => <React.Fragment><circle cx="18" cy="18" r="3"/><circle cx="6" cy="6" r="3"/><path d="M6 21V9a9 9 0 0 0 9 9"/></React.Fragment>,
            ArrowRight: () => <path d="M5 12h14M12 5l7 7-7 7" />,
            Terminal: () => <React.Fragment><polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line></React.Fragment>
        };

        const Icon = ({ name, size=24, className }) => (
            <svg
                xmlns="http://www.w3.org/2000/svg"
                width={size} height={size} viewBox="0 0 24 24"
                fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"
                className={className}
            >
                {Icons[name] ? Icons[name]() : null}
            </svg>
        );

        // --- SVGs for Topology Illustrations ---
        const TorusSVG = ({ twist }) => (
            <svg viewBox="0 0 200 150" className="w-full h-full stroke-slate-700 fill-none stroke-2">
                <ellipse cx="100" cy="75" rx="90" ry="60" className="fill-slate-100" />
                <path d="M 50 75 Q 100 110 150 75" />
                <path d="M 60 80 Q 100 40 140 80" />
                <path d="M 100 15 L 100 135" className="stroke-red-500 stroke-[3] opacity-60" strokeDasharray="4,4" />
                <ellipse cx="100" cy="75" rx="30" ry="15" className="stroke-blue-500 stroke-[3]" />
                {twist > 0 && (
                     <path d={`M 130 75 C 130 120, ${100 + twist*20} 120, ${100 + twist*20} 75 S 70 30, 70 75`}
                           className="stroke-purple-600 stroke-[2]" fill="none" />
                )}
            </svg>
        );

        const PinchedTorusSVG = () => (
            <svg viewBox="0 0 200 150" className="w-full h-full stroke-slate-700 fill-none stroke-2">
                <path d="M 10 75 Q 50 135 100 75 Q 150 135 190 75 Q 150 15 100 75 Q 50 15 10 75 Z" className="fill-slate-100" />
                <circle cx="100" cy="75" r="4" className="fill-red-500 stroke-none" />
                <text x="105" y="70" className="text-xs stroke-none fill-slate-500">Node</text>
            </svg>
        );

        const CuspSVG = () => (
            <svg viewBox="0 0 200 150" className="w-full h-full stroke-slate-700 fill-none stroke-2">
                <path d="M 20 75 Q 100 150 180 75 Q 100 75 100 75 Q 100 75 20 75" className="fill-slate-100" />
                <circle cx="100" cy="75" r="4" className="fill-red-500 stroke-none" />
                <text x="105" y="70" className="text-xs stroke-none fill-slate-500">Cusp</text>
            </svg>
        );

        // --- Module 1: Elliptic Curve ---
        const EllipticCurveModule = () => {
            const [a, setA] = useState(1.5);
            const [b, setB] = useState(-1.5);
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                const scale = 40;

                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = '#94a3b8';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height/2); ctx.lineTo(width, height/2);
                ctx.moveTo(width/2, 0); ctx.lineTo(width/2, height);
                ctx.stroke();

                ctx.strokeStyle = '#4f46e5';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let px = 0; px < width; px++) {
                    const x = (px - width/2) / scale;
                    const val = x * (x - a) * (x - b);
                    if (val >= 0) {
                        const y = Math.sqrt(val);
                        const py_top = height/2 - y * scale;
                        const py_bot = height/2 + y * scale;
                        ctx.fillStyle = '#4f46e5';
                        ctx.fillRect(px, py_top, 1, 1);
                        ctx.fillRect(px, py_bot, 1, 1);
                    }
                }

                const drawPoint = (val, label, color) => {
                    const px = width/2 + val * scale;
                    const py = height/2;
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#334155';
                    ctx.fillText(label, px - 5, py - 10);
                }

                drawPoint(0, "0", "#ef4444");
                drawPoint(a, "a", "#22c55e");
                drawPoint(b, "b", "#3b82f6");
            }, [a, b]);

            const isNode = Math.abs(a - b) < 0.1 && Math.abs(a) > 0.1;
            const isCusp = Math.abs(a) < 0.1 && Math.abs(b) < 0.1;
            const isSmooth = !isNode && !isCusp;

            return (
                <div className="flex flex-col md:flex-row gap-6 h-full p-4">
                    <div className="flex-1 bg-white p-4 shadow-sm rounded-lg hand-drawn">
                        <h3 className="text-lg font-bold mb-2 text-slate-800">The R-Picture (Real Points)</h3>
                        <canvas ref={canvasRef} width={400} height={300} className="w-full h-64 bg-slate-50 rounded" />
                        <div className="mt-4 space-y-4">
                            <div className="slide-container">
                                <label className="flex justify-between text-sm font-medium text-slate-700">
                                    <span>Parameter a</span> <span>{a.toFixed(2)}</span>
                                </label>
                                <input type="range" min="-3" max="3" step="0.05" value={a} onChange={(e) => setA(parseFloat(e.target.value))} />
                            </div>
                            <div className="slide-container">
                                <label className="flex justify-between text-sm font-medium text-slate-700">
                                    <span>Parameter b</span> <span>{b.toFixed(2)}</span>
                                </label>
                                <input type="range" min="-3" max="3" step="0.05" value={b} onChange={(e) => setB(parseFloat(e.target.value))} />
                            </div>
                            <div className="flex gap-2 text-sm">
                                <button onClick={() => { setA(1.5); setB(-1.5); }} className="px-3 py-1 bg-slate-200 rounded hover:bg-slate-300">Reset</button>
                                <button onClick={() => { setA(1); setB(1); }} className="px-3 py-1 bg-indigo-100 text-indigo-700 rounded hover:bg-indigo-200">Make Node (a=b)</button>
                                <button onClick={() => { setA(0); setB(0); }} className="px-3 py-1 bg-rose-100 text-rose-700 rounded hover:bg-rose-200">Make Cusp (a=b=0)</button>
                            </div>
                        </div>
                    </div>

                    <div className="flex-1 bg-white p-4 shadow-sm rounded-lg hand-drawn flex flex-col items-center justify-center">
                        <h3 className="text-lg font-bold mb-4 text-slate-800">The C-Picture (Topology)</h3>
                        <div className="w-full h-64 flex items-center justify-center bg-slate-50 rounded p-4">
                            {isSmooth && <div className="text-center w-full"><TorusSVG twist={0}/><p className="mt-2 font-bold text-indigo-600">Smooth Torus (Genus 1)</p></div>}
                            {isNode && <div className="text-center w-full"><PinchedTorusSVG /><p className="mt-2 font-bold text-amber-600">Nodal Curve</p></div>}
                            {isCusp && <div className="text-center w-full"><CuspSVG /><p className="mt-2 font-bold text-rose-600">Cuspidal Curve</p></div>}
                        </div>
                        <p className="mt-4 text-sm text-slate-600 italic">
                            "One of the problems with studying the topology of complex algebraic varieties is that the dimension grows very quickly... sometimes finding the right picture to draw is half the problem!"
                        </p>
                    </div>
                </div>
            );
        };

        // --- Module 2: Whitney Umbrella ---
        const WhitneyUmbrellaModule = () => {
            const mountRef = useRef(null);
            const [sliceZ, setSliceZ] = useState(0.5);

            useEffect(() => {
                if (typeof THREE === 'undefined') {
                    console.error("Three.js not loaded");
                    return;
                }
                if (!mountRef.current) return;

                const width = mountRef.current.clientWidth;
                const height = mountRef.current.clientHeight;

                // Scene Setup
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf8fafc);

                const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 100);
                camera.position.set(4, 3, 4);
                camera.lookAt(0, 0, 0);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                mountRef.current.appendChild(renderer.domElement);

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(5, 10, 7);
                scene.add(dirLight);

                // Create Whitney Umbrella
                const createWhitneyGeometry = () => {
                    const vertices = [];
                    const indices = [];
                    const uSegments = 50;
                    const vSegments = 50;

                    for (let i = 0; i <= uSegments; i++) {
                        const u = (i / uSegments - 0.5) * 2.5;
                        for (let j = 0; j <= vSegments; j++) {
                            const v = (j / vSegments - 0.5) * 2.5;
                            const x = u * v;
                            const y = v;
                            const z = u * u;
                            vertices.push(x, z - 0.8, y);
                        }
                    }

                    for (let i = 0; i < uSegments; i++) {
                        for (let j = 0; j < vSegments; j++) {
                            const a = i * (vSegments + 1) + j;
                            const b = i * (vSegments + 1) + j + 1;
                            const c = (i + 1) * (vSegments + 1) + j + 1;
                            const d = (i + 1) * (vSegments + 1) + j;
                            indices.push(a, b, d);
                            indices.push(b, c, d);
                        }
                    }

                    const geom = new THREE.BufferGeometry();
                    geom.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                    geom.setIndex(indices);
                    geom.computeVertexNormals();
                    return geom;
                };

                const geometry = createWhitneyGeometry();
                const material = new THREE.MeshPhongMaterial({
                    color: 0x4f46e5,
                    side: THREE.DoubleSide,
                    shininess: 80,
                    flatShading: false,
                    transparent: true,
                    opacity: 0.8
                });
                const umbrella = new THREE.Mesh(geometry, material);
                scene.add(umbrella);

                const planeGeom = new THREE.PlaneGeometry(3, 3);
                const planeMat = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.2
                });
                const plane = new THREE.Mesh(planeGeom, planeMat);
                plane.rotation.x = -Math.PI / 2;
                scene.add(plane);

                // Reusable geometries for slice lines
                const lineMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });

                const line1Geom = new THREE.BufferGeometry();
                line1Geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
                const line1 = new THREE.Line(line1Geom, lineMat);
                line1.frustumCulled = false;

                const line2Geom = new THREE.BufferGeometry();
                line2Geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3));
                const line2 = new THREE.Line(line2Geom, lineMat);
                line2.frustumCulled = false;

                scene.add(line1);
                scene.add(line2);

                const axesHelper = new THREE.AxesHelper( 2 );
                scene.add( axesHelper );

                let frameId;
                const animate = () => {
                    try {
                        const h = Math.max(0, window.currentSliceZ || 0);
                        plane.position.y = h - 0.8;

                        // Update lines based on current Z
                        const slope = Math.sqrt(h);
                        const yPos = plane.position.y + 0.01;

                        // Line 1: x = slope * z
                        const pos1 = line1.geometry.attributes.position.array;
                        pos1[0] = -slope; pos1[1] = yPos; pos1[2] = -1;
                        pos1[3] = slope;  pos1[4] = yPos; pos1[5] = 1;
                        line1.geometry.attributes.position.needsUpdate = true;

                        // Line 2: x = -slope * z
                        const pos2 = line2.geometry.attributes.position.array;
                        pos2[0] = slope;  pos2[1] = yPos; pos2[2] = -1;
                        pos2[3] = -slope; pos2[4] = yPos; pos2[5] = 1;
                        line2.geometry.attributes.position.needsUpdate = true;

                        // Toggle visibility
                        line1.visible = h > 0.001;
                        line2.visible = h > 0.001;

                        umbrella.rotation.y += 0.002;
                        line1.rotation.y = umbrella.rotation.y;
                        line2.rotation.y = umbrella.rotation.y;

                        renderer.render(scene, camera);
                        frameId = requestAnimationFrame(animate);
                    } catch (e) {
                        console.error("Animation Loop Error", e);
                        cancelAnimationFrame(frameId);
                    }
                };

                animate();

                return () => {
                    cancelAnimationFrame(frameId);
                    if (mountRef.current && renderer.domElement.parentNode === mountRef.current) {
                        mountRef.current.removeChild(renderer.domElement);
                    }
                    // Dispose resources
                    geometry.dispose();
                    material.dispose();
                    planeGeom.dispose();
                    planeMat.dispose();
                    lineMat.dispose();
                    line1Geom.dispose();
                    line2Geom.dispose();
                    renderer.dispose();
                };
            }, []);

            window.currentSliceZ = sliceZ;

            if (typeof THREE === 'undefined') {
                return (
                    <div className="flex flex-col h-full gap-4 items-center justify-center text-slate-500">
                        <p>Loading 3D Engine...</p>
                        <p className="text-xs">If this takes too long, please check your connection.</p>
                    </div>
                );
            }

            return (
                <div className="flex flex-col h-full gap-4">
                     <div className="bg-white p-4 rounded-lg shadow-sm border-l-4 border-indigo-500">
                        <h2 className="text-xl font-bold text-slate-800">The Whitney Umbrella</h2>
                        <p className="text-sm text-slate-600">The surface $x^2 = zy^2$. A stratification is a way to cut this into pieces (strata) that look the same everywhere.</p>
                    </div>

                    <div className="flex-1 flex flex-col md:flex-row gap-4 relative">
                        <div ref={mountRef} className="flex-1 rounded-lg overflow-hidden shadow-inner bg-slate-900" />

                        <div className="md:w-64 bg-white p-4 rounded-lg shadow-sm hand-drawn flex flex-col gap-4">
                            <h3 className="font-bold text-slate-700">CT Scanner</h3>
                            <p className="text-xs text-slate-500">Move the slider to slice the surface at different heights ($z$).</p>

                            <div className="slide-container">
                                <label className="flex justify-between text-xs font-bold text-slate-700 mb-2">
                                    <span>Slice Height (z)</span> <span>{sliceZ.toFixed(2)}</span>
                                </label>
                                <input type="range" min="0" max="1.5" step="0.01" value={sliceZ} onChange={(e) => setSliceZ(parseFloat(e.target.value))} />
                            </div>

                            <div className="p-3 bg-slate-50 rounded text-xs border border-slate-200">
                                <span className="font-bold block mb-1">Observation:</span>
                                {sliceZ > 0.1 ? (
                                    <span className="text-green-600">At $z > 0$, the slice looks like two intersecting lines. The topology is constant here.</span>
                                ) : (
                                    <span className="text-red-600 font-bold">Singularity! At $z=0$, the lines collapse. The topology changes abruptly.</span>
                                )}
                            </div>

                            <div className="mt-auto">
                                <h4 className="font-bold text-slate-700 text-sm mb-2">Stratification:</h4>
                                <ul className="text-xs space-y-1 text-slate-600">
                                    <li className="flex items-center"><span className="w-3 h-3 bg-indigo-500 rounded-full mr-2"></span> {'$X_{reg}$'} (Surface)</li>
                                    <li className="flex items-center"><span className="w-3 h-3 bg-red-500 rounded-full mr-2"></span> {'$X_{sing}$'} (Handle axis)</li>
                                    <li className="flex items-center"><span className="w-3 h-3 bg-yellow-400 rounded-full mr-2"></span> Origin (The Pinch point)</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Module 3: Monodromy ---
        const MonodromyModule = () => {
            const [angle, setAngle] = useState(0);
            const canvasRef = useRef(null);
            const isDragging = useRef(false);

            const handleMouseDown = (e) => {
                const rect = canvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left - 150; // center offset
                const y = e.clientY - rect.top - 150;
                // Check if clicking near 'a'
                const dist = Math.sqrt( Math.pow(x - 80*Math.cos(angle), 2) + Math.pow(y - 80*Math.sin(angle), 2) );
                if (dist < 20) isDragging.current = true;
            };

            const handleMouseMove = (e) => {
                if (!isDragging.current) return;
                const rect = canvasRef.current.getBoundingClientRect();
                const x = e.clientX - rect.left - 150;
                const y = e.clientY - rect.top - 150;
                let newAngle = Math.atan2(y, x);

                // Logic to handle full rotations to accumulate twist
                // Simple version: just use raw angle for visual
                if (newAngle < 0) newAngle += Math.PI * 2;
                setAngle(newAngle);
            };

            const handleMouseUp = () => isDragging.current = false;

            useEffect(() => {
                const ctx = canvasRef.current.getContext('2d');
                ctx.clearRect(0,0, 300, 300);

                const cx = 150, cy = 150;

                // Base U
                ctx.fillStyle = '#f1f5f9';
                ctx.beginPath(); ctx.arc(cx, cy, 140, 0, Math.PI*2); ctx.fill();
                ctx.strokeStyle = '#cbd5e1'; ctx.lineWidth=2; ctx.stroke();

                // Point b (center)
                ctx.fillStyle = '#3b82f6';
                ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI*2); ctx.fill();
                ctx.fillText("b", cx - 10, cy - 10);

                // Point c (far away)
                ctx.fillStyle = '#64748b';
                ctx.beginPath(); ctx.arc(cx + 100, cy, 5, 0, Math.PI*2); ctx.fill();
                ctx.fillText("c", cx + 105, cy - 5);

                // Point a (orbiting)
                const ax = cx + 80 * Math.cos(angle);
                const ay = cy + 80 * Math.sin(angle);

                // Trail
                ctx.strokeStyle = '#cbd5e1';
                ctx.setLineDash([5, 5]);
                ctx.beginPath(); ctx.arc(cx, cy, 80, 0, Math.PI*2); ctx.stroke();
                ctx.setLineDash([]);

                // Line segment a-b
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(ax, ay); ctx.stroke();

                // Point a
                ctx.fillStyle = '#22c55e';
                ctx.beginPath(); ctx.arc(ax, ay, 8, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = 'white';
                ctx.font = '12px sans-serif';
                ctx.fillText("a", ax-3, ay+4);

            }, [angle]);

            // Calculate twist factor based on angle (0 to 2PI maps to 0 to 1 twist)
            const twistFactor = angle / (Math.PI * 2);

            return (
                <div className="flex flex-col md:flex-row gap-8 items-center justify-center h-full p-6">
                    <div className="flex flex-col items-center">
                        <h3 className="font-bold text-slate-700 mb-2">Base Space ($U$)</h3>
                        <canvas
                            ref={canvasRef}
                            width={300} height={300}
                            className="bg-white rounded-full shadow-lg cursor-pointer"
                            onMouseDown={handleMouseDown}
                            onMouseMove={handleMouseMove}
                            onMouseUp={handleMouseUp}
                            onMouseLeave={handleMouseUp}
                        />
                        <p className="text-xs text-slate-500 mt-2">Drag <strong>'a'</strong> around <strong>'b'</strong></p>
                    </div>

                    <div className="text-slate-400">
                        <Icon name="ArrowRight" size={32} />
                    </div>

                    <div className="flex flex-col items-center">
                        <h3 className="font-bold text-slate-700 mb-2">The Fiber {`($E_{a,b,c}$)`}</h3>
                        <div className="w-64 h-48 bg-white rounded-lg shadow-lg p-2 border border-slate-200">
                            <TorusSVG twist={twistFactor} />
                        </div>
                        <div className="mt-4 p-3 bg-indigo-50 rounded text-xs text-indigo-800 max-w-xs text-center border border-indigo-100">
                            <strong>Monodromy Action:</strong><br/>
                            As you loop around the singularity, the cycle $c_2$ (blue) picks up a copy of $c_1$ (red).<br/>
                            <span className="font-mono mt-1 block">c₂ ↦ c₂ + c₁ (Dehn Twist)</span>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Module 4: Vanishing Cycles Probe ---
        const VanishingCyclesModule = () => {
            const [probePos, setProbePos] = useState({ x: 50, y: 50 });
            const rectRef = useRef(null);

            const handleMove = (e) => {
                const rect = rectRef.current.getBoundingClientRect();
                setProbePos({
                    x: Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100)),
                    y: Math.max(0, Math.min(100, ((e.clientY - rect.top) / rect.height) * 100))
                });
            };

            // Distance from center (50, 50)
            const dist = Math.sqrt(Math.pow(probePos.x - 50, 2) + Math.pow(probePos.y - 50, 2));
            const isSingular = dist < 10;

            return (
                <div className="flex flex-col h-full gap-6 p-4">
                     <div className="bg-white p-4 rounded-lg shadow-sm border-l-4 border-rose-500">
                        <h2 className="text-xl font-bold text-slate-800">The Perverse Probe</h2>
                        <p className="text-sm text-slate-600">A Constructible Sheaf assigns data to open sets. A Perverse Sheaf organizes this data to handle singularities gracefully. Hover to verify!</p>
                    </div>

                    <div className="flex flex-col md:flex-row gap-8 items-start h-full">
                        {/* The Disk */}
                        <div
                            className="relative w-80 h-80 bg-slate-100 rounded-full border-2 border-slate-300 shadow-inner cursor-crosshair overflow-hidden mx-auto"
                            ref={rectRef}
                            onMouseMove={handleMove}
                        >
                            {/* Singularity */}
                            <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-4 h-4 bg-red-500 rounded-full shadow-lg z-10 animate-pulse"></div>

                            {/* Probe Visualization */}
                            <div
                                className="absolute w-8 h-8 border-2 border-indigo-600 rounded-full pointer-events-none transform -translate-x-1/2 -translate-y-1/2 transition-all duration-75"
                                style={{ left: `${probePos.x}%`, top: `${probePos.y}%` }}
                            ></div>
                            <div
                                className="absolute pointer-events-none h-px bg-indigo-400 origin-left"
                                style={{
                                    left: `${probePos.x}%`,
                                    top: `${probePos.y}%`,
                                    width: '100px',
                                    transform: 'rotate(-45deg)'
                                }}
                            ></div>
                            <div
                                className="absolute bg-indigo-600 text-white text-xs px-2 py-1 rounded shadow pointer-events-none"
                                style={{ left: `calc(${probePos.x}% + 60px)`, top: `calc(${probePos.y}% - 60px)` }}
                            >
                                Probe Data
                            </div>
                        </div>

                        {/* Data readout */}
                        <div className="flex-1 w-full bg-slate-800 text-slate-100 p-6 rounded-lg font-mono shadow-xl relative overflow-hidden">
                            <div className="absolute top-0 right-0 p-4 opacity-10">
                                <Icon name="Activity" size={100} />
                            </div>

                            <h3 className="text-indigo-400 font-bold mb-4 flex items-center gap-2">
                                <Icon name="Terminal" size={18} />
                                SHEAF DATA TERMINAL
                            </h3>

                            <div className="space-y-4">
                                <div className="flex justify-between border-b border-slate-700 pb-2">
                                    <span>Location:</span>
                                    <span className={isSingular ? "text-red-400 font-bold" : "text-green-400"}>
                                        {isSingular ? "SINGULARITY (0)" : "GENERIC POINT (U)"}
                                    </span>
                                </div>

                                {isSingular ? (
                                    <div className="animate-in fade-in slide-in-from-bottom-4 duration-300">
                                        <div className="mb-2 text-yellow-400 font-bold"> COMPLEX DETECTED:</div>
                                        <div className="pl-4 border-l-2 border-yellow-500 space-y-2">
                                            <div className="bg-slate-700 p-2 rounded">
                                                <span className="text-xs text-slate-400">Degree -1</span><br/>
                                                <span className="text-white">V (Nearby Cycles $\psi$)</span>
                                            </div>
                                            <div className="flex justify-center text-slate-500">↓ (can)</div>
                                            <div className="bg-slate-700 p-2 rounded border border-red-500">
                                                <span className="text-xs text-slate-400">Degree 0</span><br/>
                                                <span className="text-red-300">W (Vanishing Cycles $\phi$)</span>
                                            </div>
                                        </div>
                                        <p className="text-xs text-slate-400 mt-4 italic">
                                            "The vanishing cycles measure the cohomology that is lost when the generic fiber collapses into the singularity."
                                        </p>
                                    </div>
                                ) : (
                                    <div>
                                        <div className="mb-2 text-green-400 font-bold"> LOCAL SYSTEM:</div>
                                        <div className="bg-slate-700 p-4 rounded border border-green-500/30">
                                            <span className="text-white text-lg">Vector Space $V$</span><br/>
                                            <span className="text-xs text-slate-400">Solution to differential eq / Flat section</span>
                                        </div>
                                        <div className="mt-4 text-xs text-slate-400">
                                            Everything is locally constant here. The topology is boring.
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // --- Main App Component ---
        const App = () => {
            const [activeTab, setActiveTab] = useState('singularities');

            return (
                <ErrorBoundary>
                    <div className="flex flex-col h-screen bg-slate-50 text-slate-800">
                        <header className="bg-white border-b border-slate-200 p-4 flex items-center justify-between shadow-sm z-10">
                            <div className="flex items-center gap-3">
                                <div className="p-2 bg-indigo-600 rounded text-white">
                                    <Icon name="Box" size={24} />
                                </div>
                                <div>
                                    <h1 className="font-bold text-xl tracking-tight text-slate-900">Perverse Sheaves</h1>
                                    <p className="text-xs text-slate-500 font-medium">AN ILLUSTRATED GUIDE</p>
                                </div>
                            </div>
                            <div className="text-xs text-right hidden md:block text-slate-400">
                                Based on notes by<br/>Geordie Williamson
                            </div>
                        </header>

                        <main className="flex-1 flex overflow-hidden">
                            <nav className="w-64 bg-slate-100 border-r border-slate-200 flex-col gap-1 p-4 hidden md:flex">
                                <NavButton id="singularities" label="1. The Zoo of Singularities" active={activeTab} set={setActiveTab} icon="Eye" />
                                <NavButton id="whitney" label="2. Stratification (Whitney)" active={activeTab} set={setActiveTab} icon="Box" />
                                <NavButton id="monodromy" label="3. Monodromy & Twists" active={activeTab} set={setActiveTab} icon="Activity" />
                                <NavButton id="vanishing" label="4. Vanishing Cycles" active={activeTab} set={setActiveTab} icon="GitMerge" />
                            </nav>

                            <div className="md:hidden fixed bottom-0 left-0 right-0 bg-white border-t p-2 flex justify-around z-20">
                                 <button onClick={() => setActiveTab('singularities')} className={`p-2 ${activeTab==='singularities' ? 'text-indigo-600' : 'text-slate-400'}`}><Icon name="Eye"/></button>
                                 <button onClick={() => setActiveTab('whitney')} className={`p-2 ${activeTab==='whitney' ? 'text-indigo-600' : 'text-slate-400'}`}><Icon name="Box"/></button>
                                 <button onClick={() => setActiveTab('monodromy')} className={`p-2 ${activeTab==='monodromy' ? 'text-indigo-600' : 'text-slate-400'}`}><Icon name="Activity"/></button>
                                 <button onClick={() => setActiveTab('vanishing')} className={`p-2 ${activeTab==='vanishing' ? 'text-indigo-600' : 'text-slate-400'}`}><Icon name="GitMerge"/></button>
                            </div>

                            <div className="flex-1 overflow-y-auto p-4 md:p-8 bg-slate-50 relative">
                                <div className="max-w-5xl mx-auto h-full min-h-[500px]">
                                    {activeTab === 'singularities' && <EllipticCurveModule />}
                                    {activeTab === 'whitney' && <WhitneyUmbrellaModule />}
                                    {activeTab === 'monodromy' && <MonodromyModule />}
                                    {activeTab === 'vanishing' && <VanishingCyclesModule />}
                                </div>
                            </div>
                        </main>
                    </div>
                </ErrorBoundary>
            );
        };

        const NavButton = ({ id, label, active, set, icon }) => (
            <button
                onClick={() => set(id)}
                className={`flex items-center gap-3 p-3 rounded-lg text-sm font-medium transition-all
                    ${active === id
                        ? 'bg-white text-indigo-600 shadow-sm ring-1 ring-slate-200'
                        : 'text-slate-600 hover:bg-slate-200/50 hover:text-slate-900'
                    }`}
            >
                <Icon name={icon} size={18} />
                {label}
            </button>
        );

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
