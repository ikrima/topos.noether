<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SO(3): The Strange Topology of 3D Rotations</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Palatino', 'Georgia', serif;
            background: #faf8f5;
            color: #2c2416;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 0.5em;
            color: #1a1410;
        }
        
        h2 {
            font-size: 1.6em;
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            color: #1a1410;
        }
        
        p {
            margin-bottom: 1em;
            font-size: 1.1em;
        }
        
        .explorable {
            background: white;
            border-radius: 8px;
            padding: 30px;
            margin: 30px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .canvas-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        
        canvas {
            border-radius: 4px;
            background: #f8f9fa;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }
        
        .slider-group {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .slider-group label {
            min-width: 100px;
            font-weight: 600;
            color: #444;
        }
        
        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #e74c3c;
            border-radius: 50%;
            cursor: pointer;
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #e74c3c;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .value-display {
            min-width: 60px;
            text-align: right;
            font-family: 'Monaco', monospace;
            color: #e74c3c;
            font-weight: bold;
        }
        
        .insight-box {
            background: #fff9e6;
            border-left: 4px solid #f39c12;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .weird-box {
            background: #ffe6f0;
            border-left: 4px solid #e91e63;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        button {
            padding: 12px 24px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1em;
            transition: background 0.2s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        .highlight {
            background: #ffe6e6;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
        }
        
        .caption {
            font-size: 0.95em;
            color: #666;
            font-style: italic;
            margin-top: 15px;
        }
        
        .rotation-info {
            background: #e8f5e9;
            padding: 15px;
            border-radius: 4px;
            margin-top: 15px;
            font-family: 'Monaco', monospace;
            font-size: 0.95em;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>SO(3): The Strange Topology of 3D Rotations</h1>
        <p style="font-size: 1.2em; color: #666; margin-bottom: 2em;">Going deeper into Lie groups</p>
        
        <p>SO(2) was nice and simple — a circle. But SO(3), the group of rotations in three-dimensional space, is where things get genuinely weird. The article mentions it's <span class="highlight">"a six-dimensional tangle of spheres and circles."</span> But what does that actually mean?</p>
        
        <p>You can't visualize six dimensions. But you <em>can</em> interact with rotations in 3D, and you can see their strange topological properties emerge through that interaction.</p>
        
        <h2>Exploration 1: Compose Rotations, Build Intuition</h2>
        
        <div class="explorable">
            <p>Here's a cube you can rotate. But I want you to notice something: <strong>the order matters</strong>. Rotating around X then Y gives you a different result than rotating around Y then X. Groups where order matters are called "non-commutative."</p>
            
            <div class="canvas-container">
                <div style="flex: 1;">
                    <canvas id="rotation3D" width="600" height="500"></canvas>
                </div>
            </div>
            
            <div class="controls">
                <div class="slider-group">
                    <label>X-axis:</label>
                    <input type="range" id="rotX" min="0" max="360" value="0" step="1">
                    <span class="value-display" id="rotXVal">0°</span>
                </div>
                <div class="slider-group">
                    <label>Y-axis:</label>
                    <input type="range" id="rotY" min="0" max="360" value="0" step="1">
                    <span class="value-display" id="rotYVal">0°</span>
                </div>
                <div class="slider-group">
                    <label>Z-axis:</label>
                    <input type="range" id="rotZ" min="0" max="360" value="0" step="1">
                    <span class="value-display" id="rotZVal">0°</span>
                </div>
                <div>
                    <button id="demo360">Rotate 360° Around X</button>
                    <button id="demo720">Rotate 720° Around X</button>
                    <button id="reset">Reset</button>
                </div>
            </div>
            
            <div class="rotation-info" id="rotationInfo">
                Total rotation angle: 0.0°<br>
                Rotation axis: (0.00, 0.00, 0.00)
            </div>
            
            <p class="caption">Try different rotation sequences. Notice that rotating 30° around X then 30° around Y is NOT the same as 30° around Y then 30° around X. Composition of rotations is non-commutative.</p>
        </div>
        
        <div class="insight-box">
            <strong>Key Insight:</strong> Unlike SO(2) (where all rotations commute — it doesn't matter which order you do them), SO(3) is non-commutative. This non-commutativity is what makes it topologically complex.
        </div>
        
        <h2>Exploration 2: The 720° Mystery</h2>
        
        <p>Here's something truly bizarre that you need to experience to believe: In SO(3), a 360° rotation is <em>not</em> the same as the identity (no rotation). You have to rotate <strong>720°</strong> to get back to the identity.</p>
        
        <p>This isn't a mistake. This is real mathematics, and it has physical consequences — it's why electrons have "spin-1/2" and why you need to rotate an electron 720° to return it to its original quantum state.</p>
        
        <div class="explorable">
            <p><strong>The Belt Trick:</strong> This visualization simulates the famous "belt trick" or "Dirac scissors" demonstration. Watch what happens to the connecting thread as we rotate the cube.</p>
            
            <div class="canvas-container">
                <div style="flex: 1;">
                    <canvas id="beltTrick" width="600" height="500"></canvas>
                </div>
            </div>
            
            <div class="controls">
                <div class="slider-group">
                    <label>Rotation:</label>
                    <input type="range" id="beltRotation" min="0" max="1440" value="0" step="1">
                    <span class="value-display" id="beltRotVal">0°</span>
                </div>
                <div>
                    <button id="animate360">Animate 360° Rotation</button>
                    <button id="animate720">Animate 720° Rotation</button>
                    <button id="untangle">Show How 720° Untangles</button>
                </div>
            </div>
            
            <p class="caption">At 360°, the belt is tangled. At 720°, it's untangled again! This demonstrates that in SO(3), there are two "paths" between the identity and itself — you need to loop twice to get the trivial path.</p>
        </div>
        
        <div class="weird-box">
            <strong>This Is Genuinely Weird:</strong> The space of rotations SO(3) has the topology of "real projective 3-space" (ℝP³). It's not simply connected — there are loops that can't be contracted to a point. The universal cover is SU(2), which is a 3-sphere, and there's a 2-to-1 mapping. Every rotation in SO(3) corresponds to TWO elements in SU(2), which differ by a 720° rotation.
            <br><br>
            This isn't mathematical abstraction — this is literally how electron spin works in quantum mechanics.
        </div>
        
        <h2>Exploration 3: Axis-Angle Representation</h2>
        
        <p>Every rotation in 3D can be represented by an <strong>axis</strong> (a direction in 3D space) and an <strong>angle</strong> (how much to rotate around that axis). This is called the axis-angle representation, and it's one way to visualize the group manifold of SO(3).</p>
        
        <div class="explorable">
            <div class="canvas-container">
                <div style="flex: 1;">
                    <canvas id="axisAngle" width="600" height="500"></canvas>
                </div>
            </div>
            
            <div class="controls">
                <div class="slider-group">
                    <label>Axis θ:</label>
                    <input type="range" id="axisTheta" min="0" max="360" value="0" step="1">
                    <span class="value-display" id="axisThetaVal">0°</span>
                </div>
                <div class="slider-group">
                    <label>Axis φ:</label>
                    <input type="range" id="axisPhi" min="0" max="180" value="90" step="1">
                    <span class="value-display" id="axisPhiVal">90°</span>
                </div>
                <div class="slider-group">
                    <label>Angle:</label>
                    <input type="range" id="rotAngle" min="0" max="180" value="45" step="1">
                    <span class="value-display" id="rotAngleVal">45°</span>
                </div>
                <div>
                    <button id="showBall">Visualize SO(3) as a Ball</button>
                </div>
            </div>
            
            <p class="caption">The axis direction (θ, φ) picks a point on a sphere. The rotation angle extends radially. SO(3) can be visualized as a ball of radius π, where opposite points on the boundary are identified (a 180° rotation and a -180° rotation around the same axis are the same).</p>
        </div>
        
        <div class="insight-box">
            <strong>The Manifold Structure:</strong> SO(3) as a manifold is a solid ball of radius π (about 3.14) in 3D space, but with a twist: antipodal points on the boundary sphere are identified as the same point. This identification is what causes the weird 720° property — there are two distinct paths from identity to identity.
        </div>
        
        <h2>Connection to Physics</h2>
        
        <p>Emmy Noether proved that continuous symmetries correspond to conservation laws. For SO(3):</p>
        
        <p><strong>Rotational symmetry → Conservation of angular momentum</strong></p>
        
        <p>The laws of physics are the same regardless of which direction you orient your laboratory in space. This rotational invariance — this symmetry under SO(3) transformations — is why angular momentum is conserved in isolated systems.</p>
        
        <p>The non-trivial topology of SO(3) (the 720° thing) also explains why fermions (electrons, quarks) behave differently from bosons (photons, gluons) under rotations. Fermions pick up a minus sign when you rotate them 360°. You need 720° to get back to the original quantum state. This is described by SU(2), the double cover of SO(3).</p>
        
        <div class="weird-box">
            <strong>Physical Consequence:</strong> If you rotate your entire laboratory 360°, fermion wave functions change sign. This isn't detectable directly (overall phases don't matter in quantum mechanics), but it affects interference patterns and explains the Pauli exclusion principle, which is why matter is stable and why you don't fall through your chair.
        </div>
        
        <h2>What You've Learned</h2>
        
        <p>Through direct manipulation, you've discovered:</p>
        
        <p><strong>1. Non-commutativity:</strong> The order of rotations matters. XY ≠ YX in SO(3).</p>
        
        <p><strong>2. Weird topology:</strong> 360° ≠ identity, but 720° does. The manifold is ℝP³.</p>
        
        <p><strong>3. Axis-angle representation:</strong> Rotations live in a ball of radius π with boundary identifications.</p>
        
        <p><strong>4. Physical meaning:</strong> This isn't abstract — it's how angular momentum, spin, and matter itself works.</p>
        
        <p style="margin-top: 3em; font-style: italic;">Traditional mathematics teaching would have you memorize "SO(3) is ℝP³" and maybe draw some diagrams. But you don't understand ℝP³ until you've rotated objects, seen the tangles form and untangle, felt the non-commutativity, watched the paths trace through the manifold. Mathematics is not symbol manipulation. It's structure you can touch.</p>
    </div>

    <script>
        // Setup for all Three.js scenes
        function initScene(canvas) {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(50, canvas.width / canvas.height, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.width, canvas.height);
            camera.position.z = 5;
            return { scene, camera, renderer };
        }
        
        // Scene 1: Basic 3D Rotation
        const canvas1 = document.getElementById('rotation3D');
        const { scene: scene1, camera: camera1, renderer: renderer1 } = initScene(canvas1);
        
        const geometry1 = new THREE.BoxGeometry(1.5, 1.5, 1.5);
        const materials = [
            new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: false }),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: false }),
            new THREE.MeshBasicMaterial({ color: 0x0000ff, wireframe: false }),
            new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: false }),
            new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: false }),
            new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: false })
        ];
        const cube1 = new THREE.Mesh(geometry1, materials);
        scene1.add(cube1);
        
        // Add edges for clarity
        const edges1 = new THREE.EdgesGeometry(geometry1);
        const line1 = new THREE.LineSegments(edges1, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
        cube1.add(line1);
        
        // Add axes
        const axesHelper1 = new THREE.AxesHelper(2.5);
        scene1.add(axesHelper1);
        
        function updateRotation1() {
            const rx = parseFloat(document.getElementById('rotX').value) * Math.PI / 180;
            const ry = parseFloat(document.getElementById('rotY').value) * Math.PI / 180;
            const rz = parseFloat(document.getElementById('rotZ').value) * Math.PI / 180;
            
            document.getElementById('rotXVal').textContent = Math.round(rx * 180 / Math.PI) + '°';
            document.getElementById('rotYVal').textContent = Math.round(ry * 180 / Math.PI) + '°';
            document.getElementById('rotZVal').textContent = Math.round(rz * 180 / Math.PI) + '°';
            
            // Apply rotations in order: Z, then Y, then X (Euler angles)
            cube1.rotation.set(rx, ry, rz);
            
            // Calculate total rotation angle and axis
            const q = new THREE.Quaternion();
            q.setFromEuler(cube1.rotation);
            const angle = 2 * Math.acos(Math.max(-1, Math.min(1, q.w)));
            const s = Math.sqrt(1 - q.w * q.w);
            let axis = { x: 0, y: 0, z: 0 };
            if (s > 0.001) {
                axis = {
                    x: q.x / s,
                    y: q.y / s,
                    z: q.z / s
                };
            }
            
            document.getElementById('rotationInfo').innerHTML = 
                `Total rotation angle: ${(angle * 180 / Math.PI).toFixed(1)}°<br>` +
                `Rotation axis: (${axis.x.toFixed(2)}, ${axis.y.toFixed(2)}, ${axis.z.toFixed(2)})`;
            
            renderer1.render(scene1, camera1);
        }
        
        document.getElementById('rotX').addEventListener('input', updateRotation1);
        document.getElementById('rotY').addEventListener('input', updateRotation1);
        document.getElementById('rotZ').addEventListener('input', updateRotation1);
        
        document.getElementById('demo360').addEventListener('click', () => {
            let angle = 0;
            const slider = document.getElementById('rotX');
            const interval = setInterval(() => {
                angle += 5;
                if (angle > 360) {
                    clearInterval(interval);
                    angle = 360;
                }
                slider.value = angle;
                updateRotation1();
            }, 20);
        });
        
        document.getElementById('demo720').addEventListener('click', () => {
            let angle = 0;
            const slider = document.getElementById('rotX');
            const interval = setInterval(() => {
                angle += 10;
                if (angle > 720) {
                    clearInterval(interval);
                    angle = 720;
                    setTimeout(() => {
                        slider.value = 0;
                        updateRotation1();
                    }, 1000);
                }
                slider.value = angle % 360;
                updateRotation1();
            }, 20);
        });
        
        document.getElementById('reset').addEventListener('click', () => {
            document.getElementById('rotX').value = 0;
            document.getElementById('rotY').value = 0;
            document.getElementById('rotZ').value = 0;
            updateRotation1();
        });
        
        updateRotation1();
        
        // Scene 2: Belt Trick
        const canvas2 = document.getElementById('beltTrick');
        const { scene: scene2, camera: camera2, renderer: renderer2 } = initScene(canvas2);
        camera2.position.set(0, 2, 5);
        camera2.lookAt(0, 0, 0);
        
        const geometry2 = new THREE.BoxGeometry(1, 1, 1);
        const material2 = new THREE.MeshBasicMaterial({ color: 0x3498db });
        const cube2 = new THREE.Mesh(geometry2, material2);
        cube2.position.y = 0;
        scene2.add(cube2);
        
        const edges2 = new THREE.EdgesGeometry(geometry2);
        const line2 = new THREE.LineSegments(edges2, new THREE.LineBasicMaterial({ color: 0x000000 }));
        cube2.add(line2);
        
        // Create "belts" - ribbons showing the twist
        const beltPoints = [];
        const numBelts = 4;
        const belts = [];
        
        for (let i = 0; i < numBelts; i++) {
            const angle = (i / numBelts) * Math.PI * 2;
            const x = Math.cos(angle) * 0.6;
            const z = Math.sin(angle) * 0.6;
            
            const points = [
                new THREE.Vector3(x, 2, z),
                new THREE.Vector3(x, 0.5, z)
            ];
            
            const beltGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const beltMaterial = new THREE.LineBasicMaterial({ color: 0xe74c3c, linewidth: 3 });
            const belt = new THREE.Line(beltGeometry, beltMaterial);
            scene2.add(belt);
            belts.push({ belt, angle, initialX: x, initialZ: z });
        }
        
        function updateBeltTrick() {
            const rotation = parseFloat(document.getElementById('beltRotation').value) * Math.PI / 180;
            document.getElementById('beltRotVal').textContent = Math.round(rotation * 180 / Math.PI) + '°';
            
            cube2.rotation.y = rotation;
            
            // Update belts to show twisting
            belts.forEach(({ belt, angle, initialX, initialZ }, i) => {
                const rotatedAngle = angle + rotation;
                const x = Math.cos(rotatedAngle) * 0.6;
                const z = Math.sin(rotatedAngle) * 0.6;
                
                // Create a twisted ribbon
                const segments = 20;
                const points = [];
                for (let j = 0; j <= segments; j++) {
                    const t = j / segments;
                    const y = 2 - t * 1.5;
                    const twist = rotation * t;
                    const r = 0.6;
                    const px = Math.cos(angle + twist) * r;
                    const pz = Math.sin(angle + twist) * r;
                    points.push(new THREE.Vector3(px, y, pz));
                }
                
                belt.geometry.setFromPoints(points);
            });
            
            renderer2.render(scene2, camera2);
        }
        
        document.getElementById('beltRotation').addEventListener('input', updateBeltTrick);
        
        document.getElementById('animate360').addEventListener('click', () => {
            let angle = 0;
            const slider = document.getElementById('beltRotation');
            const interval = setInterval(() => {
                angle += 5;
                if (angle > 360) {
                    clearInterval(interval);
                    angle = 360;
                }
                slider.value = angle;
                updateBeltTrick();
            }, 20);
        });
        
        document.getElementById('animate720').addEventListener('click', () => {
            let angle = 0;
            const slider = document.getElementById('beltRotation');
            const interval = setInterval(() => {
                angle += 10;
                if (angle > 720) {
                    clearInterval(interval);
                    angle = 720;
                }
                slider.value = angle;
                updateBeltTrick();
            }, 20);
        });
        
        updateBeltTrick();
        
        // Scene 3: Axis-Angle
        const canvas3 = document.getElementById('axisAngle');
        const { scene: scene3, camera: camera3, renderer: renderer3 } = initScene(canvas3);
        camera3.position.set(3, 3, 3);
        camera3.lookAt(0, 0, 0);
        
        const geometry3 = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const material3 = new THREE.MeshBasicMaterial({ color: 0x9b59b6 });
        const cube3 = new THREE.Mesh(geometry3, material3);
        scene3.add(cube3);
        
        const edges3 = new THREE.EdgesGeometry(geometry3);
        const line3 = new THREE.LineSegments(edges3, new THREE.LineBasicMaterial({ color: 0x000000 }));
        cube3.add(line3);
        
        // Rotation axis visualization
        const axisGeometry = new THREE.BufferGeometry();
        const axisMaterial = new THREE.LineBasicMaterial({ color: 0xe74c3c, linewidth: 3 });
        const axisLine = new THREE.Line(axisGeometry, axisMaterial);
        scene3.add(axisLine);
        
        // Add coordinate axes
        const axesHelper3 = new THREE.AxesHelper(2);
        scene3.add(axesHelper3);
        
        function updateAxisAngle() {
            const theta = parseFloat(document.getElementById('axisTheta').value) * Math.PI / 180;
            const phi = parseFloat(document.getElementById('axisPhi').value) * Math.PI / 180;
            const angle = parseFloat(document.getElementById('rotAngle').value) * Math.PI / 180;
            
            document.getElementById('axisThetaVal').textContent = Math.round(theta * 180 / Math.PI) + '°';
            document.getElementById('axisPhiVal').textContent = Math.round(phi * 180 / Math.PI) + '°';
            document.getElementById('rotAngleVal').textContent = Math.round(angle * 180 / Math.PI) + '°';
            
            // Calculate axis direction
            const axis = new THREE.Vector3(
                Math.sin(phi) * Math.cos(theta),
                Math.cos(phi),
                Math.sin(phi) * Math.sin(theta)
            );
            
            // Update axis line
            const points = [
                new THREE.Vector3(-axis.x * 2, -axis.y * 2, -axis.z * 2),
                new THREE.Vector3(axis.x * 2, axis.y * 2, axis.z * 2)
            ];
            axisLine.geometry.setFromPoints(points);
            
            // Rotate cube around this axis
            const quaternion = new THREE.Quaternion();
            quaternion.setFromAxisAngle(axis, angle);
            cube3.quaternion.copy(quaternion);
            
            renderer3.render(scene3, camera3);
        }
        
        document.getElementById('axisTheta').addEventListener('input', updateAxisAngle);
        document.getElementById('axisPhi').addEventListener('input', updateAxisAngle);
        document.getElementById('rotAngle').addEventListener('input', updateAxisAngle);
        
        updateAxisAngle();
        
        // Animation loop for smooth rendering
        function animate() {
            requestAnimationFrame(animate);
            renderer1.render(scene1, camera1);
            renderer2.render(scene2, camera2);
            renderer3.render(scene3, camera3);
        }
        animate();
    </script>
</body>
</html>