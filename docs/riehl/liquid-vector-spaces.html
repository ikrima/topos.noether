<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Liquid Vector Spaces: Functional Analysis Through Homological Algebra</title>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=IBM+Plex+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'IBM Plex Sans', -apple-system, sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #1a1a2e 50%, #0f0f1a 100%);
            min-height: 100vh;
            color: #e0e0e0;
            line-height: 1.6;
        }
        
        /* Header Styles */
        .essay-header {
            text-align: center;
            padding: 60px 20px 40px;
            background: linear-gradient(180deg, rgba(78, 205, 196, 0.1) 0%, transparent 100%);
            border-bottom: 1px solid rgba(78, 205, 196, 0.2);
        }
        
        .essay-header h1 {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 2.5rem;
            font-weight: 600;
            color: #4ecdc4;
            margin: 0 0 10px;
            letter-spacing: -1px;
        }
        
        .essay-header h2 {
            font-size: 1.2rem;
            font-weight: 300;
            color: #aaa;
            margin: 0 0 20px;
        }
        
        .subtitle {
            font-size: 0.95rem;
            color: #888;
            max-width: 600px;
            margin: 0 auto;
            line-height: 1.6;
        }
        
        /* Navigation */
        .section-nav {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            padding: 20px;
            background: rgba(0,0,0,0.5);
            border-bottom: 1px solid #333;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .nav-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255,255,255,0.05);
            border: 1px solid #333;
            border-radius: 20px;
            color: #888;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'IBM Plex Sans', sans-serif;
        }
        
        .nav-item:hover {
            background: rgba(78, 205, 196, 0.1);
            border-color: #4ecdc4;
            color: #4ecdc4;
        }
        
        .nav-item.active {
            background: rgba(78, 205, 196, 0.2);
            border-color: #4ecdc4;
            color: #4ecdc4;
        }
        
        .nav-number {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
        }
        
        .nav-item.active .nav-number {
            background: #4ecdc4;
            color: #0a0a0f;
        }
        
        /* Main Content */
        .essay-main {
            max-width: 900px;
            margin: 0 auto;
            padding: 40px 20px;
        }
        
        .content-section {
            display: none;
            animation: fadeIn 0.3s ease;
        }
        
        .content-section.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        /* Visualization Container */
        .viz-container {
            background: rgba(255,255,255,0.03);
            border: 1px solid #333;
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
        }
        
        .viz-title {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 1.4rem;
            color: #4ecdc4;
            margin: 0 0 15px;
        }
        
        .viz-description {
            color: #aaa;
            line-height: 1.7;
            margin-bottom: 25px;
            font-size: 0.95rem;
        }
        
        /* Canvas and SVG */
        .main-svg, .main-canvas {
            display: block;
            width: 100%;
            max-width: 600px;
            margin: 0 auto 20px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
        }
        
        /* Controls */
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
            padding: 15px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
        }
        
        .control-row label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85rem;
            color: #888;
            min-width: 100px;
        }
        
        .control-row input[type="range"] {
            flex: 1;
            height: 6px;
            background: #333;
            border-radius: 3px;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }
        
        .control-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #4ecdc4;
            border-radius: 50%;
            cursor: grab;
        }
        
        .control-row input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #4ecdc4;
            border-radius: 50%;
            cursor: grab;
            border: none;
        }
        
        .value-display {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.9rem;
            color: #4ecdc4;
            min-width: 50px;
            text-align: right;
        }
        
        /* Buttons */
        .button-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
        }
        
        .btn {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85rem;
            padding: 10px 20px;
            background: rgba(78, 205, 196, 0.1);
            border: 1px solid #4ecdc4;
            color: #4ecdc4;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .btn:hover {
            background: rgba(78, 205, 196, 0.2);
        }
        
        .btn.active {
            background: #4ecdc4;
            color: #0a0a0f;
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        /* Insight Box */
        .insight-box {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.1) 0%, rgba(78, 205, 196, 0.05) 100%);
            border-left: 3px solid #4ecdc4;
            padding: 20px;
            margin-top: 20px;
            border-radius: 0 8px 8px 0;
            font-size: 0.9rem;
            line-height: 1.7;
        }
        
        .insight-box strong {
            color: #4ecdc4;
        }
        
        .scholze-quote {
            font-style: italic;
            text-align: center;
        }
        
        .quote-attribution {
            margin-top: 10px;
            font-style: normal;
            color: #888;
            font-size: 0.85rem;
        }
        
        /* Verification */
        .verification-container {
            text-align: center;
            padding: 30px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            margin: 20px 0;
        }
        
        .progress-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #45b7aa);
            border-radius: 4px;
            transition: width 0.1s ease;
            width: 0%;
        }
        
        .progress-label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 1rem;
            color: #4ecdc4;
            margin-bottom: 15px;
        }
        
        /* Stats Grid */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }
        
        .stat-box {
            background: rgba(255,255,255,0.03);
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
        }
        
        .stat-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 2rem;
            color: #4ecdc4;
            font-weight: 600;
        }
        
        .stat-label {
            font-size: 0.9rem;
            color: #aaa;
            margin-top: 5px;
        }
        
        .stat-note {
            font-size: 0.75rem;
            color: #666;
            margin-top: 3px;
        }
        
        /* Details Panel */
        .details-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 20px;
            margin-top: 15px;
            display: none;
        }
        
        .details-panel.visible {
            display: block;
        }
        
        .detail-item {
            display: flex;
            gap: 15px;
            padding: 15px 0;
            border-bottom: 1px solid #333;
        }
        
        .detail-item:last-child {
            border-bottom: none;
        }
        
        .detail-icon {
            font-size: 1.5rem;
        }
        
        .detail-item strong {
            color: #4ecdc4;
        }
        
        /* Comparison Table */
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 0.85rem;
        }
        
        .comparison-table th,
        .comparison-table td {
            padding: 12px 15px;
            border: 1px solid #333;
            text-align: left;
        }
        
        .comparison-table th {
            background: rgba(78, 205, 196, 0.1);
            color: #4ecdc4;
            font-family: 'IBM Plex Mono', monospace;
        }
        
        .comparison-table td {
            background: rgba(0,0,0,0.2);
        }
        
        /* Footer */
        .essay-footer {
            text-align: center;
            padding: 40px 20px;
            border-top: 1px solid #333;
            color: #666;
            font-size: 0.85rem;
        }
        
        .credits {
            margin-top: 10px;
            font-size: 0.75rem;
            color: #555;
        }
        
        /* Equation Display */
        .equation {
            font-family: 'IBM Plex Mono', monospace;
            background: rgba(0,0,0,0.3);
            padding: 15px 25px;
            border-radius: 8px;
            text-align: center;
            margin: 20px 0;
            font-size: 1.1rem;
            color: #4ecdc4;
            border: 1px solid #333;
        }
        
        /* Space Types Table */
        .space-types-table {
            width: 100%;
            margin: 20px 0;
        }
        
        .space-types-table td {
            padding: 8px 12px;
            border-bottom: 1px solid #333;
        }
        
        .space-types-table tr:last-child td {
            border-bottom: none;
        }
        
        .checkmark {
            color: #4ecdc4;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .essay-header h1 {
                font-size: 1.8rem;
            }
            
            .section-nav {
                gap: 5px;
                padding: 15px 10px;
            }
            
            .nav-item {
                padding: 6px 12px;
                font-size: 0.75rem;
            }
            
            .nav-title {
                display: none;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .viz-container {
                padding: 20px 15px;
            }
            
            .control-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .control-row label {
                min-width: auto;
            }
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #1a1a2e;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #4ecdc4;
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #45b7aa;
        }
    </style>
</head>
<body>
    <header class="essay-header">
        <h1>Liquid Vector Spaces</h1>
        <h2>Functional Analysis Through the Lens of Homological Algebra</h2>
        <p class="subtitle">
            An interactive exploration of Clausen-Scholze's condensed mathematics,
            where classical theorems emerge from Ext vanishing
        </p>
    </header>
    
    <nav class="section-nav" id="nav">
        <!-- Generated by JavaScript -->
    </nav>
    
    <main class="essay-main">
        <!-- Section 1: The Broken Promise -->
        <section class="content-section active" id="section-0">
            <div class="viz-container">
                <h3 class="viz-title">The Identity That Isn't</h3>
                <p class="viz-description">
                    The map id: (‚Ñù, discrete) ‚Üí (‚Ñù, standard) has trivial kernel and cokernel, 
                    yet fails to be an isomorphism. This fundamental failure shows why topological 
                    abelian groups cannot form an abelian category‚Äîthe foundation of homological algebra.
                </p>
                
                <svg viewBox="0 0 600 320" class="main-svg" id="broken-promise-svg">
                    <!-- Rendered by JavaScript -->
                </svg>
                
                <div class="equation">
                    ker(id) = 0, &nbsp; coker(id) = 0, &nbsp; yet id ‚â† isomorphism
                </div>
                
                <div class="insight-box">
                    <strong>The Fatal Defect:</strong> In an abelian category, a morphism with trivial 
                    kernel and cokernel <em>must</em> be an isomorphism. Topological abelian groups 
                    fail this axiom‚Äîthe category is fundamentally broken for homological algebra. 
                    Clausen and Scholze's solution: replace topological spaces with <em>condensed sets</em>.
                </div>
            </div>
        </section>
        
        <!-- Section 2: Condensed Sets -->
        <section class="content-section" id="section-1">
            <div class="viz-container">
                <h3 class="viz-title">Condensed Sets: Topology Through Probes</h3>
                <p class="viz-description">
                    A condensed set XÃ≤ remembers all continuous maps from compact Hausdorff spaces. 
                    Rather than asking "what are the open sets?", we ask "what do all compact probes see?".
                    Each probe S reveals different topological information about X.
                </p>
                
                <canvas id="condensed-canvas" width="600" height="350" class="main-canvas"></canvas>
                
                <div class="control-row">
                    <label>Number of probes:</label>
                    <input type="range" id="probe-slider" min="1" max="8" value="4">
                    <span class="value-display" id="probe-value">4</span>
                </div>
                
                <div class="equation">
                    XÃ≤(S) = Cont(S, X) &nbsp;&nbsp;|&nbsp;&nbsp; S profinite
                </div>
                
                <div class="insight-box">
                    <strong>Key Insight:</strong> The functor S ‚Ü¶ Cont(S, X) carries strictly more 
                    information than just the underlying set. The quotient Q = ‚Ñù<sub>nat</sub> / ‚Ñù<sub>disc</sub> 
                    has Q(*) = 0 but Q(S) ‚â† 0 for general profinite S. Condensed structures encode 
                    topology as <em>families of maps</em> rather than open sets.
                </div>
            </div>
        </section>
        
        <!-- Section 3: The p-Ball Journey -->
        <section class="content-section" id="section-2">
            <div class="viz-container">
                <h3 class="viz-title">The p-Norm Unit Ball: Where Convexity Dies</h3>
                <p class="viz-description">
                    The unit ball {x : ‚Äñx‚Äñ<sub>p</sub> ‚â§ 1} transforms dramatically as p varies. 
                    At p = 2 we have the familiar Euclidean circle. At p = 1, the boundary becomes 
                    diamond-shaped. Below p = 1, convexity fails entirely‚Äîthis is where liquid 
                    vector spaces live.
                </p>
                
                <canvas id="pball-canvas" width="600" height="400" class="main-canvas"></canvas>
                
                <div class="control-row">
                    <label>p value:</label>
                    <input type="range" id="p-slider" min="0.1" max="2.5" step="0.01" value="1">
                    <span class="value-display" id="p-value">1.00</span>
                </div>
                
                <div class="button-row">
                    <button class="btn" onclick="animateP(2)">p = 2 (Euclidean)</button>
                    <button class="btn" onclick="animateP(1)">p = 1 (Banach)</button>
                    <button class="btn" onclick="animateP(0.5)">p = 0.5 (Liquid)</button>
                    <button class="btn" onclick="animateP(0.2)">p ‚Üí 0 (Gaseous)</button>
                </div>
                
                <table class="comparison-table">
                    <tr>
                        <th>Space Type</th>
                        <th>p-Liquid Status</th>
                    </tr>
                    <tr>
                        <td>Banach spaces</td>
                        <td><span class="checkmark">‚úì</span> All p &lt; 1</td>
                    </tr>
                    <tr>
                        <td>p-Banach spaces</td>
                        <td><span class="checkmark">‚úì</span> All q &gt; p</td>
                    </tr>
                    <tr>
                        <td>Fr√©chet spaces</td>
                        <td><span class="checkmark">‚úì</span> All p &lt; 1</td>
                    </tr>
                    <tr>
                        <td>Nuclear Fr√©chet</td>
                        <td><span class="checkmark">‚úì</span> All p (tensor ‚äó independent of p)</td>
                    </tr>
                </table>
                
                <div class="insight-box">
                    <strong>Why p ‚â§ 1?</strong> The triangle inequality requires p ‚â§ 1 over ‚Ñù. 
                    The Ribe extension forces p &lt; 1 for closure under extensions. 
                    <strong>Kalton's theorem:</strong> extensions of p-Banach spaces are p'-Banach 
                    for all p' &lt; p. This is why p-liquid (with strict inequality in ‚Ñ≥<sub>&lt;p</sub>) 
                    gives closure under extensions.
                </div>
            </div>
        </section>
        
        <!-- Section 4: Measure Spaces -->
        <section class="content-section" id="section-3">
            <div class="viz-container">
                <h3 class="viz-title">The p-Measure Space ‚Ñ≥<sub>p</sub>(S)</h3>
                <p class="viz-description">
                    For a profinite set S = lim S<sub>i</sub>, the space ‚Ñ≥<sub>p</sub>(S) consists 
                    of "measures" with p-summable coefficients. Drag the points to see how the 
                    p-constraint shapes allowed configurations.
                </p>
                
                <canvas id="measure-canvas" width="600" height="350" class="main-canvas"></canvas>
                
                <div class="control-row">
                    <label>p value:</label>
                    <input type="range" id="measure-p-slider" min="0.1" max="1" step="0.01" value="0.7">
                    <span class="value-display" id="measure-p-value">0.70</span>
                </div>
                
                <div class="equation">
                    ‚Ñ≥<sub>p</sub>(S) = ‚ãÉ<sub>C&gt;0</sub> lim<sub>‚Üêi</sub> {(x<sub>s</sub>) ‚àà ‚Ñù<sup>S<sub>i</sub></sup> : Œ£|x<sub>s</sub>|<sup>p</sup> ‚â§ C}
                </div>
                
                <div class="insight-box">
                    <strong>The &lt;p Subtlety:</strong> We use ‚Ñ≥<sub>&lt;p</sub> = ‚à™<sub>q&lt;p</sub> ‚Ñ≥<sub>q</sub> 
                    rather than ‚Ñ≥<sub>p</sub> itself. Why? The quotient ‚Ñì¬≤/‚Ñì¬π admits two distinct 
                    extensions of the zero sequence via the entropy map œÜ(x) = x log|x|. 
                    ‚Ñ≥<sub>p</sub> fails uniqueness, but ‚Ñ≥<sub>&lt;p</sub> resolves this.
                </div>
            </div>
        </section>
        
        <!-- Section 5: Completeness Spectrum -->
        <section class="content-section" id="section-4">
            <div class="viz-container">
                <h3 class="viz-title">The Completeness Spectrum</h3>
                <p class="viz-description">
                    Mathematical structures occupy different points on the rigidity spectrum.
                    Liquid is the Goldilocks zone‚Äîenough structure for homological algebra, 
                    enough flexibility for real analysis.
                </p>
                
                <canvas id="spectrum-canvas" width="600" height="380" class="main-canvas"></canvas>
                
                <div class="control-row">
                    <label>Position:</label>
                    <input type="range" id="spectrum-slider" min="0" max="1" step="0.01" value="0.5">
                    <span class="value-display" id="spectrum-value">Liquid</span>
                </div>
                
                <div class="insight-box">
                    <strong>Why "Liquid"?</strong> Like physical liquids, these spaces flow 
                    (closure under limits and colimits) yet maintain coherent structure (abelian category). 
                    <em>Solid</em> freezes too rigidly over ‚Ñù (works perfectly for ‚Ñö<sub>p</sub>). 
                    <em>Gaseous</em> dissipates all structure. The liquid condition V is p-liquid iff 
                    every map f: S ‚Üí V extends uniquely to ‚Ñ≥<sub>&lt;p</sub>(S) ‚Üí V.
                </div>
            </div>
        </section>
        
        <!-- Section 6: Ext Vanishing -->
        <section class="content-section" id="section-5">
            <div class="viz-container">
                <h3 class="viz-title">Ext Vanishing: Extensions That Split</h3>
                <p class="viz-description">
                    The Clausen-Scholze theorem: Ext<sup>i</sup>(‚Ñ≥<sub>p'</sub>(S), V) = 0 for p' &lt; p 
                    and V a p-Banach space. This means all extensions split‚Äîthe categorical magic 
                    enabling liquid functional analysis.
                </p>
                
                <canvas id="ext-canvas" width="600" height="380" class="main-canvas"></canvas>
                
                <div class="button-row">
                    <button class="btn" onclick="showExtension('twisted')">Show Twisted Extension</button>
                    <button class="btn" onclick="showExtension('split')">Show Split Extension (Ext=0)</button>
                </div>
                
                <div class="control-row">
                    <label>Split progress:</label>
                    <input type="range" id="ext-slider" min="0" max="1" step="0.01" value="0">
                    <span class="value-display" id="ext-value">0%</span>
                </div>
                
                <div class="equation">
                    Ext<sup>i</sup><sub>Cond(Ab)</sub>(‚Ñ≥<sub>p'</sub>(S), V) = 0 &nbsp;&nbsp; for all i ‚â• 1
                </div>
                
                <div class="insight-box">
                    <strong>Scholze's Assessment:</strong> "The most logically involved statement I have 
                    ever proved... possibly my most important theorem to date." The proof requires 
                    implicit constants chosen in exactly the right order‚Äîa statement "of the form 
                    ‚àÄ‚àÉ‚àÄ‚àÉ‚àÄ‚àÉ with no messing around with quantifier order."
                </div>
            </div>
        </section>
        
        <!-- Section 7: Open Mapping Theorem -->
        <section class="content-section" id="section-6">
            <div class="viz-container">
                <h3 class="viz-title">Open Mapping Theorem: Two Worlds</h3>
                <p class="viz-description">
                    The same theorem, proved two fundamentally different ways. Classical functional 
                    analysis uses Baire category arguments; liquid vector spaces use Ext vanishing.
                </p>
                
                <canvas id="omt-canvas" width="600" height="400" class="main-canvas"></canvas>
                
                <div class="button-row">
                    <button class="btn active" id="btn-classical" onclick="setOMTProof('classical')">
                        Classical (Baire Category)
                    </button>
                    <button class="btn" id="btn-liquid" onclick="setOMTProof('liquid')">
                        Liquid (Ext Vanishing)
                    </button>
                </div>
                
                <table class="comparison-table">
                    <tr>
                        <th>Aspect</th>
                        <th>Baire Category</th>
                        <th>Liquid/Homological</th>
                    </tr>
                    <tr>
                        <td>Key tool</td>
                        <td>Dense GŒ¥ sets</td>
                        <td>Ext vanishing</td>
                    </tr>
                    <tr>
                        <td>Completeness</td>
                        <td>Metric</td>
                        <td>Categorical closure properties</td>
                    </tr>
                    <tr>
                        <td>Scope</td>
                        <td>Metrizable/Fr√©chet</td>
                        <td>General profinite indexing</td>
                    </tr>
                    <tr>
                        <td>Extensions</td>
                        <td>Not addressed</td>
                        <td>Central to theory</td>
                    </tr>
                </table>
                
                <div class="insight-box">
                    <strong>The Unification:</strong> The hard analysis is black-boxed into the 
                    Ext vanishing theorem. Once established, purely categorical arguments suffice. 
                    For algebraic geometers, this offers "a nonzero chance to proceed without 
                    leaving the comfort of your preferred topos."
                </div>
            </div>
        </section>
        
        <!-- Section 8: Liquid Tensor Experiment -->
        <section class="content-section" id="section-7">
            <div class="viz-container">
                <h3 class="viz-title">The Liquid Tensor Experiment</h3>
                <p class="viz-description">
                    December 2020 ‚Äì July 2022: The first formalization of cutting-edge research 
                    mathematics in Lean. Scholze challenged the community because he had 
                    "small lingering doubts" about his proof.
                </p>
                
                <div class="verification-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="verify-progress"></div>
                    </div>
                    <div class="progress-label" id="verify-label">Click to verify theorem</div>
                    <button class="btn" id="verify-btn" onclick="runVerification()">Run Verification</button>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-box">
                        <div class="stat-value">~20</div>
                        <div class="stat-label">de Bruijn Factor</div>
                        <div class="stat-note">(Remarkably small)</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">19</div>
                        <div class="stat-label">Months</div>
                        <div class="stat-note">Dec 2020 ‚Äì July 2022</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-value">0</div>
                        <div class="stat-label">Critical Errors</div>
                        <div class="stat-note">Minor issues only</div>
                    </div>
                </div>
                
                <button class="btn" style="width: 100%; margin: 20px 0;" onclick="toggleDetails()">
                    Show What Was Learned
                </button>
                
                <div class="details-panel" id="details-panel">
                    <div class="detail-item">
                        <span class="detail-icon">üîç</span>
                        <div>
                            <strong>Minor Issues Found:</strong> Quotient norm subtleties 
                            (infimum need not be minimum), hypothesis corrections in Lemma 9.6
                        </div>
                    </div>
                    <div class="detail-item">
                        <span class="detail-icon">üí°</span>
                        <div>
                            <strong>Major Insight:</strong> The non-explicit Breen-Deligne resolution 
                            from stable homotopy theory can be replaced by a completely explicit 
                            construction‚Äîeliminating the need for stable homotopy theory
                        </div>
                    </div>
                    <div class="detail-item">
                        <span class="detail-icon">üéØ</span>
                        <div>
                            <strong>Key Reduction:</strong> "A reduction from a non-convex problem 
                            over the reals to a convex problem over the integers"
                        </div>
                    </div>
                </div>
                
                <div class="insight-box scholze-quote">
                    <em>"This experiment has changed drastically my impression of proof assistants. 
                    I now think it's sensible to formalize whatever you want in Lean."</em>
                    <div class="quote-attribution">‚Äî Peter Scholze</div>
                </div>
            </div>
        </section>
    </main>
    
    <footer class="essay-footer">
        <p>
            Based on Clausen-Scholze's <em>Condensed Mathematics</em> program.
            Verified in Lean via the Liquid Tensor Experiment (2020-2022).
        </p>
        <p class="credits">
            Visualization inspired by Bret Victor, Steven Wittens, and Bartosz Ciechanowski
        </p>
    </footer>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // STATE MANAGEMENT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const state = {
            activeSection: 0,
            p: 1.0,
            measureP: 0.7,
            probeCount: 4,
            spectrumPos: 0.5,
            extProgress: 0,
            omtProof: 'classical',
            time: 0,
            animating: false,
            measurePoints: [],
            draggedPoint: null,
            verifying: false,
            verifyProgress: 0
        };
        
        const sections = [
            'The Broken Promise',
            'Condensed Sets',
            'The p-Ball Journey',
            'Measure Spaces',
            'Completeness Spectrum',
            'Ext Vanishing',
            'Open Mapping Theorem',
            'Liquid Tensor Experiment'
        ];
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // NAVIGATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function initNavigation() {
            const nav = document.getElementById('nav');
            sections.forEach((title, i) => {
                const btn = document.createElement('button');
                btn.className = 'nav-item' + (i === 0 ? ' active' : '');
                btn.innerHTML = `<span class="nav-number">${i + 1}</span><span class="nav-title">${title}</span>`;
                btn.onclick = () => setSection(i);
                nav.appendChild(btn);
            });
        }
        
        function setSection(index) {
            state.activeSection = index;
            
            // Update nav
            document.querySelectorAll('.nav-item').forEach((item, i) => {
                item.classList.toggle('active', i === index);
            });
            
            // Update sections
            document.querySelectorAll('.content-section').forEach((section, i) => {
                section.classList.toggle('active', i === index);
            });
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SECTION 1: BROKEN PROMISE
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function renderBrokenPromise() {
            const svg = document.getElementById('broken-promise-svg');
            svg.innerHTML = `
                <!-- Discrete topology -->
                <g transform="translate(100, 150)">
                    <text x="0" y="-100" fill="#fff" font-family="IBM Plex Mono" font-size="14" text-anchor="middle">
                        (‚Ñù, discrete)
                    </text>
                    ${[-2, -1, 0, 1, 2].map(n => `
                        <circle cx="${n * 40}" cy="0" r="10" fill="#4ecdc4" opacity="0.8"/>
                        <text x="${n * 40}" y="35" fill="#888" font-family="IBM Plex Mono" font-size="11" text-anchor="middle">${n}</text>
                    `).join('')}
                    <text x="0" y="65" fill="#666" font-family="IBM Plex Sans" font-size="11" text-anchor="middle">
                        Every point is open (isolated)
                    </text>
                </g>
                
                <!-- Arrow -->
                <g transform="translate(300, 150)">
                    <defs>
                        <marker id="arrow" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#ff6b6b"/>
                        </marker>
                    </defs>
                    <line x1="-60" y1="0" x2="60" y2="0" stroke="#ff6b6b" stroke-width="3" marker-end="url(#arrow)"/>
                    <text x="0" y="-15" fill="#ff6b6b" font-family="IBM Plex Mono" font-size="16" text-anchor="middle">id</text>
                    <text x="0" y="25" fill="#888" font-family="IBM Plex Mono" font-size="10" text-anchor="middle">bijective, continuous</text>
                    <text x="0" y="40" fill="#ff6b6b" font-family="IBM Plex Mono" font-size="10" text-anchor="middle">NOT an isomorphism!</text>
                </g>
                
                <!-- Standard topology -->
                <g transform="translate(500, 150)">
                    <text x="0" y="-100" fill="#fff" font-family="IBM Plex Mono" font-size="14" text-anchor="middle">
                        (‚Ñù, standard)
                    </text>
                    <line x1="-100" y1="0" x2="100" y2="0" stroke="#4ecdc4" stroke-width="4"/>
                    ${[-2, -1, 0, 1, 2].map(n => `
                        <circle cx="${n * 40}" cy="0" r="6" fill="#4ecdc4"/>
                        <text x="${n * 40}" y="35" fill="#888" font-family="IBM Plex Mono" font-size="11" text-anchor="middle">${n}</text>
                    `).join('')}
                    <text x="0" y="65" fill="#666" font-family="IBM Plex Sans" font-size="11" text-anchor="middle">
                        Connected continuum
                    </text>
                </g>
                
                <!-- Problem statement -->
                <g transform="translate(300, 280)">
                    <text fill="#aaa" font-family="IBM Plex Mono" font-size="12" text-anchor="middle">
                        In abelian categories: ker=0, coker=0 ‚üπ isomorphism
                    </text>
                    <text y="20" fill="#ff6b6b" font-family="IBM Plex Mono" font-size="12" text-anchor="middle">
                        TopAb violates this axiom ‚Üí not abelian!
                    </text>
                </g>
            `;
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SECTION 2: CONDENSED SETS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function renderCondensed() {
            const canvas = document.getElementById('condensed-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            
            ctx.clearRect(0, 0, w, h);
            
            // Target space (lemniscate)
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let t = 0; t < Math.PI * 2; t += 0.01) {
                const scale = 70;
                const x = w/2 + scale * Math.sin(t);
                const y = h/2 - 50 + scale * Math.sin(t) * Math.cos(t);
                if (t === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#fff';
            ctx.font = '14px "IBM Plex Mono"';
            ctx.textAlign = 'center';
            ctx.fillText('Target Space X', w/2, 35);
            
            // Draw probing compact sets
            for (let i = 0; i < state.probeCount; i++) {
                const angle = (i / state.probeCount) * Math.PI * 2 + state.time * 0.3;
                const radius = 25 + i * 5;
                const cx = w/2 + Math.cos(angle) * 160;
                const cy = h/2 + 90;
                
                const hue = (i * 50 + 180) % 360;
                
                // Probe circle
                ctx.strokeStyle = `hsl(${hue}, 70%, 60%)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Label
                ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                ctx.font = '10px "IBM Plex Mono"';
                ctx.fillText(`S${i+1}`, cx, cy + radius + 15);
                
                // Mapping curves
                ctx.strokeStyle = `hsla(${hue}, 70%, 60%, 0.3)`;
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                
                for (let t = 0; t < Math.PI * 2; t += 0.3) {
                    const px = cx + Math.cos(t) * radius;
                    const py = cy + Math.sin(t) * radius;
                    
                    const targetT = t + angle;
                    const scale = 70;
                    const tx = w/2 + scale * Math.sin(targetT);
                    const ty = h/2 - 50 + scale * Math.sin(targetT) * Math.cos(targetT);
                    
                    ctx.moveTo(px, py);
                    ctx.lineTo(tx, ty);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Bottom label
            ctx.fillStyle = '#888';
            ctx.font = '12px "IBM Plex Mono"';
            ctx.fillText('Compact probes S map continuously into X', w/2, h - 15);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SECTION 3: P-BALL
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function renderPBall() {
            const canvas = document.getElementById('pball-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const cx = w/2, cy = h/2;
            const scale = 130;
            
            ctx.clearRect(0, 0, w, h);
            
            // Grid
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            for (let i = -2; i <= 2; i++) {
                ctx.beginPath();
                ctx.moveTo(cx + i * scale/2, 30);
                ctx.lineTo(cx + i * scale/2, h - 30);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(30, cy + i * scale/2);
                ctx.lineTo(w - 30, cy + i * scale/2);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(30, cy);
            ctx.lineTo(w - 30, cy);
            ctx.moveTo(cx, 30);
            ctx.lineTo(cx, h - 30);
            ctx.stroke();
            
            // Comparison p-balls (faded)
            [2, 1, 0.5].forEach(compP => {
                if (Math.abs(compP - state.p) < 0.1) return;
                
                ctx.strokeStyle = `hsla(${compP * 90}, 40%, 40%, 0.25)`;
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                
                for (let angle = 0; angle <= Math.PI * 2; angle += 0.02) {
                    const cosA = Math.cos(angle), sinA = Math.sin(angle);
                    const r = 1 / Math.pow(Math.pow(Math.abs(cosA), compP) + Math.pow(Math.abs(sinA), compP), 1/compP);
                    const x = cx + r * cosA * scale;
                    const y = cy - r * sinA * scale;
                    if (angle === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
            });
            
            // Main p-ball
            const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, scale * 1.5);
            const hue = state.p * 90;
            gradient.addColorStop(0, `hsla(${hue}, 80%, 55%, 0.5)`);
            gradient.addColorStop(1, `hsla(${hue}, 80%, 55%, 0)`);
            ctx.fillStyle = gradient;
            
            ctx.beginPath();
            for (let angle = 0; angle <= Math.PI * 2; angle += 0.01) {
                const cosA = Math.cos(angle), sinA = Math.sin(angle);
                const r = 1 / Math.pow(Math.pow(Math.abs(cosA), state.p) + Math.pow(Math.abs(sinA), state.p), 1/state.p);
                const x = cx + r * cosA * scale;
                const y = cy - r * sinA * scale;
                if (angle === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = `hsl(${hue}, 80%, 55%)`;
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // Convexity indicator
            const isConvex = state.p >= 1;
            ctx.fillStyle = isConvex ? '#4ecdc4' : '#ff6b6b';
            ctx.font = 'bold 18px "IBM Plex Mono"';
            ctx.textAlign = 'center';
            ctx.fillText(isConvex ? '‚úì CONVEX' : '‚úó NON-CONVEX', cx, 28);
            
            // P value
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 24px "IBM Plex Mono"';
            ctx.fillText(`p = ${state.p.toFixed(2)}`, cx, h - 15);
            
            // Regime label
            ctx.font = '12px "IBM Plex Mono"';
            ctx.fillStyle = '#888';
            let regime = 'Liquid regime';
            if (state.p > 1.5) regime = 'Euclidean regime';
            else if (state.p > 0.9) regime = 'Banach regime';
            else if (state.p < 0.3) regime = 'Approaching gaseous';
            ctx.fillText(regime, cx, h - 38);
            
            // Axis labels
            ctx.fillStyle = '#666';
            ctx.font = '11px "IBM Plex Mono"';
            ctx.fillText('x', w - 20, cy + 15);
            ctx.fillText('y', cx + 10, 25);
        }
        
        function animateP(targetP) {
            if (state.animating) return;
            state.animating = true;
            
            const startP = state.p;
            const duration = 800;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                
                state.p = startP + (targetP - startP) * eased;
                document.getElementById('p-slider').value = state.p;
                document.getElementById('p-value').textContent = state.p.toFixed(2);
                renderPBall();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    state.animating = false;
                }
            }
            animate();
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SECTION 4: MEASURE SPACES
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function initMeasurePoints() {
            state.measurePoints = [];
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                state.measurePoints.push({
                    x: Math.cos(angle) * 0.5,
                    y: Math.sin(angle) * 0.5,
                    id: i
                });
            }
        }
        
        function renderMeasure() {
            const canvas = document.getElementById('measure-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const cx = w/2, cy = h/2;
            const scale = 120;
            
            ctx.clearRect(0, 0, w, h);
            
            // Grid
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 1;
            for (let i = -3; i <= 3; i++) {
                ctx.beginPath();
                ctx.moveTo(cx + i * scale/3, 0);
                ctx.lineTo(cx + i * scale/3, h);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, cy + i * scale/3);
                ctx.lineTo(w, cy + i * scale/3);
                ctx.stroke();
            }
            
            // Draw p-ball constraint
            const hue = state.measureP * 180;
            ctx.fillStyle = `hsla(${hue}, 60%, 40%, 0.25)`;
            ctx.strokeStyle = `hsl(${hue}, 60%, 50%)`;
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            for (let angle = 0; angle <= Math.PI * 2; angle += 0.01) {
                const cosA = Math.cos(angle), sinA = Math.sin(angle);
                const r = 1 / Math.pow(Math.pow(Math.abs(cosA), state.measureP) + Math.pow(Math.abs(sinA), state.measureP), 1/state.measureP);
                const x = cx + r * cosA * scale;
                const y = cy - r * sinA * scale;
                if (angle === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw measure points
            state.measurePoints.forEach((pt, i) => {
                const x = cx + pt.x * scale;
                const y = cy - pt.y * scale;
                
                const norm = Math.pow(Math.pow(Math.abs(pt.x), state.measureP) + Math.pow(Math.abs(pt.y), state.measureP), 1/state.measureP);
                const inside = norm <= 1;
                
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fillStyle = inside ? '#4ecdc4' : '#ff6b6b';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.fillStyle = '#fff';
                ctx.font = '9px "IBM Plex Mono"';
                ctx.textAlign = 'center';
                ctx.fillText(`Œº${i}`, x, y + 22);
            });
            
            // Title
            ctx.fillStyle = '#fff';
            ctx.font = '14px "IBM Plex Mono"';
            ctx.textAlign = 'center';
            ctx.fillText(`‚Ñ≥${state.measureP.toFixed(1)}(S) = {Œº : Œ£|Œº‚Çõ|^p ‚â§ C}`, cx, 25);
            
            // Total norm
            const totalNorm = state.measurePoints.reduce((sum, pt) => 
                sum + Math.pow(Math.abs(pt.x), state.measureP) + Math.pow(Math.abs(pt.y), state.measureP), 0);
            ctx.font = '12px "IBM Plex Mono"';
            ctx.fillStyle = totalNorm <= state.measurePoints.length ? '#4ecdc4' : '#ff6b6b';
            ctx.fillText(`Œ£|Œº|^p = ${totalNorm.toFixed(2)}`, cx, h - 15);
        }
        
        function setupMeasureDrag() {
            const canvas = document.getElementById('measure-canvas');
            if (!canvas) return;
            
            canvas.style.cursor = 'grab';
            
            canvas.onmousedown = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - canvas.width/2) / 120;
                const y = -(e.clientY - rect.top - canvas.height/2) / 120;
                
                let closest = null, minDist = Infinity;
                state.measurePoints.forEach((pt, i) => {
                    const dist = Math.sqrt((pt.x - x)**2 + (pt.y - y)**2);
                    if (dist < minDist && dist < 0.15) {
                        minDist = dist;
                        closest = i;
                    }
                });
                
                if (closest !== null) {
                    state.draggedPoint = closest;
                    canvas.style.cursor = 'grabbing';
                }
            };
            
            canvas.onmousemove = (e) => {
                if (state.draggedPoint === null) return;
                const rect = canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - canvas.width/2) / 120;
                const y = -(e.clientY - rect.top - canvas.height/2) / 120;
                
                state.measurePoints[state.draggedPoint].x = Math.max(-1.2, Math.min(1.2, x));
                state.measurePoints[state.draggedPoint].y = Math.max(-1.2, Math.min(1.2, y));
                renderMeasure();
            };
            
            canvas.onmouseup = canvas.onmouseleave = () => {
                state.draggedPoint = null;
                canvas.style.cursor = 'grab';
            };
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SECTION 5: COMPLETENESS SPECTRUM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function renderSpectrum() {
            const canvas = document.getElementById('spectrum-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            
            ctx.clearRect(0, 0, w, h);
            
            // Spectrum bar
            const gradient = ctx.createLinearGradient(50, 0, w - 50, 0);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#4ecdc4');
            gradient.addColorStop(1, '#ff6b6b');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(50, 100, w - 100, 50);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(50, 100, w - 100, 50);
            
            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 14px "IBM Plex Mono"';
            ctx.textAlign = 'center';
            ctx.fillText('GASEOUS', 100, 90);
            ctx.fillText('LIQUID', w/2, 90);
            ctx.fillText('SOLID', w - 100, 90);
            
            ctx.font = '11px "IBM Plex Mono"';
            ctx.fillStyle = '#888';
            ctx.fillText('p ‚Üí 0', 100, 170);
            ctx.fillText('0 < p ‚â§ 1', w/2, 170);
            ctx.fillText('p = ‚àû', w - 100, 170);
            
            ctx.font = '10px "IBM Plex Mono"';
            ctx.fillText('All condensed', 100, 188);
            ctx.fillText('p-Banach spaces', w/2, 188);
            ctx.fillText('Nonarchimedean', w - 100, 188);
            
            // Position indicator
            const posX = 50 + state.spectrumPos * (w - 100);
            ctx.beginPath();
            ctx.moveTo(posX, 95);
            ctx.lineTo(posX - 12, 70);
            ctx.lineTo(posX + 12, 70);
            ctx.closePath();
            ctx.fillStyle = '#fff';
            ctx.fill();
            
            // Property boxes
            const drawBox = (x, y, title, props, active) => {
                ctx.fillStyle = active ? 'rgba(78, 205, 196, 0.15)' : 'rgba(255,255,255,0.03)';
                ctx.fillRect(x - 85, y, 170, 90);
                ctx.strokeStyle = active ? '#4ecdc4' : '#333';
                ctx.lineWidth = active ? 2 : 1;
                ctx.strokeRect(x - 85, y, 170, 90);
                
                ctx.fillStyle = active ? '#4ecdc4' : '#666';
                ctx.font = 'bold 11px "IBM Plex Mono"';
                ctx.textAlign = 'center';
                ctx.fillText(title, x, y + 20);
                
                ctx.font = '10px "IBM Plex Mono"';
                ctx.fillStyle = active ? '#ccc' : '#555';
                props.forEach((prop, i) => {
                    ctx.fillText(prop, x, y + 40 + i * 16);
                });
            };
            
            const gasActive = state.spectrumPos < 0.3;
            const liqActive = state.spectrumPos >= 0.3 && state.spectrumPos <= 0.7;
            const solActive = state.spectrumPos > 0.7;
            
            drawBox(100, 220, 'Gaseous', ['No completeness', 'All modules', 'No Ext control'], gasActive);
            drawBox(w/2, 220, 'Liquid', ['Abelian category', 'Ext vanishing', 'Closed under ext'], liqActive);
            drawBox(w - 100, 220, 'Solid', ['Over ‚Ñö‚Çö only', 'Fails over ‚Ñù', 'Too rigid'], solActive);
            
            // Update label
            let label = 'Liquid';
            if (state.spectrumPos < 0.3) label = 'Gaseous';
            else if (state.spectrumPos > 0.7) label = 'Solid';
            document.getElementById('spectrum-value').textContent = label;
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SECTION 6: EXT VANISHING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function renderExt() {
            const canvas = document.getElementById('ext-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            
            ctx.clearRect(0, 0, w, h);
            
            // Short exact sequence boxes
            const drawModule = (x, y, label, color) => {
                ctx.fillStyle = color + '80';
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.fillRect(x - 25, y - 18, 50, 36);
                ctx.strokeRect(x - 25, y - 18, 50, 36);
                ctx.fillStyle = '#fff';
                ctx.font = '13px "IBM Plex Mono"';
                ctx.textAlign = 'center';
                ctx.fillText(label, x, y + 5);
            };
            
            const seqY = 80;
            drawModule(80, seqY, '0', '#333');
            drawModule(180, seqY, 'K', '#ff6b6b');
            drawModule(300, seqY, 'E', '#ffd93d');
            drawModule(420, seqY, 'V', '#4ecdc4');
            drawModule(520, seqY, '0', '#333');
            
            // Arrows
            ctx.strokeStyle = '#888';
            ctx.fillStyle = '#888';
            ctx.lineWidth = 2;
            [[105, 155], [205, 275], [325, 395], [445, 495]].forEach(([x1, x2]) => {
                ctx.beginPath();
                ctx.moveTo(x1, seqY);
                ctx.lineTo(x2, seqY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(x2, seqY);
                ctx.lineTo(x2 - 8, seqY - 5);
                ctx.lineTo(x2 - 8, seqY + 5);
                ctx.closePath();
                ctx.fill();
            });
            
            // Title
            ctx.fillStyle = '#fff';
            ctx.font = '12px "IBM Plex Mono"';
            ctx.textAlign = 'center';
            ctx.fillText('Short exact sequence: 0 ‚Üí K ‚Üí E ‚Üí V ‚Üí 0', w/2, 35);
            
            // Extension visualization
            const splitY = 180;
            const twist = Math.sin(state.time * 2) * 25 * (1 - state.extProgress);
            
            // Twisted extension
            ctx.fillStyle = `rgba(255, 107, 107, ${0.3 * (1 - state.extProgress)})`;
            ctx.beginPath();
            ctx.moveTo(120, splitY - 30);
            ctx.bezierCurveTo(200, splitY - 30 - twist, 280, splitY - 30 + twist, 360, splitY - 30);
            ctx.bezierCurveTo(400, splitY - 30 - twist, 440, splitY - 30 + twist, 480, splitY - 30);
            ctx.lineTo(480, splitY + 30);
            ctx.bezierCurveTo(440, splitY + 30 - twist, 400, splitY + 30 + twist, 360, splitY + 30);
            ctx.bezierCurveTo(280, splitY + 30 - twist, 200, splitY + 30 + twist, 120, splitY + 30);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = `rgba(255, 107, 107, ${1 - state.extProgress})`;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Split extension
            if (state.extProgress > 0) {
                ctx.fillStyle = `rgba(78, 205, 196, ${0.3 * state.extProgress})`;
                ctx.fillRect(120, splitY + 60, 360, 70);
                ctx.strokeStyle = `rgba(78, 205, 196, ${state.extProgress})`;
                ctx.lineWidth = 2;
                ctx.strokeRect(120, splitY + 60, 360, 70);
                
                // Direct sum line
                ctx.strokeStyle = `rgba(78, 205, 196, ${state.extProgress})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(120, splitY + 95);
                ctx.lineTo(480, splitY + 95);
                ctx.stroke();
                
                ctx.fillStyle = `rgba(255, 255, 255, ${state.extProgress})`;
                ctx.font = '11px "IBM Plex Mono"';
                ctx.textAlign = 'left';
                ctx.fillText('K', 135, splitY + 82);
                ctx.fillText('V', 135, splitY + 118);
                ctx.textAlign = 'center';
                ctx.fillText('E ‚âÖ K ‚äï V (splits!)', 300, splitY + 98);
            }
            
            // Ext indicator
            const extColor = state.extProgress > 0.5 ? '#4ecdc4' : '#ff6b6b';
            ctx.fillStyle = extColor;
            ctx.font = 'bold 14px "IBM Plex Mono"';
            ctx.textAlign = 'center';
            ctx.fillText(state.extProgress > 0.5 ? 'Ext¬π(V, K) = 0' : 'Ext¬π(V, K) ‚â† 0', w/2, splitY + 160);
            
            ctx.font = '11px "IBM Plex Mono"';
            ctx.fillStyle = '#888';
            ctx.fillText(state.extProgress > 0.5 ? 'All extensions split' : 'Extension can twist', w/2, splitY + 180);
        }
        
        function showExtension(type) {
            const target = type === 'split' ? 1 : 0;
            const start = state.extProgress;
            const duration = 600;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                
                state.extProgress = start + (target - start) * eased;
                document.getElementById('ext-slider').value = state.extProgress;
                document.getElementById('ext-value').textContent = Math.round(state.extProgress * 100) + '%';
                renderExt();
                
                if (progress < 1) requestAnimationFrame(animate);
            }
            animate();
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SECTION 7: OPEN MAPPING THEOREM
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function renderOMT() {
            const canvas = document.getElementById('omt-canvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            
            ctx.clearRect(0, 0, w, h);
            
            if (state.omtProof === 'classical') {
                // Classical Baire category proof
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px "IBM Plex Mono"';
                ctx.textAlign = 'center';
                ctx.fillText('Classical Proof: Baire Category', w/2, 30);
                
                // X as union of closed sets
                const colors = ['#ff6b6b', '#ffd93d', '#4ecdc4', '#a855f7'];
                for (let n = 0; n < 4; n++) {
                    const offset = Math.sin(state.time + n * 0.5) * 8;
                    ctx.fillStyle = colors[n] + '30';
                    ctx.strokeStyle = colors[n];
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(180 + n * 25, 160 + offset, 50 + n * 15, 70, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px "IBM Plex Mono"';
                ctx.fillText('Banach space X', 200, 80);
                ctx.fillText('X = ‚à™‚Çô T(B(0,n))‚Åª', 200, 270);
                ctx.fillStyle = '#888';
                ctx.font = '10px "IBM Plex Mono"';
                ctx.fillText('Baire: some closure has interior', 200, 290);
                
                // Arrow
                ctx.strokeStyle = '#888';
                ctx.fillStyle = '#888';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(320, 160);
                ctx.lineTo(380, 160);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(380, 160);
                ctx.lineTo(370, 155);
                ctx.lineTo(370, 165);
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px "IBM Plex Mono"';
                ctx.fillText('T', 350, 145);
                ctx.fillStyle = '#888';
                ctx.font = '10px "IBM Plex Mono"';
                ctx.fillText('surjective', 350, 180);
                
                // Y
                ctx.fillStyle = '#4ecdc4' + '40';
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(480, 160, 80, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Open ball in Y
                ctx.fillStyle = '#fff' + '20';
                ctx.strokeStyle = '#fff';
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.arc(480, 160, 35, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px "IBM Plex Mono"';
                ctx.fillText('Banach space Y', 480, 80);
                ctx.fillText('Open ball', 480, 165);
                ctx.fillStyle = '#4ecdc4';
                ctx.fillText('T is open!', 480, 290);
                
            } else {
                // Liquid proof
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px "IBM Plex Mono"';
                ctx.textAlign = 'center';
                ctx.fillText('Liquid Proof: Ext Vanishing', w/2, 30);
                
                // Short exact sequence
                const seqY = 100;
                const drawBox = (x, label, color) => {
                    ctx.fillStyle = color + '60';
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.fillRect(x - 28, seqY - 18, 56, 36);
                    ctx.strokeRect(x - 28, seqY - 18, 56, 36);
                    ctx.fillStyle = '#fff';
                    ctx.font = '12px "IBM Plex Mono"';
                    ctx.textAlign = 'center';
                    ctx.fillText(label, x, seqY + 5);
                };
                
                drawBox(80, '0', '#333');
                drawBox(170, 'K', '#ff6b6b');
                drawBox(300, 'V', '#ffd93d');
                drawBox(430, 'W', '#4ecdc4');
                drawBox(520, '0', '#333');
                
                // Arrows
                ctx.strokeStyle = '#888';
                ctx.fillStyle = '#888';
                ctx.lineWidth = 2;
                [[108, 142], [198, 272], [328, 402], [458, 492]].forEach(([x1, x2]) => {
                    ctx.beginPath();
                    ctx.moveTo(x1, seqY);
                    ctx.lineTo(x2, seqY);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x2, seqY);
                    ctx.lineTo(x2 - 8, seqY - 5);
                    ctx.lineTo(x2 - 8, seqY + 5);
                    ctx.closePath();
                    ctx.fill();
                });
                
                // Ext vanishing
                ctx.fillStyle = '#4ecdc4';
                ctx.font = 'bold 14px "IBM Plex Mono"';
                ctx.fillText('Ext¬π(W, K) = 0', 300, 170);
                
                // Splitting arrow
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(430, seqY + 30);
                ctx.quadraticCurveTo(300, seqY + 90, 170, seqY + 30);
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = '#fff';
                ctx.font = '11px "IBM Plex Mono"';
                ctx.fillText('Sequence splits!', 300, seqY + 75);
                
                // Result
                ctx.fillStyle = '#4ecdc4';
                ctx.font = '13px "IBM Plex Mono"';
                ctx.fillText('‚Üí f: V ‚Ü† W is open (categorical argument)', 300, 240);
                
                ctx.fillStyle = '#888';
                ctx.font = '11px "IBM Plex Mono"';
                ctx.fillText('No metric completeness needed', 300, 265);
                ctx.fillText('Hard analysis black-boxed into Ext vanishing', 300, 285);
            }
        }
        
        function setOMTProof(type) {
            state.omtProof = type;
            document.getElementById('btn-classical').classList.toggle('active', type === 'classical');
            document.getElementById('btn-liquid').classList.toggle('active', type === 'liquid');
            renderOMT();
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // SECTION 8: LIQUID TENSOR EXPERIMENT
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function runVerification() {
            if (state.verifying) return;
            state.verifying = true;
            state.verifyProgress = 0;
            
            const btn = document.getElementById('verify-btn');
            btn.disabled = true;
            btn.textContent = 'Verifying...';
            
            function tick() {
                state.verifyProgress += 2;
                document.getElementById('verify-progress').style.width = state.verifyProgress + '%';
                document.getElementById('verify-label').textContent = `Verifying... ${state.verifyProgress}%`;
                
                if (state.verifyProgress < 100) {
                    setTimeout(tick, 40);
                } else {
                    document.getElementById('verify-label').textContent = '‚úì QED - Theorem Verified in Lean';
                    btn.textContent = 'Verified!';
                    state.verifying = false;
                }
            }
            tick();
        }
        
        function toggleDetails() {
            const panel = document.getElementById('details-panel');
            panel.classList.toggle('visible');
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INPUT HANDLERS
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function setupInputs() {
            // Probe slider
            document.getElementById('probe-slider').oninput = function() {
                state.probeCount = parseInt(this.value);
                document.getElementById('probe-value').textContent = state.probeCount;
            };
            
            // P slider
            document.getElementById('p-slider').oninput = function() {
                state.p = parseFloat(this.value);
                document.getElementById('p-value').textContent = state.p.toFixed(2);
                renderPBall();
            };
            
            // Measure P slider
            document.getElementById('measure-p-slider').oninput = function() {
                state.measureP = parseFloat(this.value);
                document.getElementById('measure-p-value').textContent = state.measureP.toFixed(2);
                renderMeasure();
            };
            
            // Spectrum slider
            document.getElementById('spectrum-slider').oninput = function() {
                state.spectrumPos = parseFloat(this.value);
                renderSpectrum();
            };
            
            // Ext slider
            document.getElementById('ext-slider').oninput = function() {
                state.extProgress = parseFloat(this.value);
                document.getElementById('ext-value').textContent = Math.round(state.extProgress * 100) + '%';
                renderExt();
            };
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ANIMATION LOOP
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function animate() {
            state.time += 0.016;
            
            // Only render active section
            switch (state.activeSection) {
                case 1: renderCondensed(); break;
                case 5: renderExt(); break;
                case 6: renderOMT(); break;
            }
            
            requestAnimationFrame(animate);
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // INITIALIZATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function init() {
            initNavigation();
            initMeasurePoints();
            setupInputs();
            setupMeasureDrag();
            
            // Initial renders
            renderBrokenPromise();
            renderCondensed();
            renderPBall();
            renderMeasure();
            renderSpectrum();
            renderExt();
            renderOMT();
            
            // Start animation loop
            animate();
        }
        
        // Run on load
        window.onload = init;
    </script>
</body>
</html>
