<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>The Classifying Space: An Interactive Exploration</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Charter', 'Georgia', serif;
      line-height: 1.7;
      color: #1a1a1a;
      background: #fafafa;
      padding: 0;
      overflow-x: hidden;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 60px 20px;
    }

    h1 {
      font-size: 2.5em;
      font-weight: 600;
      margin-bottom: 0.3em;
      color: #000;
      letter-spacing: -0.02em;
    }

    h2 {
      font-size: 1.8em;
      font-weight: 600;
      margin: 1.5em 0 0.6em;
      color: #000;
      letter-spacing: -0.01em;
    }

    h3 {
      font-size: 1.3em;
      font-weight: 600;
      margin: 1.2em 0 0.5em;
      color: #333;
    }

    p {
      margin-bottom: 1em;
      font-size: 1.05em;
    }

    .subtitle {
      font-size: 1.2em;
      color: #666;
      margin-bottom: 2em;
      font-style: italic;
    }

    .interactive-container {
      background: white;
      border-radius: 8px;
      padding: 30px;
      margin: 2em 0;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }

    .canvas-container {
      width: 100%;
      height: 400px;
      position: relative;
      margin: 20px 0;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      background: #fff;
    }

    canvas {
      display: block;
      cursor: pointer;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-top: 20px;
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    label {
      font-size: 0.95em;
      color: #444;
      min-width: 120px;
      font-weight: 500;
    }

    input[type="range"] {
      flex: 1;
      height: 4px;
      border-radius: 2px;
      background: #ddd;
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #2563eb;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: #1d4ed8;
      transform: scale(1.1);
    }

    .value-display {
      min-width: 40px;
      text-align: right;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      color: #666;
    }

    button {
      padding: 8px 16px;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.95em;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    button:hover {
      background: #1d4ed8;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    button:active {
      transform: translateY(0);
    }

    .highlight {
      background: linear-gradient(120deg, #fef3c7 0%, #fef3c7 100%);
      background-repeat: no-repeat;
      background-size: 100% 40%;
      background-position: 0 85%;
      padding: 2px 4px;
      border-radius: 2px;
    }

    .equation {
      font-family: 'Cambria Math', 'Times New Roman', serif;
      font-style: italic;
      background: #f8f9fa;
      padding: 15px 20px;
      border-radius: 4px;
      margin: 1.5em 0;
      border-left: 3px solid #2563eb;
      font-size: 1.05em;
      text-align: center;
    }

    .caption {
      font-size: 0.9em;
      color: #666;
      text-align: center;
      margin-top: 10px;
      font-style: italic;
    }

    .insight-box {
      background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
      border-left: 4px solid #2563eb;
      padding: 20px 25px;
      margin: 2em 0;
      border-radius: 4px;
    }

    .insight-box h3 {
      margin-top: 0;
      color: #1e40af;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 2em 0;
    }

    @media (max-width: 600px) {
      .grid-2 {
        grid-template-columns: 1fr;
      }
    }

    .perspective-card {
      background: white;
      padding: 20px;
      border-radius: 6px;
      border: 2px solid #e5e7eb;
      transition: all 0.3s ease;
    }

    .perspective-card:hover {
      border-color: #2563eb;
      box-shadow: 0 4px 12px rgba(37, 99, 235, 0.1);
      transform: translateY(-2px);
    }

    .perspective-card h4 {
      color: #2563eb;
      margin-bottom: 0.5em;
      font-size: 1.1em;
    }

    .perspective-card p {
      font-size: 0.95em;
      margin: 0;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Interactive Bundle Visualization
    function BundleVisualization() {
      const canvasRef = useRef(null);
      const [baseAngle, setBaseAngle] = useState(0);
      const [fiberRotation, setFiberRotation] = useState(0);
      const [twist, setTwist] = useState(0);
      const animationRef = useRef(null);

      useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        
        canvas.width = canvas.offsetWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        ctx.scale(dpr, dpr);

        const width = canvas.offsetWidth;
        const height = canvas.offsetHeight;
        const centerX = width / 2;
        const centerY = height / 2;
        const baseRadius = 100;

        function drawScene(angle, fiberRot, twistAmount) {
          ctx.clearRect(0, 0, width, height);

          // Draw base circle (base space X)
          ctx.strokeStyle = '#2563eb';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.arc(centerX, centerY, baseRadius, 0, Math.PI * 2);
          ctx.stroke();

          // Draw multiple fibers around the circle
          const numFibers = 12;
          for (let i = 0; i < numFibers; i++) {
            const t = (i / numFibers + angle) * Math.PI * 2;
            const x = centerX + Math.cos(t) * baseRadius;
            const y = centerY + Math.sin(t) * baseRadius;

            // The fiber rotates based on position (twist) and global rotation
            const localTwist = t * twistAmount;
            const totalRot = fiberRot + localTwist;

            // Draw fiber as a small circle with a line indicating orientation
            const fiberRadius = 15;
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(x, y, fiberRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Orientation line
            ctx.strokeStyle = '#dc2626';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(
              x + Math.cos(totalRot) * fiberRadius,
              y + Math.sin(totalRot) * fiberRadius
            );
            ctx.stroke();
          }

          // Draw labels
          ctx.fillStyle = '#2563eb';
          ctx.font = '14px Charter, Georgia';
          ctx.fillText('Base space X', centerX - 50, centerY + baseRadius + 30);

          ctx.fillStyle = '#dc2626';
          ctx.fillText('Fibers (group G)', centerX + baseRadius + 15, centerY - baseRadius + 20);

          // Draw twist indicator
          ctx.fillStyle = '#666';
          ctx.font = '12px Charter, Georgia';
          ctx.fillText(`Twist: ${twistAmount === 0 ? 'none (trivial bundle)' : twistAmount.toFixed(1) + ' (nontrivial)'}`, 
                       20, height - 20);
        }

        drawScene(baseAngle, fiberRotation, twist);
        
        // Animation loop
        function animate() {
          setBaseAngle(a => a + 0.002);
          animationRef.current = requestAnimationFrame(animate);
        }
        animate();

        return () => {
          if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
          }
        };
      }, [baseAngle, fiberRotation, twist]);

      return (
        <div className="interactive-container">
          <h3>Interactive: Principal Bundle Visualization</h3>
          <p>A principal G-bundle has fibers (copies of group G) sitting over each point of the base space. The twist parameter controls how the fibers rotate as you move around the base.</p>
          
          <div className="canvas-container">
            <canvas 
              ref={canvasRef} 
              style={{width: '100%', height: '100%'}}
            />
          </div>

          <div className="controls">
            <div className="control-row">
              <label>Fiber rotation:</label>
              <input 
                type="range" 
                min="0" 
                max={Math.PI * 2} 
                step="0.1" 
                value={fiberRotation}
                onChange={(e) => setFiberRotation(parseFloat(e.target.value))}
              />
              <span className="value-display">{(fiberRotation * 180 / Math.PI).toFixed(0)}°</span>
            </div>
            <div className="control-row">
              <label>Twist (monodromy):</label>
              <input 
                type="range" 
                min="0" 
                max="3" 
                step="0.1" 
                value={twist}
                onChange={(e) => setTwist(parseFloat(e.target.value))}
              />
              <span className="value-display">{twist.toFixed(1)}</span>
            </div>
          </div>

          <p className="caption">
            Drag the sliders to explore. When twist = 0, the bundle is trivial (X × G). 
            When twist ≠ 0, the bundle has nontrivial topology.
          </p>
        </div>
      );
    }

    // Pullback Diagram Visualization
    function PullbackDiagram() {
      const canvasRef = useRef(null);
      const [xPos, setXPos] = useState(0.5);
      const [showPullback, setShowPullback] = useState(true);

      useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        
        canvas.width = canvas.offsetWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        ctx.scale(dpr, dpr);

        const width = canvas.offsetWidth;
        const height = canvas.offsetHeight;

        function drawArrow(ctx, fromX, fromY, toX, toY, label) {
          ctx.strokeStyle = '#374151';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(fromX, fromY);
          ctx.lineTo(toX, toY);
          ctx.stroke();

          // Arrowhead
          const angle = Math.atan2(toY - fromY, toX - fromX);
          const headLength = 10;
          ctx.beginPath();
          ctx.moveTo(toX, toY);
          ctx.lineTo(
            toX - headLength * Math.cos(angle - Math.PI / 6),
            toY - headLength * Math.sin(angle - Math.PI / 6)
          );
          ctx.moveTo(toX, toY);
          ctx.lineTo(
            toX - headLength * Math.cos(angle + Math.PI / 6),
            toY - headLength * Math.sin(angle + Math.PI / 6)
          );
          ctx.stroke();

          // Label
          if (label) {
            ctx.fillStyle = '#374151';
            ctx.font = '13px Charter, Georgia';
            const midX = (fromX + toX) / 2;
            const midY = (fromY + toY) / 2;
            ctx.fillText(label, midX + 5, midY - 5);
          }
        }

        function drawSpace(ctx, x, y, label, color = '#2563eb') {
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x, y, 30, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = 'white';
          ctx.font = 'bold 14px Charter, Georgia';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(label, x, y);

          ctx.textAlign = 'start';
          ctx.textBaseline = 'alphabetic';
        }

        ctx.clearRect(0, 0, width, height);

        // Layout positions
        const x0 = width * 0.25;
        const x1 = width * 0.75;
        const y0 = height * 0.3;
        const y1 = height * 0.7;

        if (showPullback) {
          // Draw pullback square
          drawSpace(ctx, x0, y0, 'f*EG', '#dc2626');
          drawSpace(ctx, x1, y0, 'EG', '#2563eb');
          drawSpace(ctx, x0, y1, 'X', '#059669');
          drawSpace(ctx, x1, y1, 'BG', '#7c3aed');

          drawArrow(ctx, x0 + 30, y0, x1 - 30, y0, '');
          drawArrow(ctx, x0, y0 + 30, x0, y1 - 30, '');
          drawArrow(ctx, x1, y0 + 30, x1, y1 - 30, 'π');
          drawArrow(ctx, x0 + 30, y1, x1 - 30, y1, 'f');

          // Highlight the pullback corner
          ctx.strokeStyle = '#dc2626';
          ctx.lineWidth = 3;
          ctx.setLineDash([5, 5]);
          ctx.strokeRect(x0 - 40, y0 - 40, 80, 80);
          ctx.setLineDash([]);

          // Interactive point
          const pointX = x0 + (x1 - x0) * xPos;
          const pointY = y1;
          
          ctx.fillStyle = '#dc2626';
          ctx.beginPath();
          ctx.arc(pointX, pointY, 6, 0, Math.PI * 2);
          ctx.fill();

          // Show fiber above
          ctx.strokeStyle = '#dc2626';
          ctx.lineWidth = 2;
          ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.moveTo(pointX, pointY);
          ctx.lineTo(pointX, y0 - 50);
          ctx.stroke();
          ctx.setLineDash([]);

          ctx.fillStyle = '#666';
          ctx.font = '12px Charter, Georgia';
          ctx.fillText('Move point ↓', width / 2 - 40, height - 20);
        }
      }, [xPos, showPullback]);

      return (
        <div className="interactive-container">
          <h3>Interactive: The Pullback Mechanism</h3>
          <p>
            Given a map <em>f</em>: X → BG, the pullback f*EG is constructed by taking pairs (x, e) where f(x) = π(e). 
            This gives you a principal G-bundle over X.
          </p>
          
          <div className="canvas-container">
            <canvas 
              ref={canvasRef} 
              style={{width: '100%', height: '100%'}}
            />
          </div>

          <div className="controls">
            <div className="control-row">
              <label>Point in X:</label>
              <input 
                type="range" 
                min="0" 
                max="1" 
                step="0.01" 
                value={xPos}
                onChange={(e) => setXPos(parseFloat(e.target.value))}
              />
            </div>
            <div className="control-row">
              <button onClick={() => setShowPullback(!showPullback)}>
                {showPullback ? 'Hide' : 'Show'} Pullback Construction
              </button>
            </div>
          </div>

          <p className="caption">
            The pullback f*EG sits in the upper left. It inherits the G-action from EG, making it a principal G-bundle over X.
          </p>
        </div>
      );
    }

    // Stability Visualization
    function StabilityVisualization() {
      const canvasRef = useRef(null);
      const [dimension, setDimension] = useState(3);
      const [time, setTime] = useState(0);
      const animationRef = useRef(null);

      useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        
        canvas.width = canvas.offsetWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        ctx.scale(dpr, dpr);

        const width = canvas.offsetWidth;
        const height = canvas.offsetHeight;

        function drawStabilization(dim, t) {
          ctx.clearRect(0, 0, width, height);

          const maxDim = 20;
          const barWidth = (width - 100) / maxDim;
          const startX = 50;
          const baseY = height - 80;

          // Draw bars representing homotopy groups
          for (let n = 1; n <= maxDim; n++) {
            const x = startX + (n - 1) * barWidth;
            
            // Simulate stabilization: values fluctuate for small n, stabilize for large n
            const stabilizationPoint = Math.max(5, dim);
            let value;
            if (n < stabilizationPoint) {
              value = 50 + Math.sin(n * 1.3 + t) * 30 + Math.cos(n * 0.7) * 20;
            } else {
              // Stable value
              value = 70 + Math.sin(t * 0.5) * 5;
            }

            const barHeight = value * 1.5;
            const isStable = n >= stabilizationPoint;
            
            ctx.fillStyle = isStable ? '#059669' : '#2563eb';
            ctx.fillRect(x, baseY - barHeight, barWidth - 2, barHeight);

            // Highlight current dimension
            if (n === dim) {
              ctx.strokeStyle = '#dc2626';
              ctx.lineWidth = 2;
              ctx.strokeRect(x - 2, baseY - barHeight - 2, barWidth + 2, barHeight + 2);
            }
          }

          // Draw stability line
          const stableX = startX + (Math.max(5, dim) - 1) * barWidth;
          ctx.strokeStyle = '#059669';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(stableX, 50);
          ctx.lineTo(stableX, baseY);
          ctx.stroke();
          ctx.setLineDash([]);

          ctx.fillStyle = '#059669';
          ctx.font = '12px Charter, Georgia';
          ctx.fillText('Stable region →', stableX + 5, 45);

          // Axis labels
          ctx.fillStyle = '#374151';
          ctx.font = '13px Charter, Georgia';
          ctx.fillText('n →', width - 30, baseY + 25);
          ctx.fillText('πₙ(Sⁿ⁺ᵏ)', 15, 50);

          // Legend
          ctx.fillStyle = '#666';
          ctx.font = '11px Charter, Georgia';
          ctx.fillText('Blue: Unstable | Green: Stabilized', startX, height - 20);
        }

        drawStabilization(dimension, time);

        // Animation
        function animate() {
          setTime(t => t + 0.03);
          animationRef.current = requestAnimationFrame(animate);
        }
        animate();

        return () => {
          if (animationRef.current) {
            cancelAnimationFrame(animationRef.current);
          }
        };
      }, [dimension, time]);

      return (
        <div className="interactive-container">
          <h3>Interactive: The Freudenthal Suspension Theorem</h3>
          <p>
            As we increase the dimension of the sphere, the homotopy groups eventually stabilize. 
            This visualization shows how π<sub>n</sub>(S<sup>n+k</sup>) changes with n—chaotic at first, then settling into stable values.
          </p>
          
          <div className="canvas-container">
            <canvas 
              ref={canvasRef} 
              style={{width: '100%', height: '100%'}}
            />
          </div>

          <div className="controls">
            <div className="control-row">
              <label>Reference dimension k:</label>
              <input 
                type="range" 
                min="1" 
                max="10" 
                step="1" 
                value={dimension}
                onChange={(e) => setDimension(parseInt(e.target.value))}
              />
              <span className="value-display">{dimension}</span>
            </div>
          </div>

          <p className="caption">
            Green bars indicate stabilized homotopy groups. As k increases, stabilization happens earlier.
            This is the essence of stable homotopy theory.
          </p>
        </div>
      );
    }

    // Gamma Spaces Visualization
    function GammaSpaceVisualization() {
      const canvasRef = useRef(null);
      const [nPlus, setNPlus] = useState(2);

      useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        
        canvas.width = canvas.offsetWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        ctx.scale(dpr, dpr);

        const width = canvas.offsetWidth;
        const height = canvas.offsetHeight;

        function drawPointedSet(ctx, x, y, n, label) {
          const radius = 8;
          const spacing = 20;
          
          // Draw basepoint (0) in center
          ctx.fillStyle = '#9ca3af';
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = 'white';
          ctx.font = 'bold 11px Charter, Georgia';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('0', x, y);

          // Draw other points in a circle around it
          for (let i = 1; i <= n; i++) {
            const angle = (i - 1) * (2 * Math.PI / n) - Math.PI / 2;
            const px = x + Math.cos(angle) * spacing * 1.5;
            const py = y + Math.sin(angle) * spacing * 1.5;

            ctx.fillStyle = '#2563eb';
            ctx.beginPath();
            ctx.arc(px, py, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.fillText(i.toString(), px, py);
          }

          // Label
          ctx.fillStyle = '#374151';
          ctx.font = '13px Charter, Georgia';
          ctx.textAlign = 'center';
          ctx.fillText(label, x, y + spacing * 2.5);
          ctx.textAlign = 'start';
          ctx.textBaseline = 'alphabetic';
        }

        function drawSpace(ctx, x, y, label, color) {
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x, y, 35, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.fillStyle = 'white';
          ctx.font = 'bold 14px Charter, Georgia';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(label, x, y);

          ctx.textAlign = 'start';
          ctx.textBaseline = 'alphabetic';
        }

        ctx.clearRect(0, 0, width, height);

        const leftX = width * 0.25;
        const rightX = width * 0.75;
        const topY = height * 0.25;
        const bottomY = height * 0.75;

        // Draw Γ^op category
        drawPointedSet(ctx, leftX, topY, nPlus, `${nPlus}₊`);
        
        // Draw functor arrow
        ctx.strokeStyle = '#374151';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(leftX + 50, topY);
        ctx.lineTo(rightX - 50, topY);
        ctx.stroke();

        // Arrow label
        ctx.fillStyle = '#374151';
        ctx.font = '14px Charter, Georgia';
        ctx.fillText('F', (leftX + rightX) / 2 - 5, topY - 10);

        // Draw target space F(n₊)
        drawSpace(ctx, rightX, topY, `F(${nPlus}₊)`, '#dc2626');

        // Show specialness condition
        if (nPlus > 1) {
          drawSpace(ctx, rightX - 60, bottomY, 'F(1₊)', '#059669');
          drawSpace(ctx, rightX + 60, bottomY, 'F(1₊)', '#059669');
          
          if (nPlus === 2) {
            ctx.fillStyle = '#666';
            ctx.font = '12px Charter, Georgia';
            ctx.textAlign = 'center';
            ctx.fillText('×', rightX, bottomY);
          } else {
            ctx.fillStyle = '#666';
            ctx.font = '12px Charter, Georgia';
            ctx.textAlign = 'center';
            ctx.fillText(`× ... ×  (${nPlus} times)`, rightX, bottomY);
          }

          // Equivalence arrow
          ctx.strokeStyle = '#7c3aed';
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(rightX, topY + 45);
          ctx.lineTo(rightX, bottomY - 50);
          ctx.stroke();
          ctx.setLineDash([]);

          ctx.fillStyle = '#7c3aed';
          ctx.font = '13px Charter, Georgia';
          ctx.textAlign = 'center';
          ctx.fillText('≃', rightX + 15, (topY + bottomY) / 2);
          ctx.textAlign = 'start';
        }

        // Explanation text
        ctx.fillStyle = '#666';
        ctx.font = '12px Charter, Georgia';
        ctx.fillText('Γ-space = contravariant functor from finite pointed sets', 20, height - 20);
      }, [nPlus]);

      return (
        <div className="interactive-container">
          <h3>Interactive: Γ-Spaces and Specialness</h3>
          <p>
            A Γ-space is a functor F: Γ<sup>op</sup> → Spaces. The "specialness" condition says 
            F(n₊) ≃ F(1₊) × F(1₊) × ... × F(1₊) (n times).
          </p>
          
          <div className="canvas-container">
            <canvas 
              ref={canvasRef} 
              style={{width: '100%', height: '100%'}}
            />
          </div>

          <div className="controls">
            <div className="control-row">
              <label>Choose n₊:</label>
              <input 
                type="range" 
                min="1" 
                max="5" 
                step="1" 
                value={nPlus}
                onChange={(e) => setNPlus(parseInt(e.target.value))}
              />
              <span className="value-display">{nPlus}</span>
            </div>
          </div>

          <p className="caption">
            The specialness condition makes F(1₊) into an E<sub>∞</sub>-space—a space with coherently commutative multiplication.
            This is the key to infinite loop space theory.
          </p>
        </div>
      );
    }

    // Main App Component
    function App() {
      return (
        <div className="container">
          <h1>The Classifying Space</h1>
          <p className="subtitle">
            An interactive exploration of universal bundles, stability, and the machines of modern topology
          </p>

          <p>
            In topology, we constantly face <span className="highlight">classification problems</span>: 
            How many fiber bundles exist over a given space? How do we organize cohomology theories? 
            What invariants distinguish geometric structures?
          </p>

          <p>
            The profound insight of mid-20th century mathematics was this: <strong>classification problems 
            can be transformed into homotopy problems</strong> by constructing universal objects—classifying spaces.
          </p>

          <h2>Part I: The Universal Bundle</h2>

          <p>
            A <em>principal G-bundle</em> over a space X consists of a total space E with a free G-action 
            and a projection π: E → X whose fibers are copies of G. The classification theorem states:
          </p>

          <div className="equation">
            {"{principal G-bundles over X}"} ≅ [X, BG]
          </div>

          <p>
            where [X, BG] denotes homotopy classes of continuous maps from X to the <em>classifying space</em> BG.
          </p>

          <BundleVisualization />

          <div className="insight-box">
            <h3>Key Insight: Universality</h3>
            <p>
              BG is not just any space—it's the quotient of a contractible space EG by the free G-action. 
              The bundle EG → BG is <em>universal</em>: every other principal G-bundle is obtained by pulling 
              it back along a map to BG.
            </p>
          </div>

          <h2>Part II: The Pullback Mechanism</h2>

          <p>
            How does a map f: X → BG give you a bundle? Through the <em>pullback construction</em>. 
            You form the fiber product of f and the projection π: EG → BG:
          </p>

          <PullbackDiagram />

          <p>
            The pullback f*EG = {"{(x, e) ∈ X × EG : f(x) = π(e)}"} inherits the G-action from EG 
            and projects to X. This is your bundle. Remarkably, <strong>every principal G-bundle arises 
            this way</strong>, and homotopic maps give isomorphic bundles.
          </p>

          <h2>Part III: The Stable Phenomenon</h2>

          <p>
            A single classifying space BG classifies bundles with a fixed structure group. But many 
            topological invariants are <em>stable</em>—they don't depend on dimension in the limit. 
            This is where <span className="highlight">stability</span> becomes essential.
          </p>

          <StabilityVisualization />

          <p>
            The Freudenthal suspension theorem tells us that homotopy groups of spheres stabilize: 
            for n large enough (relative to k), the map π<sub>k</sub>(S<sup>n</sup>) → 
            π<sub>k+1</sub>(S<sup>n+1</sup>) is an isomorphism. The limit is the <em>stable homotopy 
            group</em> π<sub>k</sub><sup>st</sup>.
          </p>

          <div className="insight-box">
            <h3>Why Stability Matters</h3>
            <p>
              Stable phenomena require <em>spectra</em>—sequences of spaces connected by suspension maps—not 
              single classifying spaces. A spectrum represents a generalized cohomology theory via the 
              Brown representability theorem. This is where Γ-spaces enter the story.
            </p>
          </div>

          <h2>Part IV: Γ-Spaces and Infinite Loop Spaces</h2>

          <p>
            How do we systematically construct spectra? Graeme Segal's brilliant insight was to package 
            the coherence of infinite loop spaces using a simple combinatorial category: <strong>Γ</strong>, 
            the category of finite pointed sets.
          </p>

          <GammaSpaceVisualization />

          <p>
            A <em>Γ-space</em> is a contravariant functor F: Γ<sup>op</sup> → Spaces. The key condition 
            is <em>specialness</em>: F(n₊) should be equivalent to n copies of F(1₊), making F(1₊) 
            into an E<sub>∞</sub>-space (a space with coherently commutative multiplication).
          </p>

          <div className="equation">
            F(n₊) ≃ F(1₊)<sup>n</sup>
          </div>

          <p>
            When F is <em>very special</em> (group-like), F(1₊) is an infinite loop space, and you can 
            construct a spectrum from it through repeated delooping.
          </p>

          <h2>Part V: Five Perspectives on Classification</h2>

          <div className="grid-2">
            <div className="perspective-card">
              <h4>The Builder (Milnor)</h4>
              <p>
                "Construct EG explicitly—via infinite joins or bar constructions. Show me the coordinates. 
                Every bundle pulls back from this universal one."
              </p>
            </div>

            <div className="perspective-card">
              <h4>The Organizer (Segal)</h4>
              <p>
                "Define objects by universal properties. Functors package coherence automatically. 
                Γ-spaces make E<sub>∞</sub>-structure inevitable."
              </p>
            </div>

            <div className="perspective-card">
              <h4>The Measurer (Mirzakhani)</h4>
              <p>
                "Compute volumes, count geodesics. The Weil-Petersson volume of M<sub>g</sub> stabilizes 
                in genus—geometry and topology agree."
              </p>
            </div>

            <div className="perspective-card">
              <h4>The Algebraist (Noether)</h4>
              <p>
                "Cohomology is a derived functor. Characteristic classes live in H*(BG). 
                Algebra makes topology computable."
              </p>
            </div>
          </div>

          <div className="perspective-card" style={{marginTop: '20px'}}>
            <h4>The Categorist (Grothendieck)</h4>
            <p>
              "Classification is representability in the correct category. Objects are less important 
              than the category they form. The universal property is the essence; let the water rise 
              until the solution is visible."
            </p>
          </div>

          <div className="insight-box" style={{marginTop: '3em'}}>
            <h3>The Unifying Principle</h3>
            <p>
              Whether we're classifying principal bundles via BG, organizing spectra via Γ-spaces, 
              or measuring moduli spaces M<sub>g</sub>, the pattern is the same:
            </p>
            <ul style={{marginTop: '1em', paddingLeft: '1.5em'}}>
              <li><strong>Find the universal object</strong> that encodes all instances</li>
              <li><strong>Study its properties</strong> (cohomology, homotopy, measure)</li>
              <li><strong>Let classification flow</strong> from representability</li>
              <li><strong>Take limits</strong> to reveal stable structure</li>
              <li><strong>Use functors</strong> to make coherence automatic</li>
            </ul>
          </div>

          <h2>Epilogue: The Meta-Pattern</h2>

          <p>
            Mathematics advances by recognizing patterns across different domains. The classifying space 
            BG transforms bundle theory. Γ-spaces transform stable homotopy theory. Moduli spaces M<sub>g</sub> 
            transform geometric classification. Grothendieck's topoi transform sheaf theory.
          </p>

          <p>
            At every level, the method is the same: <strong>replace ad-hoc classification by universal 
            properties and functorial machines</strong>. This is how modern mathematics thinks.
          </p>

          <div className="equation" style={{background: 'linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%)', borderLeft: '4px solid #2563eb'}}>
            classification = representability + universality + stability
          </div>

          <p style={{marginTop: '3em', fontStyle: 'italic', color: '#666', textAlign: 'center'}}>
            Interactive essay by Bartosz Ciechanowski<br/>
            Inspired by conversations on classifying spaces, Γ-spaces, and the unity of mathematics
          </p>
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>