<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Constructive Mathematics Explorable: Sheaves & Bisection</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:rgba(255,255,255,0.06);
    --panel2:rgba(255,255,255,0.09);
    --stroke:rgba(255,255,255,0.12);
    --text:rgba(255,255,255,0.92);
    --muted:rgba(255,255,255,0.68);
    --muted2:rgba(255,255,255,0.50);
    --shadow: 0 18px 60px rgba(0,0,0,0.45);
    --r: 18px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    color:var(--text);
    background:
      radial-gradient(1200px 900px at 20% 10%, rgba(110,231,255,0.16), transparent 60%),
      radial-gradient(900px 900px at 80% 40%, rgba(167,139,250,0.14), transparent 60%),
      radial-gradient(900px 900px at 50% 90%, rgba(34,197,94,0.10), transparent 55%),
      linear-gradient(180deg, #070a14, var(--bg));
    overflow:hidden;
  }
  header{
    height:68px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding: 0 18px;
    border-bottom: 1px solid var(--stroke);
    background: rgba(0,0,0,0.15);
    backdrop-filter: blur(10px);
  }
  .brand{display:flex; gap:12px; align-items:center;}
  .badge{
    width:34px;height:34px;border-radius:10px;
    background: linear-gradient(135deg, rgba(110,231,255,0.9), rgba(167,139,250,0.9));
    box-shadow: var(--shadow);
  }
  .title{display:flex;flex-direction:column;line-height:1.1}
  .title b{font-size:14px; letter-spacing:0.2px}
  .title span{font-size:12px;color:var(--muted)}
  .tabs{display:flex;gap:10px;align-items:center}
  .tab{
    border:1px solid var(--stroke);
    background: rgba(255,255,255,0.04);
    color: var(--muted);
    padding: 10px 12px;
    border-radius: 999px;
    cursor:pointer;
    user-select:none;
    transition: transform 120ms ease, background 120ms ease, color 120ms ease;
  }
  .tab:hover{transform: translateY(-1px); background: rgba(255,255,255,0.07); color: rgba(255,255,255,0.86)}
  .tab.active{
    color: rgba(0,0,0,0.82);
    background: linear-gradient(135deg, rgba(110,231,255,0.95), rgba(167,139,250,0.95));
    border-color: rgba(255,255,255,0.12);
  }

  main{
    height: calc(100% - 68px);
    display:grid;
    grid-template-columns: 1.25fr 0.75fr;
    gap: 14px;
    padding: 14px;
  }

  .canvasWrap{
    position:relative;
    border-radius: var(--r);
    overflow:hidden;
    border:1px solid var(--stroke);
    background: rgba(255,255,255,0.03);
    box-shadow: var(--shadow);
  }
  canvas{width:100%;height:100%;display:block}

  .panel{
    border-radius: var(--r);
    border:1px solid var(--stroke);
    background: rgba(255,255,255,0.04);
    box-shadow: var(--shadow);
    overflow:hidden;
    display:flex;
    flex-direction:column;
  }
  .panelHead{
    padding: 14px 14px 10px 14px;
    border-bottom:1px solid var(--stroke);
    background: rgba(0,0,0,0.16);
  }
  .panelHead b{font-size:13px}
  .panelHead span{display:block;margin-top:4px;font-size:12px;color:var(--muted)}
  .panelBody{padding: 12px 14px; overflow:auto}

  .row{display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; margin: 10px 0}
  .row label{font-size:12px;color:var(--muted)}
  .row .val{font-variant-numeric: tabular-nums; font-size:12px; color: rgba(255,255,255,0.88)}
  input[type=range]{width:100%}

  .toggles{display:flex; flex-wrap:wrap; gap:8px; margin-top:8px}
  .chip{
    padding: 8px 10px;
    border-radius: 999px;
    border:1px solid var(--stroke);
    background: rgba(255,255,255,0.04);
    color: var(--muted);
    cursor:pointer;
    user-select:none;
    font-size:12px;
    transition: transform 120ms ease, background 120ms ease;
  }
  .chip:hover{transform: translateY(-1px); background: rgba(255,255,255,0.07)}
  .chip.on{background: rgba(255,255,255,0.10); color: rgba(255,255,255,0.90)}

  .kpi{
    margin-top: 10px;
    padding: 12px;
    border-radius: 14px;
    border:1px solid var(--stroke);
    background: rgba(255,255,255,0.04);
  }
  .kpi .big{font-size:22px; font-weight:700; letter-spacing:0.2px}
  .kpi .small{font-size:12px; color: var(--muted)}

  .btnRow{display:flex; gap:10px; flex-wrap:wrap; margin-top: 10px}
  button{
    border:none;
    padding: 10px 12px;
    border-radius: 12px;
    background: rgba(255,255,255,0.08);
    color: rgba(255,255,255,0.90);
    cursor:pointer;
    border: 1px solid var(--stroke);
    transition: transform 120ms ease, background 120ms ease;
  }
  button:hover{transform: translateY(-1px); background: rgba(255,255,255,0.12)}
  button.primary{
    color: rgba(0,0,0,0.82);
    background: linear-gradient(135deg, rgba(34,197,94,0.85), rgba(110,231,255,0.85));
  }
  button.primary:hover{background: linear-gradient(135deg, rgba(34,197,94,0.95), rgba(110,231,255,0.95));}

  .hint{
    margin-top: 10px;
    font-size:12px;
    color: var(--muted2);
    line-height: 1.35;
  }
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
</style>
</head>
<body>
<header>
  <div class="brand">
    <div class="badge"></div>
    <div class="title">
      <b>Constructive Mathematics Explorable</b>
      <span>Sheaf truth values • Realizability intuition • IVT bisection with ε-uncertainty</span>
    </div>
  </div>
  <div class="tabs">
    <div id="tabSheaf" class="tab active">Sheaf Logic</div>
    <div id="tabBisection" class="tab">Bisection IVT</div>
  </div>
</header>

<main>
  <div class="canvasWrap"><canvas id="c"></canvas></div>

  <section class="panel">
    <div class="panelHead">
      <b id="panelTitle">Sheaf Logic: truth values are open sets</b>
      <span id="panelSub">Drag the threshold line on the plot. Watch why A ∪ ¬A can miss the boundary.</span>
    </div>
    <div class="panelBody" id="controls"></div>
  </section>
</main>

<script>
(() => {
  // -----------------------------
  // Utilities
  // -----------------------------
  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
  const lerp = (a,b,t)=>a+(b-a)*t;
  const invLerp = (a,b,x)=> (x-a)/(b-a);

  function nice(n, d=3){
    const p = Math.pow(10,d);
    return (Math.round(n*p)/p).toFixed(d);
  }

  // Open set representation: array of [l,r] with l<r, normalized/merged.
  function normalizeIntervals(iv){
    const a = iv
      .map(([l,r])=>[Math.max(0,Math.min(1,l)), Math.max(0,Math.min(1,r))])
      .filter(([l,r])=>r-l>1e-6)
      .sort((x,y)=>x[0]-y[0]);
    const out=[];
    for(const seg of a){
      if(!out.length){ out.push(seg); continue; }
      const last=out[out.length-1];
      if(seg[0] <= last[1] + 1e-5){
        last[1] = Math.max(last[1], seg[1]);
      } else out.push(seg);
    }
    return out;
  }

  function intervalMeasure(iv){
    let s=0; for(const [l,r] of iv) s += (r-l); return s;
  }

  function intervalUnion(a,b){
    return normalizeIntervals([...a, ...b]);
  }

  function intervalIntersect(a,b){
    const out=[];
    let i=0,j=0;
    while(i<a.length && j<b.length){
      const [al,ar]=a[i], [bl,br]=b[j];
      const l=Math.max(al,bl), r=Math.min(ar,br);
      if(r-l>1e-6) out.push([l,r]);
      if(ar<br) i++; else j++;
    }
    return out;
  }

  // Complement in [0,1]
  function intervalComplement(a){
    const iv = normalizeIntervals(a);
    const out=[];
    let x=0;
    for(const [l,r] of iv){
      if(l-x>1e-6) out.push([x,l]);
      x=r;
    }
    if(1-x>1e-6) out.push([x,1]);
    return out;
  }

  // Intuitionistic negation for opens on a line: interior(complement(A)).
  // Here we approximate "interior" by trimming a tiny boundary epsilon.
  function interior(iv, eps){
    const out=[];
    for(const [l,r] of iv){
      const nl=l+eps, nr=r-eps;
      if(nr-nl>1e-6) out.push([nl,nr]);
    }
    return normalizeIntervals(out);
  }

  function implication(A,B, eps){
    // A ⇒ B = int( (¬A) ∪ B ) where ¬A = int(comp(A))
    const notA = interior(intervalComplement(A), eps);
    return interior(intervalUnion(notA, B), eps);
  }

  // -----------------------------
  // Canvas / layout
  // -----------------------------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // -----------------------------
  // State
  // -----------------------------
  const Mode = { Sheaf: 'sheaf', Bisection: 'bisection' };
  let mode = Mode.Sheaf;

  const sheaf = {
    freq: 2.0,
    bump: 0.55,
    threshold: 0.00,
    boundaryEps: 0.012,
    showA: true,
    showNotA: true,
    showUnion: true,
    showImp: false,
    impTarget: 'B', // placeholder, we use B = (f > threshold + delta)
    delta: 0.18,
    draggingThresh: false,
    mouse: {x:0,y:0,down:false},
  };

  const bisect = {
    eps: 0.06,
    steps: 0,
    maxSteps: 18,
    auto: false,
    tAuto: 0,
    funcKind: 0, // 0 cubic-ish, 1 wiggly
    intervals: [[0,1]],
    // enforce g(0)<0<g(1) by adjusting offset each eval
    a: 0,
    b: 1,
    mouse: {x:0,y:0,down:false},
  };

  // -----------------------------
  // Functions
  // -----------------------------
  function fSheaf(x){
    // Smooth function with a bump; meant to create boundaries where f(x)=threshold.
    const w = 2*Math.PI*sheaf.freq;
    const s = Math.sin(w*x);
    const bump = sheaf.bump * Math.exp(-Math.pow((x-0.62)/0.09,2));
    const ripple = 0.12*Math.sin(2*w*x + 0.7);
    return 0.55*s + bump + ripple;
  }

  function openSetFromPredicate(fn, pred, N=600){
    // Build intervals where pred(fn(x)) is true using sampling + linear crossing.
    const iv=[];
    let prevX=0, prevV=fn(0), prevT=pred(prevV);
    let start = prevT ? 0 : null;
    for(let i=1;i<=N;i++){
      const x=i/N;
      const v=fn(x);
      const t=pred(v);
      if(t !== prevT){
        // crossing between prevX and x; approximate root where v==threshold-like boundary.
        const dx=x-prevX;
        const a=prevV, b=v;
        let alpha = 0.5;
        if(Math.abs(b-a)>1e-9){
          // Solve a + alpha(b-a) == 0 in the special case pred is (v>0); we generalize by bisecting.
          // We'll do a tiny local bisection on the predicate boundary.
          let lo=0, hi=1;
          for(let k=0;k<14;k++){
            const mid=(lo+hi)/2;
            const vm = lerp(a,b,mid);
            const tm = pred(vm);
            if(tm===prevT) lo=mid; else hi=mid;
          }
          alpha=(lo+hi)/2;
        }
        const xc=prevX + alpha*dx;
        if(prevT){
          // was true, now false
          iv.push([start, xc]);
          start=null;
        } else {
          // was false, now true
          start=xc;
        }
      }
      prevX=x; prevV=v; prevT=t;
    }
    if(prevT && start!==null) iv.push([start,1]);
    return normalizeIntervals(iv);
  }

  function gBase(x){
    if(bisect.funcKind===0){
      // cubic-ish with an inflection
      const t = x-0.5;
      return 1.4*t*t*t - 0.45*t + 0.05*Math.sin(10*x);
    } else {
      // wiggly but still continuous
      return 0.55*Math.sin(2*Math.PI*2.2*x) + 0.20*Math.sin(2*Math.PI*7.1*x + 0.3) + 0.10*(x-0.5);
    }
  }

  function g(x){
    // Affine normalize so g(0)<0<g(1).
    const g0 = gBase(0);
    const g1 = gBase(1);
    // shift so endpoints straddle 0 (make g0 negative, g1 positive)
    const mid = (g0+g1)/2;
    const shifted = gBase(x) - mid;
    // scale to keep in view
    return shifted;
  }

  // -----------------------------
  // UI construction
  // -----------------------------
  const controls = document.getElementById('controls');
  const panelTitle = document.getElementById('panelTitle');
  const panelSub = document.getElementById('panelSub');

  function setTab(active){
    const tabSheaf = document.getElementById('tabSheaf');
    const tabBisection = document.getElementById('tabBisection');
    if(active===Mode.Sheaf){
      tabSheaf.classList.add('active');
      tabBisection.classList.remove('active');
      mode = Mode.Sheaf;
      panelTitle.textContent = 'Sheaf Logic: truth values are open sets';
      panelSub.textContent = 'Drag the threshold line on the plot. Watch why A ∪ ¬A can miss the boundary.';
      buildControls();
    } else {
      tabBisection.classList.add('active');
      tabSheaf.classList.remove('active');
      mode = Mode.Bisection;
      panelTitle.textContent = 'Bisection IVT: ε-uncertainty forces branching';
      panelSub.textContent = 'When |f(m)| ≤ ε you cannot decide the sign, so the algorithm must keep both halves.';
      buildControls();
    }
  }
  document.getElementById('tabSheaf').addEventListener('click', ()=>setTab(Mode.Sheaf));
  document.getElementById('tabBisection').addEventListener('click', ()=>setTab(Mode.Bisection));

  function sliderRow({label, min, max, step, get, set, fmt}){
    const wrap=document.createElement('div');
    wrap.className='row';

    const left=document.createElement('div');
    const lab=document.createElement('label');
    lab.textContent=label;
    const input=document.createElement('input');
    input.type='range';
    input.min=min; input.max=max; input.step=step;
    input.value=get();
    input.addEventListener('input', ()=>{ set(parseFloat(input.value)); val.textContent = fmt(get()); });
    left.appendChild(lab);
    left.appendChild(input);

    const val=document.createElement('div');
    val.className='val mono';
    val.textContent = fmt(get());

    wrap.appendChild(left);
    wrap.appendChild(val);
    return wrap;
  }

  function chip(label, get, set){
    const el=document.createElement('div');
    el.className='chip'+(get()?' on':'');
    el.textContent=label;
    el.addEventListener('click', ()=>{ set(!get()); el.className='chip'+(get()?' on':''); });
    return el;
  }

  function kpi(big, small){
    const el=document.createElement('div');
    el.className='kpi';
    const b=document.createElement('div'); b.className='big'; b.textContent=big;
    const s=document.createElement('div'); s.className='small'; s.textContent=small;
    el.appendChild(b); el.appendChild(s);
    return el;
  }

  function buildControls(){
    controls.innerHTML='';

    if(mode===Mode.Sheaf){
      controls.appendChild(sliderRow({
        label:'Frequency', min:0.6, max:4.0, step:0.01,
        get:()=>sheaf.freq, set:v=>sheaf.freq=v,
        fmt:v=>nice(v,2)
      }));
      controls.appendChild(sliderRow({
        label:'Bump', min:0.0, max:1.0, step:0.01,
        get:()=>sheaf.bump, set:v=>sheaf.bump=v,
        fmt:v=>nice(v,2)
      }));
      controls.appendChild(sliderRow({
        label:'Threshold', min:-1.0, max:1.0, step:0.001,
        get:()=>sheaf.threshold, set:v=>sheaf.threshold=v,
        fmt:v=>nice(v,3)
      }));
      controls.appendChild(sliderRow({
        label:'Boundary ε (interior trim)', min:0.0, max:0.05, step:0.0005,
        get:()=>sheaf.boundaryEps, set:v=>sheaf.boundaryEps=v,
        fmt:v=>nice(v,4)
      }));
      controls.appendChild(sliderRow({
        label:'B = (f > threshold + δ)', min:0.0, max:0.5, step:0.001,
        get:()=>sheaf.delta, set:v=>sheaf.delta=v,
        fmt:v=>nice(v,3)
      }));

      const tgs=document.createElement('div');
      tgs.className='toggles';
      tgs.appendChild(chip('Show A', ()=>sheaf.showA, v=>sheaf.showA=v));
      tgs.appendChild(chip('Show ¬A', ()=>sheaf.showNotA, v=>sheaf.showNotA=v));
      tgs.appendChild(chip('Show A ∪ ¬A', ()=>sheaf.showUnion, v=>sheaf.showUnion=v));
      tgs.appendChild(chip('Show A ⇒ B', ()=>sheaf.showImp, v=>sheaf.showImp=v));
      controls.appendChild(tgs);

      const {lemPct, gapPct} = sheafKPIs();
      controls.appendChild(kpi(`${lemPct}%`, 'Approx. coverage of A ∪ ¬A within [0,1] (LEM would be 100%)'));
      controls.appendChild(kpi(`${gapPct}%`, 'Boundary gap area: where neither A nor ¬A holds (undecided region)'));

      const hint=document.createElement('div');
      hint.className='hint';
      hint.innerHTML =
        `<div><b>Interpretation</b></div>
         <div>
           Here, a proposition is an <span class="mono">open set</span> on the line. Negation is <span class="mono">interior(complement)</span>.
           When A has a boundary, that boundary is neither in A nor in ¬A, so <span class="mono">A ∪ ¬A</span> can miss it.
         </div>
         <div style="margin-top:8px">
           <span class="mono">A ⇒ B = int( (¬A) ∪ B )</span> shows implication as “locally, either A is refutable or B holds.”
         </div>`;
      controls.appendChild(hint);

    } else {
      controls.appendChild(sliderRow({
        label:'ε undecidable zone', min:0.0, max:0.25, step:0.001,
        get:()=>bisect.eps, set:v=>bisect.eps=v,
        fmt:v=>nice(v,3)
      }));
      controls.appendChild(sliderRow({
        label:'Max steps', min:6, max:28, step:1,
        get:()=>bisect.maxSteps, set:v=>bisect.maxSteps=v,
        fmt:v=>String(Math.round(v))
      }));

      const tgs=document.createElement('div');
      tgs.className='toggles';
      tgs.appendChild(chip('Wiggly function', ()=>bisect.funcKind===1, v=>{bisect.funcKind = v?1:0; resetBisection();}));
      tgs.appendChild(chip('Auto-run', ()=>bisect.auto, v=>bisect.auto=v));
      controls.appendChild(tgs);

      const btns=document.createElement('div');
      btns.className='btnRow';
      const stepBtn=document.createElement('button');
      stepBtn.className='primary';
      stepBtn.textContent='Step';
      stepBtn.addEventListener('click', ()=>doBisectionStep());
      const resetBtn=document.createElement('button');
      resetBtn.textContent='Reset';
      resetBtn.addEventListener('click', ()=>resetBisection());
      btns.appendChild(stepBtn);
      btns.appendChild(resetBtn);
      controls.appendChild(btns);

      const w = bisectWidth();
      controls.appendChild(kpi(`${bisect.steps}`, 'Steps executed'));
      controls.appendChild(kpi(`${nice(w,4)}`, 'Total remaining interval width (sum of branches)'));

      const hint=document.createElement('div');
      hint.className='hint';
      hint.innerHTML =
        `<div><b>Interpretation</b></div>
         <div>
           Classical bisection chooses a half by deciding the sign of <span class="mono">f(m)</span>. If you only know <span class="mono">|f(m)|</span> is small,
           you may be unable to decide. The constructive response is to keep <span class="mono">both halves</span>.
         </div>
         <div style="margin-top:8px">
           Slide ε upward to force more branching; slide it to 0 to recover the classical path.
         </div>`;
      controls.appendChild(hint);
    }
  }

  function sheafKPIs(){
    const A = openSetFromPredicate(x=>fSheaf(x), v=>v>sheaf.threshold);
    const notA = interior(intervalComplement(A), sheaf.boundaryEps);
    const u = intervalUnion(A, notA);
    const cov = intervalMeasure(u);
    const gap = 1 - cov;
    const lemPct = Math.round(1000*cov)/10;
    const gapPct = Math.round(1000*gap)/10;
    return {lemPct, gapPct};
  }

  function resetBisection(){
    bisect.steps = 0;
    bisect.intervals = [[0,1]];
  }

  function bisectWidth(){
    let s=0; for(const [l,r] of bisect.intervals) s += (r-l); return s;
  }

  function doBisectionStep(){
    if(bisect.steps >= bisect.maxSteps) return;
    const eps = bisect.eps;
    const next=[];

    for(const [l,r] of bisect.intervals){
      const m = 0.5*(l+r);
      const fm = g(m);
      if(fm > eps){
        // root is in left half because g(l) < 0 and g(r) > 0; but with normalization, we still branch based on fm.
        next.push([l,m]);
      } else if(fm < -eps){
        next.push([m,r]);
      } else {
        // undecidable: keep both halves
        next.push([l,m]);
        next.push([m,r]);
      }
    }

    bisect.intervals = normalizeIntervals(next);
    bisect.steps++;
  }

  // -----------------------------
  // Pointer interaction
  // -----------------------------
  function getMouse(e){
    const rect = canvas.getBoundingClientRect();
    return {x: e.clientX - rect.left, y: e.clientY - rect.top};
  }

  canvas.addEventListener('pointerdown', (e)=>{
    canvas.setPointerCapture(e.pointerId);
    const m = getMouse(e);
    if(mode===Mode.Sheaf){
      sheaf.mouse = {...m, down:true};
      // if near threshold line in plot region, start drag
      const hit = hitThresholdLine(m.x, m.y);
      sheaf.draggingThresh = hit;
      if(hit){
        updateThresholdFromMouse(m.y);
        buildControls();
      }
    } else {
      bisect.mouse = {...m, down:true};
    }
  });

  canvas.addEventListener('pointermove', (e)=>{
    const m = getMouse(e);
    if(mode===Mode.Sheaf){
      sheaf.mouse = {...m, down:sheaf.mouse.down};
      if(sheaf.draggingThresh){
        updateThresholdFromMouse(m.y);
        buildControls();
      }
    } else {
      bisect.mouse = {...m, down:bisect.mouse.down};
    }
  });

  canvas.addEventListener('pointerup', (e)=>{
    if(mode===Mode.Sheaf){
      sheaf.mouse.down=false;
      sheaf.draggingThresh=false;
    } else {
      bisect.mouse.down=false;
    }
  });

  // -----------------------------
  // Drawing helpers
  // -----------------------------
  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function text(x,y,s, size=12, alpha=0.85){
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = `${size}px ui-sans-serif, system-ui`;
    ctx.fillText(s, x, y);
    ctx.restore();
  }

  // -----------------------------
  // Sheaf plotting layout
  // -----------------------------
  function sheafLayout(){
    const rect = canvas.getBoundingClientRect();
    const W = rect.width, H = rect.height;
    const pad = 26;
    const top = 18;
    const plotH = Math.min(260, H*0.46);
    const plot = {x: pad, y: top+10, w: W-2*pad, h: plotH};
    const bar = {x: pad, y: plot.y+plot.h+24, w: W-2*pad, h: 50};
    const caption = {x: pad, y: bar.y+bar.h+22, w: W-2*pad, h: H-(bar.y+bar.h+22)-pad};
    return {W,H,plot,bar,caption,pad};
  }

  function worldToPlot(x, y, plot, yMin, yMax){
    const px = plot.x + x*plot.w;
    const py = plot.y + (1 - invLerp(yMin,yMax,y))*plot.h;
    return {x:px,y:py};
  }

  function updateThresholdFromMouse(mouseY){
    const {plot} = sheafLayout();
    const yMin=-1.25, yMax=1.25;
    const t = clamp((mouseY - plot.y)/plot.h, 0, 1);
    const y = lerp(yMax, yMin, t);
    sheaf.threshold = clamp(y, -1.0, 1.0);
  }

  function hitThresholdLine(mx,my){
    const {plot} = sheafLayout();
    if(mx<plot.x || mx>plot.x+plot.w || my<plot.y || my>plot.y+plot.h) return false;
    const yMin=-1.25, yMax=1.25;
    const py = worldToPlot(0, sheaf.threshold, plot, yMin, yMax).y;
    return Math.abs(my - py) < 10;
  }

  // -----------------------------
  // Render
  // -----------------------------
  let last = performance.now();
  function frame(t){
    const dt = Math.min(0.05, (t-last)/1000);
    last=t;

    if(mode===Mode.Bisection && bisect.auto){
      bisect.tAuto += dt;
      if(bisect.tAuto > 0.35){
        bisect.tAuto = 0;
        doBisectionStep();
        buildControls();
      }
    }

    draw();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  function clear(){
    const rect = canvas.getBoundingClientRect();
    ctx.clearRect(0,0,rect.width, rect.height);
  }

  function draw(){
    clear();
    if(mode===Mode.Sheaf) drawSheaf();
    else drawBisection();
  }

  function drawSheaf(){
    const {W,H,plot,bar,caption} = sheafLayout();

    // subtle panel
    ctx.save();
    roundRect(14, 14, W-28, H-28, 18);
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fill();
    ctx.restore();

    // plot axes
    ctx.save();
    roundRect(plot.x-10, plot.y-10, plot.w+20, plot.h+20, 16);
    ctx.fillStyle='rgba(255,255,255,0.03)';
    ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.09)';
    ctx.stroke();
    ctx.restore();

    const yMin=-1.25, yMax=1.25;

    // grid
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,0.06)';
    ctx.lineWidth=1;
    for(let i=0;i<=6;i++){
      const yy = lerp(plot.y, plot.y+plot.h, i/6);
      ctx.beginPath(); ctx.moveTo(plot.x, yy); ctx.lineTo(plot.x+plot.w, yy); ctx.stroke();
    }
    for(let i=0;i<=10;i++){
      const xx = lerp(plot.x, plot.x+plot.w, i/10);
      ctx.beginPath(); ctx.moveTo(xx, plot.y); ctx.lineTo(xx, plot.y+plot.h); ctx.stroke();
    }
    ctx.restore();

    // function
    ctx.save();
    ctx.beginPath();
    const N=900;
    for(let i=0;i<=N;i++){
      const x=i/N;
      const y=fSheaf(x);
      const p=worldToPlot(x,y,plot,yMin,yMax);
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.lineWidth=2;
    ctx.strokeStyle='rgba(110,231,255,0.85)';
    ctx.stroke();
    ctx.restore();

    // threshold line
    const py = worldToPlot(0, sheaf.threshold, plot, yMin, yMax).y;
    ctx.save();
    ctx.beginPath(); ctx.moveTo(plot.x, py); ctx.lineTo(plot.x+plot.w, py);
    ctx.strokeStyle = sheaf.draggingThresh ? 'rgba(34,197,94,0.95)' : 'rgba(255,255,255,0.65)';
    ctx.setLineDash([6,6]);
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle='rgba(255,255,255,0.85)';
    text(plot.x+8, py-10, `threshold = ${nice(sheaf.threshold,3)}`, 12, 0.85);
    ctx.restore();

    // Open set A and friends
    const A = openSetFromPredicate(x=>fSheaf(x), v=>v>sheaf.threshold);
    const notA = interior(intervalComplement(A), sheaf.boundaryEps);
    const U = intervalUnion(A, notA);
    const B = openSetFromPredicate(x=>fSheaf(x), v=>v>(sheaf.threshold+sheaf.delta));
    const Imp = implication(A,B, sheaf.boundaryEps);

    // bar frame
    ctx.save();
    roundRect(bar.x-10, bar.y-10, bar.w+20, bar.h+20, 16);
    ctx.fillStyle='rgba(255,255,255,0.03)';
    ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.09)';
    ctx.stroke();
    ctx.restore();

    // draw base bar
    ctx.save();
    roundRect(bar.x, bar.y, bar.w, bar.h, 12);
    ctx.fillStyle='rgba(0,0,0,0.22)';
    ctx.fill();
    ctx.restore();

    function drawIntervals(iv, fill){
      ctx.save();
      ctx.fillStyle = fill;
      for(const [l,r] of iv){
        const x=bar.x + l*bar.w;
        const w=(r-l)*bar.w;
        roundRect(x, bar.y, w, bar.h, 12);
        ctx.fill();
      }
      ctx.restore();
    }

    if(sheaf.showUnion) drawIntervals(U, 'rgba(167,139,250,0.26)');
    if(sheaf.showA) drawIntervals(A, 'rgba(110,231,255,0.28)');
    if(sheaf.showNotA) drawIntervals(notA, 'rgba(34,197,94,0.22)');
    if(sheaf.showImp) drawIntervals(Imp, 'rgba(255,255,255,0.14)');

    // LEM gap highlight = complement(U)
    const gap = intervalComplement(U);
    drawIntervals(gap, 'rgba(255,255,255,0.05)');

    // bar labels
    ctx.save();
    ctx.fillStyle='rgba(255,255,255,0.85)';
    text(bar.x, bar.y-12, 'Truth values as opens on [0,1]', 12, 0.80);
    text(bar.x, bar.y+bar.h+18, 'A = {x | f(x) > threshold}', 12, 0.78);
    text(bar.x, bar.y+bar.h+36, '¬A = interior(complement(A))', 12, 0.60);
    text(bar.x, bar.y+bar.h+54, 'A ∪ ¬A may miss the boundary → LEM gap', 12, 0.60);
    ctx.restore();

    // caption
    ctx.save();
    ctx.fillStyle='rgba(255,255,255,0.82)';
    text(caption.x, caption.y, 'Direct manipulation:', 12, 0.85);
    ctx.fillStyle='rgba(255,255,255,0.60)';
    text(caption.x, caption.y+18, '• Drag the threshold line (dashed) up/down.', 12, 0.62);
    text(caption.x, caption.y+36, '• Increase Boundary ε to “thicken” undecidability (interior trim).', 12, 0.62);
    text(caption.x, caption.y+54, '• Toggle A, ¬A, union, and implication A ⇒ B.', 12, 0.62);
    ctx.restore();
  }

  function drawBisection(){
    const rect = canvas.getBoundingClientRect();
    const W=rect.width, H=rect.height;
    const pad=26;

    // panels
    ctx.save();
    roundRect(14, 14, W-28, H-28, 18);
    ctx.fillStyle='rgba(255,255,255,0.02)';
    ctx.fill();
    ctx.restore();

    const plotH = Math.min(300, H*0.46);
    const plot = {x: pad, y: 28, w: W-2*pad, h: plotH};
    const stack = {x: pad, y: plot.y+plot.h+28, w: W-2*pad, h: H-(plot.y+plot.h+28)-pad};

    // plot frame
    ctx.save();
    roundRect(plot.x-10, plot.y-10, plot.w+20, plot.h+20, 16);
    ctx.fillStyle='rgba(255,255,255,0.03)';
    ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.09)';
    ctx.stroke();
    ctx.restore();

    const yMin=-1.2, yMax=1.2;

    // grid
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,0.06)';
    for(let i=0;i<=6;i++){
      const yy = lerp(plot.y, plot.y+plot.h, i/6);
      ctx.beginPath(); ctx.moveTo(plot.x,yy); ctx.lineTo(plot.x+plot.w,yy); ctx.stroke();
    }
    for(let i=0;i<=10;i++){
      const xx = lerp(plot.x, plot.x+plot.w, i/10);
      ctx.beginPath(); ctx.moveTo(xx,plot.y); ctx.lineTo(xx,plot.y+plot.h); ctx.stroke();
    }
    ctx.restore();

    function toPlot(x,y){
      return {
        x: plot.x + x*plot.w,
        y: plot.y + (1-invLerp(yMin,yMax,y))*plot.h
      };
    }

    // function
    ctx.save();
    ctx.beginPath();
    const N=900;
    for(let i=0;i<=N;i++){
      const x=i/N;
      const y=g(x);
      const p=toPlot(x,y);
      if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);
    }
    ctx.lineWidth=2;
    ctx.strokeStyle='rgba(110,231,255,0.85)';
    ctx.stroke();
    ctx.restore();

    // epsilon band
    const py0 = toPlot(0, bisect.eps).y;
    const py1 = toPlot(0, -bisect.eps).y;
    ctx.save();
    ctx.fillStyle='rgba(255,255,255,0.06)';
    ctx.fillRect(plot.x, py0, plot.w, py1-py0);
    ctx.strokeStyle='rgba(255,255,255,0.14)';
    ctx.setLineDash([6,6]);
    ctx.beginPath(); ctx.moveTo(plot.x, py0); ctx.lineTo(plot.x+plot.w, py0);
    ctx.moveTo(plot.x, py1); ctx.lineTo(plot.x+plot.w, py1);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle='rgba(255,255,255,0.70)';
    text(plot.x+8, py0-8, `+ε = ${nice(bisect.eps,3)}`, 12, 0.75);
    text(plot.x+8, py1+14, `-ε`, 12, 0.55);
    ctx.restore();

    // stack frame
    ctx.save();
    roundRect(stack.x-10, stack.y-10, stack.w+20, stack.h+20, 16);
    ctx.fillStyle='rgba(255,255,255,0.03)';
    ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.09)';
    ctx.stroke();
    ctx.restore();

    // intervals visualization
    const rows = Math.max(1, Math.min(10, bisect.intervals.length));
    const h = Math.min(34, (stack.h-24) / Math.max(1, rows));
    const top = stack.y + 18;

    ctx.save();
    ctx.fillStyle='rgba(255,255,255,0.80)';
    text(stack.x, stack.y+2, 'Remaining candidate intervals (branches)', 12, 0.80);
    ctx.restore();

    for(let i=0;i<bisect.intervals.length;i++){
      const [l,r] = bisect.intervals[i];
      const y = top + i*h;
      const x = stack.x + l*stack.w;
      const w = (r-l)*stack.w;

      ctx.save();
      roundRect(stack.x, y, stack.w, h-6, 12);
      ctx.fillStyle='rgba(0,0,0,0.18)';
      ctx.fill();

      roundRect(x, y, w, h-6, 12);
      ctx.fillStyle = (w < 0.04) ? 'rgba(34,197,94,0.24)' : 'rgba(167,139,250,0.22)';
      ctx.fill();

      ctx.fillStyle='rgba(255,255,255,0.70)';
      ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
      ctx.fillText(`[${nice(l,4)}, ${nice(r,4)}]  width=${nice(r-l,4)}`, stack.x+10, y+16);
      ctx.restore();
    }

    // overlay midpoints of first few intervals on plot
    ctx.save();
    const show = Math.min(6, bisect.intervals.length);
    for(let i=0;i<show;i++){
      const [l,r]=bisect.intervals[i];
      const m=0.5*(l+r);
      const fm=g(m);
      const p=toPlot(m,fm);
      ctx.beginPath();
      ctx.arc(p.x,p.y,4.2,0,Math.PI*2);
      const undec = Math.abs(fm) <= bisect.eps;
      ctx.fillStyle = undec ? 'rgba(255,255,255,0.75)' : (fm>0 ? 'rgba(34,197,94,0.85)' : 'rgba(167,139,250,0.85)');
      ctx.fill();
    }
    ctx.restore();

    // caption
    ctx.save();
    ctx.fillStyle='rgba(255,255,255,0.60)';
    text(plot.x, plot.y+plot.h+14, 'Markers show midpoints m; white = undecidable (|f(m)| ≤ ε) → branch.', 12, 0.62);
    ctx.restore();
  }

  // -----------------------------
  // Boot
  // -----------------------------
  resetBisection();
  buildControls();
})();
</script>
</body>
</html>