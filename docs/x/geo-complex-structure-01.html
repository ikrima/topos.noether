<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Essential Structure of Complex Numbers</title>
    <style>
        /* Design Tokens - Clean, Academic, Paper-like aesthetics. */
        :root {
            --bg-color: #fdfbf7;
            --text-color: #333;
            --accent-color: #d9480f; /* Orange-red for interactions */
            --link-color: #0077cc;
            --grid-color: #e0e0e0;
            --axis-color: #333;
            --secondary-text: #666;
            --font-serif: "Merriweather", "Georgia", serif;
            --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            
            /* Logic Colors */
            --col-add: #2b8a3e; /* Green for Addition */
            --col-mult: #1098ad; /* Cyan/Blue for Multiplication */
            --col-root: #862e9c; /* Purple for Roots */
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-serif);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Layout */
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem 1rem;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 700;
        }

        .subtitle {
            font-family: var(--font-sans);
            color: var(--secondary-text);
            font-size: 1.1rem;
        }

        a { color: var(--link-color); text-decoration: none; }
        a:hover { text-decoration: underline; }

        /* The Interactive Canvas Wrapper */
        .canvas-container {
            position: relative;
            width: 100%;
            height: 550px;
            margin: 2rem 0;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            overflow: hidden;
            border: 1px solid rgba(0,0,0,0.05);
            cursor: grab;
            user-select: none;
        }

        .canvas-container:active {
            cursor: grabbing;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Overlay UI Controls */
        .controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
            font-family: var(--font-sans);
            flex-wrap: wrap;
        }

        button {
            background: white;
            border: 1px solid #ccc;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        button.active {
            background: var(--text-color);
            color: white;
            border-color: var(--text-color);
            transform: translateY(1px);
        }

        button:hover:not(.active) {
            background: #f0f0f0;
        }

        /* Sub-controls for specific modes */
        .sub-controls {
            margin-top: 1rem;
            display: flex;
            justify-content: center;
            gap: 1rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            height: 0;
            overflow: hidden;
        }
        .sub-controls.visible {
            opacity: 1;
            pointer-events: auto;
            height: auto;
            padding-bottom: 1rem;
        }

        .action-btn {
            background: var(--bg-color);
            border: 1px solid var(--accent-color);
            color: var(--accent-color);
            font-weight: 600;
        }
        .action-btn:hover {
            background: var(--accent-color);
            color: white;
        }

        /* Explanatory Text Panels */
        .explanation {
            margin-top: 2rem;
            padding: 1.5rem;
            background: rgba(255,255,255,0.5);
            border-left: 4px solid var(--accent-color);
            transition: opacity 0.3s ease;
        }

        .math {
            font-family: "Courier New", monospace;
            background: #eee;
            padding: 0.1rem 0.3rem;
            border-radius: 3px;
            font-size: 0.95em;
        }
        
        /* Legends for the Web */
        .legend-item {
            display: inline-block;
            margin-right: 15px;
            font-size: 0.85rem;
            font-family: var(--font-sans);
        }
        .dot {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }

        /* Responsive Text */
        @media (max-width: 600px) {
            h1 { font-size: 2rem; }
            .canvas-container { height: 400px; }
            .controls { flex-direction: column; align-items: center; }
        }

    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>Complex Structure</h1>
        <div class="subtitle">An interactive exploration of <a href="https://www.infinitelymore.xyz/p/complex-numbers-essential-structure" target="_blank">Joel David Hamkins' ideas</a>.</div>
    </header>

    <p>
        What are the complex numbers? Physics gives us a grid. Geometry gives us a plane. But logic gives us something stranger.
        Use the controls to shift your perspective from the rigid to the purely algebraic.
    </p>

    <!-- The Stage -->
    <div class="canvas-container" id="canvas-wrapper">
        <canvas id="main-canvas"></canvas>
    </div>

    <!-- Navigation -->
    <div class="controls">
        <button id="btn-grid" class="active">1. The Rigid Grid</button>
        <button id="btn-mirror">2. The Mirror</button>
        <button id="btn-web">3. The Algebraic Web</button>
    </div>

    <!-- Mode Specific Actions -->
    <div id="controls-web" class="sub-controls">
        <button class="action-btn" id="btn-toggle-roots">Swap Roots (Noether)</button>
        <div style="font-size:0.9rem; align-self:center; color:#666;">Drag <strong>α</strong> to deform the field</div>
    </div>

    <!-- Dynamic Explanation Text -->
    <div id="text-grid" class="explanation">
        <h3>1. The Rigid Coordinate Plane</h3>
        <p>
            The engineer's view: $\mathbb{C}$ is a <strong>fixed stage</strong>. 
            Points have absolute addresses $(x, y)$. 
        </p>
        <p>
            <strong>Interact:</strong> Drag the orange point $z$. It is locked to the Cartesian grid. 
            $i$ is strictly "Up". This structure is rigid; no points can move without breaking the coordinates.
        </p>
        <p class="math">Structure: ⟨ ℂ, +, ·, 0, 1, Re, Im ⟩</p>
    </div>

    <div id="text-mirror" class="explanation" style="display:none;">
        <h3>2. The Symmetric Field</h3>
        <p>
            We erase the vertical axis. We lose "Up/Down" orientation. 
            What remains is the <strong>Real line</strong> and reflection symmetry.
        </p>
        <p>
            <strong>Interact:</strong> Drag $z$ across the axis. The field is symmetric: mathematically, $i$ and $-i$ play identical roles. 
            You can flip the plane (Conjugation), and all algebraic truths remain invariant.
        </p>
        <p class="math">Structure: ⟨ ℂ, +, ·, 0, 1, ℝ ⟩</p>
    </div>

    <div id="text-web" class="explanation" style="display:none;">
        <h3>3. Grothendieck's Web & Noether's Symmetry</h3>
        <p>
            We erase the Real line. We enter the realm of pure algebra. 
            Points are no longer defined by *where* they are, but by *how they relate* to 0 and 1.
        </p>
        <p>
            <strong>The Grothendieck Lens:</strong> Drag the generator point $\alpha$. Notice that $\alpha+1$ and $\alpha^2$ move with it. 
            The "shape" of the constellation distorts wildly, but the <strong>algebraic relations</strong> (green and blue lines) never break.
        </p>
        <p>
            <strong>The Noether Lens:</strong> Click <em>"Swap Roots"</em>. This is the Galois Automorphism. 
            It swaps $i$ and $-i$ (the roots of $x^2+1$). Since the field has no orientation, both configurations are effectively the same object.
        </p>
        <p class="math">Structure: ⟨ ℂ, +, ·, 0, 1 ⟩</p>
        <div style="margin-top:10px;">
            <span class="legend-item"><span class="dot" style="background:var(--col-add)"></span>Sum (a+b)</span>
            <span class="legend-item"><span class="dot" style="background:var(--col-mult)"></span>Product (a·b)</span>
        </div>
    </div>

</div>

<script>
/**
 * interactive-complex-v2.js
 * Visualizing Complex Numbers: Grid, Symmetry, and Algebraic Structure.
 */

// --- Configuration ---
const COLORS = {
    bg: '#fdfbf7',
    grid: '#e0e0e0',
    axis: '#333',
    primary: '#333',
    accent: '#d9480f',
    ghost: 'rgba(217, 72, 15, 0.3)',
    text: '#444',
    add: '#2b8a3e',  // Green
    mult: '#1098ad', // Cyan
    root: '#862e9c'  // Purple
};

// --- State Management ---
const STATE = {
    mode: 'GRID', // 'GRID', 'MIRROR', 'WEB'
    time: 0,
    width: 0,
    height: 0,
    scale: 60, // pixels per unit
    centerX: 0,
    centerY: 0,
    
    // Mode 1 & 2: Simple Z
    z: { x: 2, y: 1.5 },
    
    // Mode 2: Flip state
    flipProgress: 0, 
    isFlipped: false,

    // Mode 3: Algebraic Web State
    // We treat 'alpha' as a free variable (transcendental-ish)
    alpha: { x: 1.2, y: 0.8 }, 
    
    // Roots of x^2 + 1. In 'Web' mode, these can swap.
    // We store current visual phase for i. 
    // targetPhase is PI/2 or -PI/2.
    rootPhase: Math.PI / 2, 
    targetRootPhase: Math.PI / 2,

    isDragging: false,
    dragTarget: null // 'z' or 'alpha'
};

// --- Setup Canvas ---
const canvas = document.getElementById('main-canvas');
const ctx = canvas.getContext('2d');
const wrapper = document.getElementById('canvas-wrapper');

function resize() {
    const rect = wrapper.getBoundingClientRect();
    canvas.width = rect.width * window.devicePixelRatio;
    canvas.height = rect.height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    STATE.width = rect.width;
    STATE.height = rect.height;
    STATE.centerX = STATE.width / 2;
    STATE.centerY = STATE.height / 2;
}
window.addEventListener('resize', resize);
resize();

// --- Math Helpers ---
function complexAdd(a, b) { return { x: a.x + b.x, y: a.y + b.y }; }
function complexMult(a, b) { return { x: a.x*b.x - a.y*b.y, y: a.x*b.y + a.y*b.x }; }

// --- Input Handling ---
function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
    const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
    return {
        x: (clientX - rect.left - STATE.centerX) / STATE.scale,
        y: -(clientY - rect.top - STATE.centerY) / STATE.scale
    };
}

canvas.addEventListener('mousedown', startDrag);
canvas.addEventListener('touchstart', startDrag);
window.addEventListener('mousemove', drag);
window.addEventListener('touchmove', drag);
window.addEventListener('mouseup', endDrag);
window.addEventListener('touchend', endDrag);

function startDrag(e) {
    e.preventDefault();
    const m = getMousePos(e);
    
    // Determine drag targets based on mode
    let targets = [];
    if (STATE.mode === 'WEB') {
        targets.push({ name: 'alpha', pos: STATE.alpha });
    } else {
        targets.push({ name: 'z', pos: STATE.z });
    }

    // Check distance
    for (let t of targets) {
        let dx = m.x - t.pos.x;
        let dy = m.y - t.pos.y;
        if (dx*dx + dy*dy < 0.3) { // hit radius
            STATE.isDragging = true;
            STATE.dragTarget = t.name;
            canvas.style.cursor = 'grabbing';
            return;
        }
    }
    
    // Interaction for Mirror Mode (Click to flip)
    if (STATE.mode === 'MIRROR') {
        STATE.isFlipped = !STATE.isFlipped;
    }
}

function drag(e) {
    if (!STATE.isDragging) return;
    const m = getMousePos(e);
    
    if (STATE.dragTarget === 'z') {
        STATE.z.x = m.x;
        STATE.z.y = m.y;
    } else if (STATE.dragTarget === 'alpha') {
        STATE.alpha.x = m.x;
        STATE.alpha.y = m.y;
    }
}

function endDrag() {
    STATE.isDragging = false;
    STATE.dragTarget = null;
    canvas.style.cursor = 'grab';
}

// --- Mode 3 Logic: Swap Roots ---
document.getElementById('btn-toggle-roots').addEventListener('click', () => {
    // Toggle between PI/2 (i) and -PI/2 (-i)
    if (STATE.targetRootPhase > 0) STATE.targetRootPhase = -Math.PI/2;
    else STATE.targetRootPhase = Math.PI/2;
});

// --- Drawing Primitives ---

function toScreen(x, y) {
    return {
        x: STATE.centerX + x * STATE.scale,
        y: STATE.centerY - y * STATE.scale
    };
}

function drawLine(x1, y1, x2, y2, color, width=1, dash=[]) {
    const p1 = toScreen(x1, y1);
    const p2 = toScreen(x2, y2);
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = width;
    ctx.setLineDash(dash);
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
    ctx.setLineDash([]);
}

function drawCircle(x, y, r, color, fill=false) {
    const p = toScreen(x, y);
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, Math.PI*2);
    if (fill) {
        ctx.fillStyle = color;
        ctx.fill();
    } else {
        ctx.strokeStyle = color;
        ctx.stroke();
    }
}

function drawLabel(text, x, y, color='#333', offset={x:10, y:-10}, font="14px Merriweather") {
    const p = toScreen(x, y);
    ctx.fillStyle = color;
    ctx.font = font;
    ctx.fillText(text, p.x + offset.x, p.y + offset.y);
}

// --- Rendering Modes ---

function renderGridMode() {
    // Standard Grid
    ctx.globalAlpha = 1;
    for (let i = -10; i <= 10; i++) {
        drawLine(i, -10, i, 10, COLORS.grid);
        drawLine(-10, i, 10, i, COLORS.grid);
    }
    // Axes
    drawLine(-10, 0, 10, 0, COLORS.axis, 2);
    drawLine(0, -10, 0, 10, COLORS.axis, 2);
    drawLabel("Re", 4.5, 0.2);
    drawLabel("Im", 0.2, 3.5);

    // Point Z
    drawCircle(STATE.z.x, STATE.z.y, 6, COLORS.accent, true);
    drawLabel("z", STATE.z.x, STATE.z.y, COLORS.accent);
    
    // Projections
    ctx.setLineDash([4, 4]);
    drawLine(STATE.z.x, STATE.z.y, STATE.z.x, 0, '#999');
    drawLine(STATE.z.x, STATE.z.y, 0, STATE.z.y, '#999');
    ctx.setLineDash([]);

    // Anchor i
    drawCircle(0, 1, 3, COLORS.text, true);
    drawLabel("i", 0, 1);
    drawCircle(1, 0, 3, COLORS.text, true);
    drawLabel("1", 1, 0);
}

function renderMirrorMode() {
    // Animation logic
    const target = STATE.isFlipped ? 1 : 0;
    STATE.flipProgress += (target - STATE.flipProgress) * 0.1;

    // Horizontal Lines only
    for (let i = -10; i <= 10; i++) drawLine(-10, i, 10, i, COLORS.grid);
    // Real Axis
    drawLine(-10, 0, 10, 0, COLORS.axis, 2);
    drawLabel("ℝ", 4.5, 0.2);

    // Visual Z calculation
    // Lerp between y and -y
    const yVal = STATE.z.y * (1 - 2 * STATE.flipProgress);
    const yConj = STATE.z.y * (1 - 2 * (1 - STATE.flipProgress));

    // Draw Ghost (Conjugate)
    drawCircle(STATE.z.x, yConj, 4, '#ccc', true);
    drawLine(STATE.z.x, yVal, STATE.z.x, yConj, '#eee', 1, [2,2]);

    // Draw Z
    drawCircle(STATE.z.x, yVal, 6, COLORS.accent, true);
    drawLabel("z", STATE.z.x, yVal, COLORS.accent);

    // Anchor 1
    drawCircle(1, 0, 3, COLORS.text, true);
    drawLabel("1", 1, 0);
}

function renderWebMode() {
    // Animate Root Phase (Noether Swap)
    STATE.rootPhase += (STATE.targetRootPhase - STATE.rootPhase) * 0.1;

    // We do NOT draw the grid or axes.
    // Anchors: 0, 1
    drawCircle(0, 0, 3, COLORS.axis, true);
    drawLabel("0", 0, 0, COLORS.secondary, {x:-15, y:0});
    drawCircle(1, 0, 3, COLORS.axis, true);
    drawLabel("1", 1, 0, COLORS.secondary);

    // Generator Alpha
    const A = STATE.alpha;
    drawCircle(A.x, A.y, 6, COLORS.accent, true);
    drawLabel("α", A.x, A.y, COLORS.accent);

    // --- Algebraic Constructions ---

    // 1. Addition Web: 0 -> 1 and alpha -> alpha + 1
    const A_plus_1 = complexAdd(A, {x:1, y:0});
    
    // Visualizing the Parallelogram of Addition
    ctx.globalAlpha = 0.6;
    drawLine(0, 0, 1, 0, COLORS.add, 1);
    drawLine(0, 0, A.x, A.y, COLORS.add, 1);
    drawLine(1, 0, A_plus_1.x, A_plus_1.y, COLORS.add, 1); // 1 -> A+1
    drawLine(A.x, A.y, A_plus_1.x, A_plus_1.y, COLORS.add, 1); // A -> A+1
    ctx.globalAlpha = 1;

    drawCircle(A_plus_1.x, A_plus_1.y, 4, COLORS.add, true);
    drawLabel("α+1", A_plus_1.x, A_plus_1.y, COLORS.add);

    // 2. Multiplication Web: 1, alpha, alpha^2
    const A_sq = complexMult(A, A);
    
    // Visualizing Similar Triangles (0,1,A) ~ (0,A,A^2)
    ctx.globalAlpha = 0.4;
    drawLine(0, 0, A_sq.x, A_sq.y, COLORS.mult, 1);
    drawLine(A.x, A.y, A_sq.x, A_sq.y, COLORS.mult, 1, [2,2]);
    ctx.globalAlpha = 1;

    drawCircle(A_sq.x, A_sq.y, 4, COLORS.mult, true);
    drawLabel("α²", A_sq.x, A_sq.y, COLORS.mult);

    // 3. The Roots of Unity (Noether's domain)
    // We visualize i and -i based on rootPhase.
    // In this mode, we show that i is defined by relation to 0, not by "up".
    // We can show the square relationship: i^2 = -1
    
    const rootX = 0; // In standard embedding
    const rootY = 1; // magnitude
    // Rotate standard (0,1) by (rootPhase - PI/2) effectively
    // But easier: Just use sin/cos of rootPhase
    const i_node = { x: Math.cos(STATE.rootPhase), y: Math.sin(STATE.rootPhase) };
    const neg_i_node = { x: -i_node.x, y: -i_node.y };
    const neg_one = { x: -1, y: 0 };

    // Draw relationships for i
    ctx.globalAlpha = 0.3;
    // Show that i^2 = -1
    // Triangle (0, 1, i) should be similar to (0, i, -1)
    drawLine(0,0, i_node.x, i_node.y, COLORS.root);
    drawLine(0,0, neg_one.x, neg_one.y, COLORS.root);
    ctx.globalAlpha = 1;

    drawCircle(i_node.x, i_node.y, 5, COLORS.root, true);
    drawLabel("j", i_node.x, i_node.y, COLORS.root); // Using 'j' to denote generic root
    
    drawCircle(neg_i_node.x, neg_i_node.y, 4, COLORS.root, false); // Ghost of other root
    drawLabel("-j", neg_i_node.x, neg_i_node.y, COLORS.root);

    drawCircle(-1, 0, 3, COLORS.text, true);
    
    // Draw connection alpha + j
    // This emphasizes that mixing transcendentals and algebraic roots works
    // regardless of which root we picked.
    const alpha_plus_i = complexAdd(A, i_node);
    drawLine(A.x, A.y, alpha_plus_i.x, alpha_plus_i.y, COLORS.root, 1, [2,4]);
    drawCircle(alpha_plus_i.x, alpha_plus_i.y, 3, COLORS.root, true);
}

// --- Main Loop ---

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    if (STATE.mode === 'GRID') renderGridMode();
    else if (STATE.mode === 'MIRROR') renderMirrorMode();
    else if (STATE.mode === 'WEB') renderWebMode();

    requestAnimationFrame(render);
}

// --- UI Binding ---
const btns = {
    grid: document.getElementById('btn-grid'),
    mirror: document.getElementById('btn-mirror'),
    web: document.getElementById('btn-web')
};
const panels = {
    grid: document.getElementById('text-grid'),
    mirror: document.getElementById('text-mirror'),
    web: document.getElementById('text-web')
};
const webControls = document.getElementById('controls-web');

function setMode(m) {
    STATE.mode = m;
    
    // Buttons
    Object.values(btns).forEach(b => b.classList.remove('active'));
    if (m === 'GRID') btns.grid.classList.add('active');
    if (m === 'MIRROR') btns.mirror.classList.add('active');
    if (m === 'WEB') btns.web.classList.add('active');

    // Text Panels
    Object.values(panels).forEach(p => p.style.display = 'none');
    if (m === 'GRID') panels.grid.style.display = 'block';
    if (m === 'MIRROR') panels.mirror.style.display = 'block';
    if (m === 'WEB') panels.web.style.display = 'block';

    // Sub controls
    if (m === 'WEB') webControls.classList.add('visible');
    else webControls.classList.remove('visible');

    // Reset physics bits
    if (m !== 'MIRROR') {
        STATE.isFlipped = false;
        STATE.flipProgress = 0;
    }
}

btns.grid.addEventListener('click', () => setMode('GRID'));
btns.mirror.addEventListener('click', () => setMode('MIRROR'));
btns.web.addEventListener('click', () => setMode('WEB'));

// Init
render();

</script>
</body>
</html>