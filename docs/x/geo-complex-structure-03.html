<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Geometry of Algebra: A Grand Unification</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-color: #212529;
            --accent-color: #4c6ef5;
            --secondary-color: #868e96;
            --grid-color: #dee2e6;
            --axis-color: #343a40;
            --font-serif: "Merriweather", "Georgia", serif;
            --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            
            /* Semantic Colors */
            --col-elliptic: #2f9e44; /* Green */
            --col-parabolic: #fcc419; /* Yellow/Orange */
            --col-hyperbolic: #f03e3e; /* Red */
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-serif);
            line-height: 1.7;
        }

        .container {
            max-width: 840px;
            margin: 0 auto;
            padding: 3rem 1.5rem;
        }

        header {
            margin-bottom: 3rem;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            letter-spacing: -0.02em;
        }

        .subtitle {
            font-family: var(--font-sans);
            color: var(--secondary-color);
            font-size: 1.1rem;
            font-weight: 300;
        }

        /* The Interactive Canvas */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            height: 600px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            border: 1px solid rgba(0,0,0,0.05);
            margin: 2rem 0;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        canvas {
            flex-grow: 1;
            cursor: crosshair;
            display: block;
        }

        /* Controls Section inside the wrapper */
        .controls-overlay {
            padding: 1.5rem;
            background: rgba(255,255,255,0.95);
            border-top: 1px solid var(--grid-color);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        /* Slider Styling */
        .slider-group {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-family: var(--font-sans);
        }

        .slider-label {
            min-width: 120px;
            font-weight: 600;
            font-size: 0.9rem;
        }

        input[type=range] {
            flex-grow: 1;
            height: 6px;
            background: var(--grid-color);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: var(--axis-color);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            transition: transform 0.1s;
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); }

        /* Status Indicators */
        .status-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: bold;
            font-family: var(--font-sans);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Explanatory Content */
        .prose {
            margin-top: 2rem;
        }
        
        .prose p { margin-bottom: 1.5rem; }

        .math-block {
            font-family: "Courier New", monospace;
            background: rgba(0,0,0,0.03);
            padding: 0.2rem 0.4rem;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .highlight-box {
            background: white;
            padding: 1.5rem;
            border-left: 4px solid var(--axis-color);
            border-radius: 0 8px 8px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.02);
            margin: 2rem 0;
        }

    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>The Geometry of Algebra</h1>
        <div class="subtitle">Synthesizing the Elliptic, Parabolic, and Hyperbolic Worlds</div>
    </header>

    <div class="prose">
        <p>
            We often treat <strong>Complex Numbers</strong> (circles) and <strong>Split-Complex Numbers</strong> (hyperbolas) as entirely different mathematical species.
            But they are merely two settings on a single, continuous machine.
        </p>
        <p>
            Let us define a generalized imaginary unit $u$ such that $u^2 = k$. 
            The value of $k$ determines the "curvature" of our algebraic universe.
        </p>
    </div>

    <!-- The Master Artifact -->
    <div class="canvas-wrapper">
        <canvas id="main-canvas"></canvas>
        
        <div class="controls-overlay">
            <div class="slider-group">
                <div class="slider-label">
                    Metric Sign ($k$)<br>
                    <span id="k-value" style="font-weight:400; color:#666;">-1.00</span>
                </div>
                <input type="range" id="slider-k" min="-1" max="1" step="0.01" value="-1">
                <div id="badge-status" class="status-badge" style="background:var(--col-elliptic); color:white;">Elliptic</div>
            </div>
            <div style="font-family:var(--font-sans); font-size:0.85rem; color:#666; display:flex; justify-content:space-between;">
                <span>i² = -1 (Complex)</span>
                <span>ε² = 0 (Dual)</span>
                <span>j² = +1 (Split)</span>
            </div>
        </div>
    </div>

    <div class="highlight-box">
        <h3 style="margin-top:0">The Universal Invariant</h3>
        <p>
            Watch the blue curve. This is the <strong>Unit Circle</strong> of each world—the set of points with "distance" 1 from the center.
            The formula for distance changes smoothly as you move the slider:
        </p>
        <p class="math-block" style="text-align:center; display:block; padding:1rem;">
            Distance² = x² - k·y²
        </p>
        <p>
            <strong>Interact:</strong> Drag the <span style="color:var(--axis-color); font-weight:bold;">Black Dot ($z$)</span>. 
            The <span style="color:var(--accent-color); font-weight:bold;">Blue Dot ($z \cdot u$)</span> shows the result of multiplying by the imaginary unit.
            <br><br>
            • At $k=-1$, multiplication rotates by 90°.
            <br>
            • At $k=+1$, multiplication reflects across the diagonal.
        </p>
    </div>

</div>

<script>
/**
 * geometry_unified.js
 * A unified explorer for Generalized Complex Numbers.
 */

// --- Configuration ---
const CONFIG = {
    scale: 70,     // pixels per unit
    pointRadius: 6
};

// --- State ---
const STATE = {
    k: -1,         // The "Cosmic Slider" (-1 to 1)
    
    // Canvas dimensions
    width: 0,
    height: 0,
    centerX: 0,
    centerY: 0,
    
    // Interactive Point Z
    z: { x: 1.5, y: 0.8 },
    isDragging: false
};

// --- DOM Elements ---
const canvas = document.getElementById('main-canvas');
const ctx = canvas.getContext('2d');
const slider = document.getElementById('slider-k');
const labelK = document.getElementById('k-value');
const badge = document.getElementById('badge-status');

// --- Initialization ---
function resize() {
    const parent = canvas.parentElement;
    canvas.width = parent.clientWidth * window.devicePixelRatio;
    canvas.height = (parent.clientHeight - 100) * window.devicePixelRatio; // Reserve space for controls
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    STATE.width = canvas.width / window.devicePixelRatio;
    STATE.height = canvas.height / window.devicePixelRatio;
    STATE.centerX = STATE.width / 2;
    STATE.centerY = STATE.height / 2;
}
window.addEventListener('resize', resize);
resize();

// --- Math Helpers ---
function toScreen(x, y) {
    return {
        x: STATE.centerX + x * CONFIG.scale,
        y: STATE.centerY - y * CONFIG.scale
    };
}

function fromScreen(sx, sy) {
    return {
        x: (sx - STATE.centerX) / CONFIG.scale,
        y: -(sy - STATE.centerY) / CONFIG.scale
    };
}

// Generalized Complex Multiplication
// (a + ub) * (c + ud) where u^2 = k
// = (ac + k*bd) + u(ad + bc)
function multiply(p1, p2, k) {
    return {
        x: p1.x * p2.x + k * p1.y * p2.y,
        y: p1.x * p2.y + p1.y * p2.x
    };
}

// --- Rendering ---

function drawGrid() {
    ctx.lineWidth = 1;
    ctx.strokeStyle = '#dee2e6';
    
    const range = 10;
    
    // Grid Lines
    for (let i = -range; i <= range; i++) {
        // Vertical
        const v1 = toScreen(i, -range);
        const v2 = toScreen(i, range);
        ctx.beginPath(); ctx.moveTo(v1.x, v1.y); ctx.lineTo(v2.x, v2.y); ctx.stroke();
        
        // Horizontal
        const h1 = toScreen(-range, i);
        const h2 = toScreen(range, i);
        ctx.beginPath(); ctx.moveTo(h1.x, h1.y); ctx.lineTo(h2.x, h2.y); ctx.stroke();
    }
    
    // Axes
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#343a40';
    
    const x1 = toScreen(-range, 0); const x2 = toScreen(range, 0);
    ctx.beginPath(); ctx.moveTo(x1.x, x1.y); ctx.lineTo(x2.x, x2.y); ctx.stroke();
    
    const y1 = toScreen(0, -range); const y2 = toScreen(0, range);
    ctx.beginPath(); ctx.moveTo(y1.x, y1.y); ctx.lineTo(y2.x, y2.y); ctx.stroke();

    // Null Cones (only visible when k > 0)
    if (STATE.k > 0) {
        ctx.strokeStyle = 'rgba(240, 62, 62, 0.4)'; // Light Red
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        
        // As k approaches 0, lines converge to vertical axis? 
        // Metric is x^2 - k*y^2 = 0 => x = sqrt(k)*y
        // Slope = 1/sqrt(k)
        
        const slope = 1 / Math.sqrt(STATE.k);
        // Draw large lines
        const n1 = toScreen(-10 * Math.sqrt(STATE.k), -10);
        const n2 = toScreen(10 * Math.sqrt(STATE.k), 10);
        ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y); ctx.stroke();
        
        const n3 = toScreen(-10 * Math.sqrt(STATE.k), 10);
        const n4 = toScreen(10 * Math.sqrt(STATE.k), -10);
        ctx.beginPath(); ctx.moveTo(n3.x, n3.y); ctx.lineTo(n4.x, n4.y); ctx.stroke();
        
        ctx.setLineDash([]);
    }
}

function drawUnitLocus() {
    // Equation: x^2 - k*y^2 = 1
    // We need to draw this parametrically to handle the morph smoothly.
    
    ctx.strokeStyle = '#4c6ef5'; // Blue
    ctx.lineWidth = 3;
    ctx.beginPath();

    // Parametrization strategy:
    // We want a closed loop for k < 0, open lines for k > 0.
    // Let's use polar coordinates roughly, or generalized trig.
    
    // Case 1: k < 0 (Elliptic)
    // x^2 + |k|y^2 = 1
    // x = cos(t), y = sin(t) / sqrt(|k|)
    if (STATE.k < -0.01) {
        const sqrtK = Math.sqrt(-STATE.k);
        for (let t = 0; t <= Math.PI * 2; t += 0.05) {
            const x = Math.cos(t);
            const y = Math.sin(t) / sqrtK;
            const p = toScreen(x, y);
            if (t===0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.closePath();
        ctx.stroke();
    } 
    // Case 2: k > 0 (Hyperbolic)
    // x^2 - k*y^2 = 1
    // x = cosh(t), y = sinh(t) / sqrt(k)
    // We draw two branches
    else if (STATE.k > 0.01) {
        const sqrtK = Math.sqrt(STATE.k);
        const limit = 2.5; // t limit
        
        // Right Branch
        ctx.beginPath();
        for (let t = -limit; t <= limit; t += 0.1) {
            const x = Math.cosh(t);
            const y = Math.sinH ? Math.sinh(t) : (Math.exp(t)-Math.exp(-t))/2; // Polyfill safety
            const sy = y / sqrtK;
            const p = toScreen(x, sy);
            if (t===-limit) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();

        // Left Branch
        ctx.beginPath();
        for (let t = -limit; t <= limit; t += 0.1) {
            const x = -Math.cosh(t);
            const y = Math.sinH ? Math.sinh(t) : (Math.exp(t)-Math.exp(-t))/2; 
            const sy = y / sqrtK;
            const p = toScreen(x, sy);
            if (t===-limit) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
    }
    // Case 3: Parabolic (near 0)
    // x^2 = 1 => x = 1 and x = -1
    else {
        const p1_top = toScreen(1, 10);
        const p1_bot = toScreen(1, -10);
        const p2_top = toScreen(-1, 10);
        const p2_bot = toScreen(-1, -10);
        
        ctx.beginPath(); ctx.moveTo(p1_top.x, p1_top.y); ctx.lineTo(p1_bot.x, p1_bot.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(p2_top.x, p2_top.y); ctx.lineTo(p2_bot.x, p2_bot.y); ctx.stroke();
    }
}

function drawPoints() {
    // 1. The User Point Z
    const screenZ = toScreen(STATE.z.x, STATE.z.y);
    
    // 2. The Multiplied Point (z * u)
    // u = (0, 1) in our coord system
    // z = (x, y)
    // z*u = (x + uy)(0 + u) = ku*y + ux = k*y + u*x
    // Coords: (k*y, x)
    const Z = STATE.z;
    const transformed = {
        x: STATE.k * Z.y,
        y: Z.x
    };
    const screenT = toScreen(transformed.x, transformed.y);

    // Draw connection lines to origin (vectors)
    ctx.lineWidth = 2;
    const origin = toScreen(0,0);
    
    // Vector Z
    ctx.strokeStyle = '#343a40'; // Black
    ctx.beginPath(); ctx.moveTo(origin.x, origin.y); ctx.lineTo(screenZ.x, screenZ.y); ctx.stroke();
    
    // Vector Z*u
    ctx.strokeStyle = '#4c6ef5'; // Blue
    ctx.beginPath(); ctx.moveTo(origin.x, origin.y); ctx.lineTo(screenT.x, screenT.y); ctx.stroke();

    // Draw connecting arc or line to show the relationship?
    // In Elliptic, it's a 90 deg arc. In Hyperbolic, it's a reflection?
    ctx.setLineDash([2, 4]);
    ctx.strokeStyle = '#adb5bd';
    ctx.beginPath(); ctx.moveTo(screenZ.x, screenZ.y); ctx.lineTo(screenT.x, screenT.y); ctx.stroke();
    ctx.setLineDash([]);

    // Draw Dots
    // Z
    ctx.fillStyle = '#212529';
    ctx.beginPath(); ctx.arc(screenZ.x, screenZ.y, CONFIG.pointRadius, 0, Math.PI*2); ctx.fill();
    
    // Z*u
    ctx.fillStyle = '#4c6ef5';
    ctx.beginPath(); ctx.arc(screenT.x, screenT.y, CONFIG.pointRadius, 0, Math.PI*2); ctx.fill();

    // Labels
    ctx.font = "bold 14px sans-serif";
    ctx.fillStyle = "#212529";
    ctx.fillText("z", screenZ.x + 10, screenZ.y - 10);
    
    ctx.fillStyle = "#4c6ef5";
    ctx.fillText("z·u", screenT.x + 10, screenT.y - 10);
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawGrid();
    drawUnitLocus();
    drawPoints();
    
    requestAnimationFrame(render);
}

// --- Interaction Logic ---

// Slider Update
slider.addEventListener('input', (e) => {
    STATE.k = parseFloat(e.target.value);
    labelK.textContent = STATE.k.toFixed(2);
    
    // Update Badge
    if (STATE.k < -0.1) {
        badge.textContent = "Elliptic Space";
        badge.style.background = "var(--col-elliptic)";
    } else if (STATE.k > 0.1) {
        badge.textContent = "Hyperbolic Space";
        badge.style.background = "var(--col-hyperbolic)";
    } else {
        badge.textContent = "Parabolic Space";
        badge.style.background = "var(--col-parabolic)";
    }
});

// Canvas Dragging
function getMousePos(evt) {
    const rect = canvas.getBoundingClientRect();
    const cx = evt.touches ? evt.touches[0].clientX : evt.clientX;
    const cy = evt.touches ? evt.touches[0].clientY : evt.clientY;
    return {
        x: (cx - rect.left) * window.devicePixelRatio,
        y: (cy - rect.top) * window.devicePixelRatio
    };
}

const handleStart = (e) => {
    e.preventDefault();
    const pos = getMousePos(e);
    const zPos = toScreen(STATE.z.x, STATE.z.y);
    
    // Check hit
    const dist = Math.hypot(pos.x - zPos.x, pos.y - zPos.y);
    if (dist < 30) {
        STATE.isDragging = true;
        canvas.style.cursor = 'grabbing';
    }
};

const handleMove = (e) => {
    if (!STATE.isDragging) return;
    e.preventDefault();
    const pos = getMousePos(e);
    const mathPos = fromScreen(pos.x, pos.y);
    STATE.z.x = mathPos.x;
    STATE.z.y = mathPos.y;
};

const handleEnd = () => {
    STATE.isDragging = false;
    canvas.style.cursor = 'crosshair';
};

canvas.addEventListener('mousedown', handleStart);
canvas.addEventListener('touchstart', handleStart);
window.addEventListener('mousemove', handleMove);
window.addEventListener('touchmove', handleMove);
window.addEventListener('mouseup', handleEnd);
window.addEventListener('touchend', handleEnd);

// Start Loop
render();

</script>
</body>
</html>