<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Connectedness as an Induction Principle</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
  <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.2/lib/anime.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #1a1d23;
      color: #e8eaed;
      font-family: system-ui, -apple-system, 'Segoe UI', sans-serif;
      font-size: 18px;
      line-height: 1.7;
      overflow-x: hidden;
    }

    .container {
      max-width: 720px;
      margin: 0 auto;
      padding: 4rem 2rem;
    }

    h1 {
      font-family: 'Georgia', serif;
      font-size: 2.5rem;
      line-height: 1.2;
      margin-bottom: 3rem;
      color: #e8eaed;
    }

    h2 {
      font-family: 'Georgia', serif;
      font-size: 1.8rem;
      margin: 3rem 0 1.5rem;
      color: #5f8a8b;
    }

    h3 {
      font-family: 'Georgia', serif;
      font-size: 1.4rem;
      margin: 2rem 0 1rem;
      color: #8b7a5f;
    }

    p {
      margin-bottom: 1.5rem;
      color: #e8eaed;
    }

    .lead {
      font-size: 1.2rem;
      color: #9aa0a6;
      font-style: italic;
      margin-bottom: 2rem;
      padding-left: 1.5rem;
      border-left: 3px solid #5f8a8b;
    }

    .visualization {
      width: 100vw;
      position: relative;
      left: 50%;
      right: 50%;
      margin-left: -50vw;
      margin-right: -50vw;
      margin-top: 3rem;
      margin-bottom: 3rem;
      background: #242830;
      padding: 3rem 0;
    }

    .viz-inner {
      max-width: 900px;
      margin: 0 auto;
      padding: 0 2rem;
    }

    canvas {
      display: block;
      width: 100%;
      border-radius: 8px;
    }

    .control-group {
      margin: 1.5rem 0;
      padding: 1rem;
      background: #1a1d23;
      border-radius: 8px;
    }

    .control-group label {
      display: block;
      margin-bottom: 0.5rem;
      color: #9aa0a6;
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .control-group label span {
      color: #5f8a8b;
      font-weight: 600;
      font-size: 1.1rem;
      margin-left: 0.5rem;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      background: #242830;
      border-radius: 3px;
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #5f8a8b;
      cursor: pointer;
      border-radius: 50%;
      transition: background 0.2s;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      background: #6f9a9b;
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: #5f8a8b;
      cursor: pointer;
      border-radius: 50%;
      border: none;
    }

    .math-display {
      margin: 2rem 0;
      padding: 1.5rem;
      background: #242830;
      border-radius: 8px;
      overflow-x: auto;
    }

    .math-inline {
      display: inline;
    }

    ul {
      margin: 1.5rem 0;
      padding-left: 2rem;
    }

    li {
      margin: 0.8rem 0;
      color: #e8eaed;
    }

    .step-indicator {
      display: flex;
      justify-content: space-between;
      margin: 2rem 0;
      padding: 1rem;
      background: #242830;
      border-radius: 8px;
    }

    .step {
      flex: 1;
      text-align: center;
      padding: 0.5rem;
      border-radius: 4px;
      transition: all 0.3s;
      opacity: 0.4;
    }

    .step.active {
      opacity: 1;
      background: #5f8a8b;
    }

    .step-label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .button-group {
      display: flex;
      gap: 1rem;
      margin: 1.5rem 0;
    }

    button {
      padding: 0.8rem 1.5rem;
      background: #5f8a8b;
      color: #e8eaed;
      border: none;
      border-radius: 6px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    button:hover {
      background: #6f9a9b;
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    button.secondary {
      background: #8b5f6d;
    }

    button.secondary:hover {
      background: #9b6f7d;
    }

    .fade-in {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 0.6s, transform 0.6s;
    }

    .fade-in.visible {
      opacity: 1;
      transform: translateY(0);
    }

    .highlight {
      background: linear-gradient(120deg, rgba(95, 138, 139, 0.3) 0%, rgba(95, 138, 139, 0.3) 100%);
      background-repeat: no-repeat;
      background-size: 0% 100%;
      transition: background-size 0.6s;
    }

    .highlight.active {
      background-size: 100% 100%;
    }

    #three-container {
      width: 100%;
      height: 500px;
      border-radius: 8px;
      overflow: hidden;
    }

    .tooltip {
      position: absolute;
      background: #242830;
      padding: 0.5rem 1rem;
      border-radius: 4px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      font-size: 0.85rem;
      border: 1px solid #5f8a8b;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Connectedness as an Induction Principle</h1>
    
    <p class="lead">Mathematical induction isn't just about natural numbers. From the real line to abstract topological spaces, the principle of "bootstrapping truth" reveals deep connections between order, continuity, and the structure of mathematical objects.</p>

    <h2>Bootstrapping Truth</h2>
    
    <p>A lecturer once explained the philosophy of mathematical induction with remarkable clarity:</p>
    
    <p class="lead">If you want to prove a statement holds for some object x, you may harmlessly assume it holds for any y < x.</p>
    
    <p>This captures the essence of <em>strong induction</em>, a powerful strategy for proving predicates on the natural numbers. The formal statement looks intimidating at first, but reveals a beautiful pattern of self-reference and bootstrapping.</p>
  </div>

  <div class="visualization">
    <div class="viz-inner">
      <h3>Strong Induction: The Domino Effect</h3>
      <canvas id="induction-canvas" width="800" height="400"></canvas>
      <div class="control-group">
        <label>Step: <span id="step-value">0</span></label>
        <input type="range" min="0" max="10" step="1" value="0" id="step-slider">
      </div>
      <div class="button-group">
        <button id="play-induction">Play Animation</button>
        <button id="reset-induction" class="secondary">Reset</button>
      </div>
    </div>
  </div>

  <div class="container">
    <p>The mechanism is elegant: we verify a base case, then show that truth propagates forward. For any natural number <em>n</em>, if we know the predicate holds for all smaller numbers, we can deduce it holds for <em>n</em> itself.</p>

    <p>Let's trace through the bootstrap process:</p>

    <div class="math-display" id="induction-steps"></div>

    <p>This creates a cascade of implications. We deduce P(0) from nothing (the empty set of assumptions is always satisfied). Then P(0) implies P(1). Then P(0) and P(1) together imply P(2). The truth builds upon itself, layer by layer, covering all natural numbers.</p>

    <h2>Induction Just Got Real</h2>

    <h3>The Definition</h3>

    <p>What happens when we try to extend induction beyond the discrete realm of natural numbers? The real line presents a challenge: there's no "next" real number after any given point. Yet remarkably, we can adapt the induction principle to intervals of real numbers.</p>

    <p>Consider a subset S of an interval [a, b] satisfying three key properties that mirror our intuition from natural number induction:</p>
  </div>

  <div class="visualization">
    <div class="viz-inner">
      <h3>Real Induction: The March Rightward</h3>
      <canvas id="real-induction-canvas" width="800" height="300"></canvas>
      <div class="control-group">
        <label>Animation Speed: <span id="speed-value">1.0</span>x</label>
        <input type="range" min="0.2" max="3" step="0.1" value="1.0" id="speed-slider">
      </div>
      <div class="step-indicator">
        <div class="step active" data-step="0">
          <div class="step-label">Base Case</div>
        </div>
        <div class="step" data-step="1">
          <div class="step-label">Ordinary Step</div>
        </div>
        <div class="step" data-step="2">
          <div class="step-label">Strong Step</div>
        </div>
        <div class="step" data-step="3">
          <div class="step-label">Complete</div>
        </div>
      </div>
      <div class="button-group">
        <button id="start-march">Start March</button>
        <button id="reset-march" class="secondary">Reset</button>
      </div>
    </div>
  </div>

  <div class="container">
    <p>The march begins at point <em>a</em> (our base case) and spreads rightward. At each point we've reached, ordinary induction lets us advance by some positive distance ε. But what about accumulation points—places we approach but never quite reach through finite steps?</p>

    <p>This is where strong induction saves us. If we've covered the entire interval [a, y) up to some point y, then strong induction guarantees that y itself is also covered. We can leap across any gap created by infinite sequences of smaller steps.</p>

    <h3>The Proof</h3>

    <p>Why does this work? The proof uses a beautiful contradiction argument based on the concept of infimum—the greatest lower bound.</p>

    <p>Suppose S doesn't cover the entire interval. Then there exists a set C of counterexamples: points in the interval that aren't in S. This set has a greatest lower bound, which we can think of as the "first" counterexample encountered from the left.</p>

    <p>But this leads to an immediate contradiction. If this point is actually a counterexample, then everything to its left must be in S (otherwise it wouldn't be the greatest lower bound). Strong induction then forces this point to also be in S—contradiction! And if it's not a counterexample, then it's in S, and ordinary induction lets us extend S beyond it—also contradicting the minimality.</p>

    <h3>The Intermediate Value Theorem</h3>

    <p>One of the most elegant applications of real induction is proving the intermediate value theorem: a continuous function that's positive at one endpoint and negative at the other must cross zero somewhere in between.</p>
  </div>

  <div class="visualization">
    <div class="viz-inner">
      <h3>Finding the Zero by Induction</h3>
      <canvas id="ivt-canvas" width="800" height="400"></canvas>
      <div class="control-group">
        <label>Function Parameter: <span id="func-value">0.5</span></label>
        <input type="range" min="0" max="1" step="0.01" value="0.5" id="func-slider">
      </div>
      <p style="margin-top: 1rem; color: #9aa0a6; font-size: 0.9rem;">
        The green region shows where the function is positive. Real induction proves this region extends to the entire interval, which contradicts f(b) < 0.
      </p>
    </div>
  </div>

  <div class="container">
    <p>The strategy is proof by contradiction. Define S as the set of points where the function is positive. We'll use real induction to show S must be the entire interval [a, b]—but this contradicts f(b) < 0, so our assumption that f is never zero must be false.</p>

    <p>The base case is immediate: f(a) > 0 by assumption. For ordinary induction, if f(x) > 0, then continuity guarantees f stays positive in a small neighborhood around x. For strong induction, if f is positive on [a, y), then by continuity f(y) ≥ 0, and since we assumed f is never zero, we must have f(y) > 0.</p>

    <h2>Diffusive Induction</h2>

    <p>Can we push this idea even further? In general topological spaces, we lose the linear order that made real induction possible. But we gain something else: the concept of <em>connectedness</em>.</p>

    <p>A space is connected if you cannot split it into two separate, non-overlapping open pieces. This seemingly simple property encodes a powerful induction principle.</p>
  </div>

  <div class="visualization">
    <div class="viz-inner">
      <h3>Topological Induction as Diffusion</h3>
      <div id="three-container"></div>
      <div class="control-group">
        <label>Diffusion Rate: <span id="diffusion-value">1.0</span></label>
        <input type="range" min="0.1" max="2" step="0.1" value="1.0" id="diffusion-slider">
      </div>
      <div class="button-group">
        <button id="start-diffusion">Start Diffusion</button>
        <button id="reset-diffusion" class="secondary">Reset</button>
      </div>
      <p style="margin-top: 1rem; color: #9aa0a6; font-size: 0.9rem;">
        Water (blue) spreads from a source point through a connected surface. Openness allows local spreading; closedness allows jumps across limit points.
      </p>
    </div>
  </div>

  <div class="container">
    <p>Suppose we have a subset S of a connected space X that is:</p>
    
    <ul>
      <li><strong>Nonempty</strong> (base case): there's some starting point in S</li>
      <li><strong>Open</strong> (ordinary induction): if x is in S, nearby points are also in S</li>
      <li><strong>Closed</strong> (strong induction): limit points of S are also in S</li>
    </ul>

    <p>Then S must be all of X! The proof is remarkably simple: if the complement of S were nonempty, it would also be open (since S is closed), and we'd have partitioned X into two disjoint open sets—contradicting connectedness.</p>

    <p>I visualize this as a diffusion process. A drop of water placed at a point in S spreads outward (openness) and jumps across any gaps (closedness). In a connected space, the water must eventually cover everything.</p>

    <p>This is genuinely a generalization of real induction. An interval [a, b] is connected. A set being open means it contains small intervals around each of its points. A set being closed means it contains all its limit points—including those approached from the left.</p>

    <h2>The Pattern Beneath</h2>

    <p>Stepping back, we can see a common thread running through all these induction principles. Whether we're dealing with natural numbers, real intervals, or abstract topological spaces, induction is fundamentally about <em>relationships</em>.</p>

    <p>We cannot prove statements about infinite collections by brute force—there isn't enough ink in the universe. Instead, we find patterns. We show that truth at one point implies truth at related points. We bootstrap our way from a single seed of knowledge to universal coverage.</p>
  </div>

  <div class="visualization">
    <div class="viz-inner">
      <h3>The Unified Pattern</h3>
      <canvas id="pattern-canvas" width="800" height="400"></canvas>
      <p style="margin-top: 1rem; color: #9aa0a6; font-size: 0.9rem;">
        Three manifestations of the same principle: discrete stepping (natural numbers), continuous marching (real numbers), and free diffusion (topological spaces). Hover over each to explore.
      </p>
    </div>
  </div>

  <div class="container">
    <p>The revised philosophy of induction might read:</p>

    <p class="lead">If you want to prove P(x), don't consider it in isolation. Consider how x relates to other objects y, and whether you can leverage the truth of P(y) to deduce P(x).</p>

    <p>This perspective—focusing on relationships and structure rather than individual objects—is of course central to category theory and modern mathematics. Induction, in all its forms, is really about understanding how local truth propagates through a structured space.</p>

    <p>From the discrete steps of the natural numbers, to the continuous march along the real line, to the free diffusion through connected topological spaces, we see the same fundamental insight: structure enables propagation, and propagation enables proof.</p>

    <div class="math-display" id="final-math"></div>
  </div>

  <script type="module">
    document.addEventListener('DOMContentLoaded', () => {
      initMath();
      initInductionViz();
      initRealInductionViz();
      initIVTViz();
      initThreeViz();
      initPatternViz();
      setupScrollAnimations();
    });

    function initMath() {
      const inductionSteps = document.getElementById('induction-steps');
      const steps = [
        '\\text{Base case: } (\\forall y < 0, P(y)) \\implies P(0)',
        '\\text{Since } \\forall y < 0 \\text{ is vacuously true, we have } P(0)',
        '\\text{Step 1: } P(0) \\implies (\\forall y < 1, P(y)) \\implies P(1)',
        '\\text{Step 2: } P(0) \\land P(1) \\implies (\\forall y < 2, P(y)) \\implies P(2)',
        '\\text{And so on for all } n \\in \\mathbb{N}\\ldots'
      ];
      
      steps.forEach((step, i) => {
        const div = document.createElement('div');
        div.style.marginBottom = '1rem';
        inductionSteps.appendChild(div);
        katex.render(step, div, { displayMode: true });
      });

      const finalMath = document.getElementById('final-math');
      katex.render('\\text{Induction} : \\text{Base} + \\text{Propagation} \\implies \\text{Universal Truth}', finalMath, { displayMode: true });
    }

    function initInductionViz() {
      const canvas = document.getElementById('induction-canvas');
      const ctx = canvas.getContext('2d');
      const slider = document.getElementById('step-slider');
      const stepValue = document.getElementById('step-value');
      const playBtn = document.getElementById('play-induction');
      const resetBtn = document.getElementById('reset-induction');

      let currentStep = 0;
      let animating = false;

      function drawDominoes(step) {
        ctx.fillStyle = '#1a1d23';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const numDominoes = 11;
        const spacing = canvas.width / (numDominoes + 1);
        const dominoWidth = 30;
        const dominoHeight = 80;
        const baseY = canvas.height / 2;

        for (let i = 0; i <= 10; i++) {
          const x = spacing * (i + 1);
          const isFallen = i <= step;
          const angle = isFallen ? Math.PI / 6 : 0;
          
          ctx.save();
          ctx.translate(x, baseY);
          ctx.rotate(angle);
          
          ctx.fillStyle = isFallen ? '#5f8a8b' : '#8b7a5f';
          ctx.fillRect(-dominoWidth / 2, -dominoHeight, dominoWidth, dominoHeight);
          
          ctx.strokeStyle = '#e8eaed';
          ctx.lineWidth = 2;
          ctx.strokeRect(-dominoWidth / 2, -dominoHeight, dominoWidth, dominoHeight);
          
          ctx.fillStyle = '#e8eaed';
          ctx.font = '16px monospace';
          ctx.textAlign = 'center';
          ctx.fillText(i.toString(), 0, 20);
          
          ctx.restore();
        }

        if (step > 0 && step < 10) {
          const x1 = spacing * step;
          const x2 = spacing * (step + 1);
          ctx.strokeStyle = '#8b5f6d';
          ctx.lineWidth = 3;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(x1 + 15, baseY - 40);
          ctx.lineTo(x2 - 15, baseY - 60);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }

      slider.addEventListener('input', (e) => {
        currentStep = parseInt(e.target.value);
        stepValue.textContent = currentStep;
        drawDominoes(currentStep);
      });

      playBtn.addEventListener('click', () => {
        if (animating) return;
        animating = true;
        currentStep = 0;
        
        const interval = setInterval(() => {
          currentStep++;
          slider.value = currentStep;
          stepValue.textContent = currentStep;
          drawDominoes(currentStep);
          
          if (currentStep >= 10) {
            clearInterval(interval);
            animating = false;
          }
        }, 300);
      });

      resetBtn.addEventListener('click', () => {
        currentStep = 0;
        slider.value = 0;
        stepValue.textContent = 0;
        drawDominoes(0);
      });

      drawDominoes(0);
    }

    function initRealInductionViz() {
      const canvas = document.getElementById('real-induction-canvas');
      const ctx = canvas.getContext('2d');
      const speedSlider = document.getElementById('speed-slider');
      const speedValue = document.getElementById('speed-value');
      const startBtn = document.getElementById('start-march');
      const resetBtn = document.getElementById('reset-march');
      const steps = document.querySelectorAll('.step');

      let marching = false;
      let marchPosition = 0;
      let speed = 1.0;

      speedSlider.addEventListener('input', (e) => {
        speed = parseFloat(e.target.value);
        speedValue.textContent = speed.toFixed(1);
      });

      function drawMarch() {
        ctx.fillStyle = '#242830';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const y = canvas.height / 2;
        const startX = 50;
        const endX = canvas.width - 50;

        ctx.strokeStyle = '#9aa0a6';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(startX, y);
        ctx.lineTo(endX, y);
        ctx.stroke();

        ctx.fillStyle = '#5f8a8b';
        ctx.fillRect(startX, y - 30, marchPosition * (endX - startX), 60);

        for (let tick = 0; tick <= 1; tick += 0.1) {
          const x = startX + tick * (endX - startX);
          ctx.fillStyle = '#9aa0a6';
          ctx.fillRect(x - 1, y - 35, 2, 10);
          ctx.font = '12px monospace';
          ctx.textAlign = 'center';
          ctx.fillText(tick.toFixed(1), x, y + 50);
        }

        const currentX = startX + marchPosition * (endX - startX);
        ctx.beginPath();
        ctx.arc(currentX, y, 8, 0, Math.PI * 2);
        ctx.fillStyle = '#8b5f6d';
        ctx.fill();
        ctx.strokeStyle = '#e8eaed';
        ctx.lineWidth = 2;
        ctx.stroke();

        if (marchPosition > 0 && marchPosition < 1) {
          ctx.strokeStyle = '#8b7a5f';
          ctx.setLineDash([5, 5]);
          ctx.lineWidth = 2;
          ctx.beginPath();
          const epsilonX = Math.min(currentX + 50, endX);
          ctx.moveTo(currentX, y - 40);
          ctx.lineTo(epsilonX, y - 40);
          ctx.stroke();
          ctx.setLineDash([]);

          ctx.fillStyle = '#8b7a5f';
          ctx.font = '14px Georgia';
          ctx.textAlign = 'center';
          ctx.fillText('ε', (currentX + epsilonX) / 2, y - 45);
        }
      }

      function updateStepIndicator() {
        steps.forEach(step => step.classList.remove('active'));
        if (marchPosition === 0) {
          steps[0].classList.add('active');
        } else if (marchPosition < 0.5) {
          steps[1].classList.add('active');
        } else if (marchPosition < 1) {
          steps[2].classList.add('active');
        } else {
          steps[3].classList.add('active');
        }
      }

      startBtn.addEventListener('click', () => {
        if (marching) return;
        marching = true;
        
        function animate() {
          if (!marching) return;
          
          marchPosition += 0.005 * speed;
          if (marchPosition >= 1) {
            marchPosition = 1;
            marching = false;
          }
          
          drawMarch();
          updateStepIndicator();
          
          if (marching) {
            requestAnimationFrame(animate);
          }
        }
        
        animate();
      });

      resetBtn.addEventListener('click', () => {
        marching = false;
        marchPosition = 0;
        drawMarch();
        updateStepIndicator();
      });

      drawMarch();
      updateStepIndicator();
    }

    function initIVTViz() {
      const canvas = document.getElementById('ivt-canvas');
      const ctx = canvas.getContext('2d');
      const slider = document.getElementById('func-slider');
      const funcValue = document.getElementById('func-value');

      let param = 0.5;

      slider.addEventListener('input', (e) => {
        param = parseFloat(e.target.value);
        funcValue.textContent = param.toFixed(2);
        draw();
      });

      function f(x) {
        const zero = param;
        return Math.sin((x - zero) * 8) * 0.4 + (x - zero) * 2;
      }

      function draw() {
        ctx.fillStyle = '#242830';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const marginX = 60;
        const marginY = 50;
        const plotWidth = canvas.width - 2 * marginX;
        const plotHeight = canvas.height - 2 * marginY;
        const centerY = canvas.height / 2;

        ctx.strokeStyle = '#9aa0a6';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(marginX, centerY);
        ctx.lineTo(canvas.width - marginX, centerY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(marginX, marginY);
        ctx.lineTo(marginX, canvas.height - marginY);
        ctx.stroke();

        ctx.fillStyle = 'rgba(95, 138, 139, 0.2)';
        ctx.beginPath();
        ctx.moveTo(marginX, centerY);
        
        for (let px = 0; px <= plotWidth; px++) {
          const x = px / plotWidth;
          const y = f(x);
          const py = centerY - y * plotHeight / 2;
          
          if (px === 0) {
            ctx.moveTo(marginX + px, py);
          } else {
            ctx.lineTo(marginX + px, py);
          }
        }
        
        for (let px = plotWidth; px >= 0; px--) {
          const x = px / plotWidth;
          const y = f(x);
          if (y > 0) {
            ctx.lineTo(marginX + px, centerY);
          } else {
            break;
          }
        }
        
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = '#5f8a8b';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        for (let px = 0; px <= plotWidth; px++) {
          const x = px / plotWidth;
          const y = f(x);
          const py = centerY - y * plotHeight / 2;
          
          if (px === 0) {
            ctx.moveTo(marginX + px, py);
          } else {
            ctx.lineTo(marginX + px, py);
          }
        }
        
        ctx.stroke();

        const ya = f(0);
        const yb = f(1);
        
        ctx.fillStyle = ya > 0 ? '#5f8a8b' : '#8b5f6d';
        ctx.beginPath();
        ctx.arc(marginX, centerY - ya * plotHeight / 2, 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = yb > 0 ? '#5f8a8b' : '#8b5f6d';
        ctx.beginPath();
        ctx.arc(marginX + plotWidth, centerY - yb * plotHeight / 2, 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#8b7a5f';
        ctx.font = '14px Georgia';
        ctx.textAlign = 'left';
        ctx.fillText('f(a) > 0', marginX + 5, centerY - ya * plotHeight / 2 - 10);
        ctx.fillText('f(b) < 0', marginX + plotWidth - 70, centerY - yb * plotHeight / 2 + 20);

        for (let px = 0; px <= plotWidth; px++) {
          const x = px / plotWidth;
          const y = f(x);
          if (Math.abs(y) < 0.02) {
            ctx.fillStyle = '#e8eaed';
            ctx.beginPath();
            ctx.arc(marginX + px, centerY, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#8b5f6d';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#e8eaed';
            ctx.font = '14px Georgia';
            ctx.textAlign = 'center';
            ctx.fillText('zero', marginX + px, centerY + 25);
            break;
          }
        }
      }

      draw();
    }

    function initThreeViz() {
      const container = document.getElementById('three-container');
      const diffusionSlider = document.getElementById('diffusion-slider');
      const diffusionValue = document.getElementById('diffusion-value');
      const startBtn = document.getElementById('start-diffusion');
      const resetBtn = document.getElementById('reset-diffusion');

      let scene, camera, renderer, surface, particles;
      let diffusionRate = 1.0;
      let diffusing = false;
      let diffusionProgress = 0;

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x242830);

        camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 3, 5);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);

        const geometry = new THREE.SphereGeometry(2, 64, 64);
        const material = new THREE.MeshPhongMaterial({
          color: 0x8b7a5f,
          emissive: 0x1a1d23,
          specular: 0x5f8a8b,
          shininess: 30,
          flatShading: false,
        });
        surface = new THREE.Mesh(geometry, material);
        scene.add(surface);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.8);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        const particleGeometry = new THREE.BufferGeometry();
        const particleCount = 2000;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        
        particles = {
          geometry: particleGeometry,
          positions: positions,
          colors: colors,
          active: new Array(particleCount).fill(false)
        };

        const particleMaterial = new THREE.PointsMaterial({
          size: 0.05,
          vertexColors: true,
          transparent: true,
          opacity: 0.8
        });

        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(particleSystem);

        window.addEventListener('resize', onResize);
      }

      function onResize() {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
      }

      function resetParticles() {
        particles.active.fill(false);
        diffusionProgress = 0;
      }

      function updateDiffusion() {
        const particleCount = particles.positions.length / 3;
        const activeCount = Math.floor(diffusionProgress * particleCount);

        for (let i = 0; i < activeCount; i++) {
          if (!particles.active[i]) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            const r = 2.05;

            particles.positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
            particles.positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
            particles.positions[i * 3 + 2] = r * Math.cos(phi);

            particles.colors[i * 3] = 95 / 255;
            particles.colors[i * 3 + 1] = 138 / 255;
            particles.colors[i * 3 + 2] = 139 / 255;

            particles.active[i] = true;
          }
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;
      }

      function animate() {
        requestAnimationFrame(animate);

        surface.rotation.y += 0.002;

        if (diffusing) {
          diffusionProgress += 0.002 * diffusionRate;
          if (diffusionProgress >= 1) {
            diffusionProgress = 1;
            diffusing = false;
          }
          updateDiffusion();
        }

        renderer.render(scene, camera);
      }

      diffusionSlider.addEventListener('input', (e) => {
        diffusionRate = parseFloat(e.target.value);
        diffusionValue.textContent = diffusionRate.toFixed(1);
      });

      startBtn.addEventListener('click', () => {
        if (!diffusing) {
          diffusing = true;
        }
      });

      resetBtn.addEventListener('click', () => {
        diffusing = false;
        resetParticles();
        updateDiffusion();
      });

      init();
      animate();
    }

    function initPatternViz() {
      const canvas = document.getElementById('pattern-canvas');
      const ctx = canvas.getContext('2d');

      let hoveredRegion = null;

      canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const regionWidth = canvas.width / 3;
        
        if (x < regionWidth) {
          hoveredRegion = 0;
        } else if (x < regionWidth * 2) {
          hoveredRegion = 1;
        } else {
          hoveredRegion = 2;
        }
        
        draw();
      });

      canvas.addEventListener('mouseleave', () => {
        hoveredRegion = null;
        draw();
      });

      function draw() {
        ctx.fillStyle = '#242830';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const regionWidth = canvas.width / 3;
        const colors = ['#5f8a8b', '#8b5f6d', '#8b7a5f'];
        const titles = ['Natural Numbers', 'Real Numbers', 'Topological Spaces'];
        const subtitles = ['Discrete Steps', 'Continuous March', 'Free Diffusion'];

        for (let i = 0; i < 3; i++) {
          const x = i * regionWidth;
          const isHovered = hoveredRegion === i;
          const alpha = isHovered ? 0.3 : 0.1;

          ctx.fillStyle = colors[i] + Math.floor(alpha * 255).toString(16).padStart(2, '0');
          ctx.fillRect(x + 10, 50, regionWidth - 20, canvas.height - 100);

          ctx.strokeStyle = colors[i];
          ctx.lineWidth = isHovered ? 3 : 2;
          ctx.strokeRect(x + 10, 50, regionWidth - 20, canvas.height - 100);

          ctx.fillStyle = '#e8eaed';
          ctx.font = isHovered ? 'bold 18px Georgia' : '16px Georgia';
          ctx.textAlign = 'center';
          ctx.fillText(titles[i], x + regionWidth / 2, 30);

          ctx.fillStyle = '#9aa0a6';
          ctx.font = '14px system-ui';
          ctx.fillText(subtitles[i], x + regionWidth / 2, canvas.height - 30);

          const centerY = canvas.height / 2;
          const centerX = x + regionWidth / 2;

          if (i === 0) {
            for (let j = 0; j < 5; j++) {
              const py = centerY - 80 + j * 40;
              ctx.beginPath();
              ctx.arc(centerX, py, 6, 0, Math.PI * 2);
              ctx.fillStyle = j === 0 ? colors[i] : (isHovered ? colors[i] : '#9aa0a6');
              ctx.fill();
              
              if (j < 4) {
                ctx.strokeStyle = isHovered ? colors[i] : '#9aa0a6';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(centerX, py + 6);
                ctx.lineTo(centerX, py + 34);
                ctx.stroke();
                
                const arrowSize = 6;
                ctx.beginPath();
                ctx.moveTo(centerX, py + 34);
                ctx.lineTo(centerX - arrowSize / 2, py + 34 - arrowSize);
                ctx.lineTo(centerX + arrowSize / 2, py + 34 - arrowSize);
                ctx.closePath();
                ctx.fillStyle = isHovered ? colors[i] : '#9aa0a6';
                ctx.fill();
              }
            }
          } else if (i === 1) {
            ctx.strokeStyle = isHovered ? colors[i] : '#9aa0a6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - 60, centerY);
            ctx.lineTo(centerX + 60, centerY);
            ctx.stroke();

            ctx.fillStyle = colors[i];
            ctx.fillRect(centerX - 60, centerY - 15, isHovered ? 100 : 60, 30);

            ctx.beginPath();
            ctx.arc(centerX - 60, centerY, 8, 0, Math.PI * 2);
            ctx.fillStyle = colors[i];
            ctx.fill();
            ctx.strokeStyle = '#e8eaed';
            ctx.lineWidth = 2;
            ctx.stroke();
          } else {
            const numPoints = 12;
            const radius = 60;
            
            for (let j = 0; j < numPoints; j++) {
              const angle = (j / numPoints) * Math.PI * 2;
              const px = centerX + Math.cos(angle) * radius;
              const py = centerY + Math.sin(angle) * radius;
              
              const distance = Math.sqrt((px - centerX) ** 2 + (py - centerY) ** 2);
              const maxDist = radius;
              const fillAmount = isHovered ? 1 : 0.5;
              
              if (distance / maxDist < fillAmount) {
                ctx.beginPath();
                ctx.arc(px, py, 4, 0, Math.PI * 2);
                ctx.fillStyle = colors[i];
                ctx.fill();
              } else {
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#9aa0a6';
                ctx.fill();
              }
            }

            ctx.beginPath();
            ctx.arc(centerX, centerY, 6, 0, Math.PI * 2);
            ctx.fillStyle = colors[i];
            ctx.fill();
            ctx.strokeStyle = '#e8eaed';
            ctx.lineWidth = 2;
            ctx.stroke();
          }
        }
      }

      draw();
    }

    function setupScrollAnimations() {
      const fadeElements = document.querySelectorAll('p, h2, h3, .visualization');
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('fade-in', 'visible');
          }
        });
      }, {
        threshold: 0.1,
        rootMargin: '0px 0px -100px 0px'
      });

      fadeElements.forEach(el => {
        el.classList.add('fade-in');
        observer.observe(el);
      });
    }
  </script>
</body>
</html>