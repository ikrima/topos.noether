<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symmetric Space Extensions | Categorical Foundations of FMM</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,600;1,300;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Crimson Pro', serif; font-size: 19px; line-height: 1.7; color: #e8e6e3; background: #0a0a0f; }
        .container { max-width: 920px; margin: 0 auto; padding: 80px 40px; }
        header { margin-bottom: 80px; padding-bottom: 40px; border-bottom: 1px solid rgba(139, 92, 246, 0.3); }
        .series-label { font-family: 'JetBrains Mono', monospace; font-size: 11px; text-transform: uppercase; letter-spacing: 3px; color: #a78bfa; margin-bottom: 20px; }
        h1 { font-size: 52px; font-weight: 300; line-height: 1.15; margin-bottom: 24px; background: linear-gradient(135deg, #a78bfa, #22d3ee); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .subtitle { font-size: 22px; font-style: italic; color: #9ca3af; font-weight: 300; }
        h2 { font-size: 32px; font-weight: 400; margin: 70px 0 30px; color: #a78bfa; }
        h3 { font-size: 24px; font-weight: 400; margin: 50px 0 20px; color: #22d3ee; }
        p { margin-bottom: 24px; text-align: justify; }
        .lead { font-size: 22px; line-height: 1.8; color: #d1d5db; margin-bottom: 40px; }
        .figure-container { margin: 50px 0; background: linear-gradient(145deg, rgba(30, 27, 46, 0.95), rgba(20, 18, 35, 0.98)); border-radius: 16px; padding: 30px; border: 1px solid rgba(139, 92, 246, 0.2); box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4); }
        .figure-title { font-family: 'JetBrains Mono', monospace; font-size: 12px; text-transform: uppercase; letter-spacing: 2px; color: #a78bfa; margin-bottom: 20px; }
        .figure-canvas { background: rgba(10, 10, 20, 0.8); border-radius: 12px; margin-bottom: 20px; }
        svg { display: block; width: 100%; height: auto; }
        .controls { display: flex; flex-wrap: wrap; gap: 15px; padding-top: 15px; border-top: 1px solid rgba(139, 92, 246, 0.2); }
        .control-group { display: flex; align-items: center; gap: 10px; }
        .control-label { font-family: 'JetBrains Mono', monospace; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #9ca3af; }
        .btn { font-family: 'JetBrains Mono', monospace; font-size: 11px; padding: 8px 16px; border: 1px solid rgba(139, 92, 246, 0.4); background: rgba(139, 92, 246, 0.1); color: #a78bfa; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; }
        .btn:hover { background: rgba(139, 92, 246, 0.25); border-color: #a78bfa; }
        .btn.active { background: rgba(139, 92, 246, 0.4); border-color: #a78bfa; color: #fff; }
        .slider-container { display: flex; align-items: center; gap: 12px; }
        input[type="range"] { -webkit-appearance: none; width: 140px; height: 4px; background: rgba(139, 92, 246, 0.3); border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: #a78bfa; border-radius: 50%; cursor: pointer; }
        .slider-value { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: #22d3ee; min-width: 50px; }
        .equation-box { background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(34, 211, 238, 0.1)); border: 1px solid rgba(139, 92, 246, 0.3); border-radius: 12px; padding: 30px; margin: 40px 0; text-align: center; }
        .equation { font-family: 'JetBrains Mono', monospace; font-size: 18px; color: #a78bfa; line-height: 2; }
        .equation-label { font-size: 14px; color: #9ca3af; margin-top: 15px; font-style: italic; }
        .definition-box { background: rgba(139, 92, 246, 0.08); border-left: 3px solid #a78bfa; padding: 25px 30px; margin: 35px 0; border-radius: 0 12px 12px 0; }
        .definition-header { font-family: 'JetBrains Mono', monospace; font-size: 12px; text-transform: uppercase; letter-spacing: 2px; color: #a78bfa; margin-bottom: 12px; }
        .theorem-box { background: linear-gradient(135deg, rgba(34, 211, 238, 0.08), rgba(139, 92, 246, 0.08)); border: 1px solid rgba(34, 211, 238, 0.3); padding: 25px 30px; margin: 35px 0; border-radius: 12px; }
        .theorem-header { font-family: 'JetBrains Mono', monospace; font-size: 12px; text-transform: uppercase; letter-spacing: 2px; color: #22d3ee; margin-bottom: 12px; }
        .insight-box { background: rgba(74, 222, 128, 0.08); border: 1px solid rgba(74, 222, 128, 0.3); padding: 25px 30px; margin: 35px 0; border-radius: 12px; position: relative; }
        .insight-box::before { content: "✦"; position: absolute; top: -12px; left: 25px; background: #0a0a0f; padding: 0 10px; color: #4ade80; font-size: 18px; }
        .table-container { overflow-x: auto; margin: 30px 0; }
        table { width: 100%; border-collapse: collapse; font-family: 'JetBrains Mono', monospace; font-size: 14px; }
        th, td { padding: 12px 16px; text-align: center; border: 1px solid rgba(139, 92, 246, 0.2); }
        th { background: rgba(139, 92, 246, 0.15); color: #a78bfa; }
        td { color: #d1d5db; }
        .symbol { font-family: 'JetBrains Mono', monospace; color: #22d3ee; }
        footer { margin-top: 100px; padding-top: 40px; border-top: 1px solid rgba(139, 92, 246, 0.2); text-align: center; }
        .nav-links { display: flex; justify-content: space-between; margin-top: 30px; }
        .nav-link { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: #a78bfa; }
        .series-summary { background: linear-gradient(135deg, rgba(139, 92, 246, 0.05), rgba(34, 211, 238, 0.05)); border: 1px solid rgba(139, 92, 246, 0.2); border-radius: 16px; padding: 40px; margin: 60px 0; }
        .series-summary h3 { margin-top: 0; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="series-label">Categorical Foundations of FMM — Essay V</div>
            <h1>Symmetric Space Extensions</h1>
            <p class="subtitle">Beyond Euclidean space: FMM on curved geometries with harmonic analysis</p>
        </header>

        <p class="lead">
            The classical FMM lives in Euclidean space ℝ<sup>d</sup>. But the categorical framework 
            reveals a far more general structure: FMM extends naturally to <em>Riemannian symmetric 
            spaces</em> G/K, with complexity bounds determined by volume growth.
        </p>

        <h2>Why Symmetric Spaces?</h2>

        <p>
            Riemannian symmetric spaces are the natural arena for generalized harmonic analysis. 
            They include Euclidean space as a special case, but also hyperbolic spaces, spheres, 
            and the spaces of positive-definite matrices central to statistics and machine learning.
        </p>

        <div class="definition-box">
            <div class="definition-header">Definition — Riemannian Symmetric Space</div>
            <p>
                A <strong>Riemannian symmetric space</strong> is a Riemannian manifold 
                <span class="symbol">M</span> such that at every point <span class="symbol">p ∈ M</span>, 
                there exists an isometry <span class="symbol">σ<sub>p</sub></span> with 
                <span class="symbol">σ<sub>p</sub>(p) = p</span> and 
                <span class="symbol">dσ<sub>p</sub>|<sub>p</sub> = -Id</span>.
            </p>
            <p style="margin-top: 15px;">
                Equivalently, <span class="symbol">M = G/K</span> where <span class="symbol">G</span> 
                is a Lie group and <span class="symbol">K</span> a compact subgroup.
            </p>
        </div>

        <div class="table-container">
            <table>
                <tr><th>Space</th><th>G</th><th>K</th><th>Curvature</th><th>Example</th></tr>
                <tr><td>Euclidean</td><td>E(d)</td><td>O(d)</td><td>0</td><td>ℝ<sup>d</sup></td></tr>
                <tr><td>Sphere</td><td>SO(d+1)</td><td>SO(d)</td><td>+1</td><td>S<sup>d</sup></td></tr>
                <tr><td>Hyperbolic</td><td>SO(d,1)</td><td>SO(d)</td><td>−1</td><td>ℍ<sup>d</sup></td></tr>
                <tr><td>Pos. Definite</td><td>GL(n,ℝ)</td><td>O(n)</td><td>≤ 0</td><td>SPD(n)</td></tr>
            </table>
        </div>

        <div class="figure-container">
            <div class="figure-title">Figure 1 · The Three Model Geometries</div>
            <div class="figure-canvas" id="fig1-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Geometry:</span>
                    <button class="btn active" data-geom="euclidean">Euclidean (κ=0)</button>
                    <button class="btn" data-geom="spherical">Spherical (κ>0)</button>
                    <button class="btn" data-geom="hyperbolic">Hyperbolic (κ<0)</button>
                </div>
            </div>
        </div>

        <h2>Spherical Harmonics Generalize</h2>

        <p>
            On Euclidean space, the FMM uses spherical harmonics—the eigenfunctions of the 
            Laplacian on the sphere. On a general symmetric space <span class="symbol">G/K</span>, 
            these generalize to <em>spherical functions</em>: K-invariant eigenfunctions of the 
            invariant differential operators.
        </p>

        <div class="definition-box">
            <div class="definition-header">Definition — Spherical Function</div>
            <p>
                A <strong>spherical function</strong> on <span class="symbol">G/K</span> is a 
                smooth K-bi-invariant function <span class="symbol">φ<sub>λ</sub> : G → ℂ</span> 
                satisfying <span class="symbol">Dφ<sub>λ</sub> = χ<sub>λ</sub>(D)φ<sub>λ</sub></span> 
                for all invariant differential operators <span class="symbol">D</span>.
            </p>
        </div>

        <p>
            The parameter <span class="symbol">λ</span> lives in the dual of a Cartan subalgebra, 
            and the spherical functions are indexed by the <em>spherical dual</em> 
            <span class="symbol">K̂</span>. This is finite-dimensional for compact 
            <span class="symbol">G/K</span> (like spheres), but infinite-dimensional for 
            non-compact spaces (like hyperbolic space).
        </p>

        <div class="equation-box">
            <div class="equation">
                ℱ<sub>FMM</sub>(B) = ∏<sub>λ∈K̂</sub> V<sub>λ</sub>
            </div>
            <div class="equation-label">
                FMM coefficients: direct product over spherical representations
            </div>
        </div>

        <div class="figure-container">
            <div class="figure-title">Figure 2 · Spherical Functions on Different Spaces</div>
            <div class="figure-canvas" id="fig2-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Mode λ:</span>
                    <div class="slider-container">
                        <input type="range" id="mode-slider" min="0" max="5" value="2">
                        <span class="slider-value" id="mode-val">λ = 2</span>
                    </div>
                </div>
                <div class="control-group">
                    <span class="control-label">Space:</span>
                    <button class="btn active" data-space="sphere">Sphere</button>
                    <button class="btn" data-space="hyperbolic">Hyperbolic</button>
                </div>
            </div>
        </div>

        <h2>Volume Growth and Complexity</h2>

        <p>
            The key insight for symmetric space FMM is that <em>volume growth</em> determines 
            computational complexity. The volume of a ball of radius <span class="symbol">r</span> 
            on <span class="symbol">G/K</span> grows according to the curvature:
        </p>

        <div class="equation-box">
            <div class="equation">
                Vol(B<sub>r</sub>) ∼ r<sup>d</sup> (Euclidean) &nbsp;&nbsp;|&nbsp;&nbsp; 
                e<sup>(d-1)r</sup> (Hyperbolic) &nbsp;&nbsp;|&nbsp;&nbsp; 
                sin<sup>d-1</sup>(r) (Spherical)
            </div>
            <div class="equation-label">
                Volume growth: polynomial, exponential, or bounded
            </div>
        </div>

        <p>
            This volume growth appears directly in the complexity bounds. More volume means more 
            potential interactions, but also more opportunity for hierarchical compression.
        </p>

        <div class="figure-container">
            <div class="figure-title">Figure 3 · Volume Growth and Ball Packing</div>
            <div class="figure-canvas" id="fig3-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Radius:</span>
                    <div class="slider-container">
                        <input type="range" id="radius-slider" min="1" max="5" step="0.5" value="2">
                        <span class="slider-value" id="radius-val">r = 2</span>
                    </div>
                </div>
                <div class="control-group">
                    <button class="btn" id="show-hierarchy">Show Hierarchy</button>
                </div>
            </div>
        </div>

        <h2>The Main Theorem</h2>

        <p>
            The extension of FMM to symmetric spaces is governed by the following theorem, which 
            quantifies complexity in terms of volume growth and representation theory.
        </p>

        <div class="theorem-box">
            <div class="theorem-header">Theorem 7.4 — Symmetric Space FMM</div>
            <p>
                Let <span class="symbol">M = G/K</span> be a Riemannian symmetric space of 
                non-compact type with rank <span class="symbol">r</span>. For 
                <span class="symbol">N</span> particles and accuracy <span class="symbol">ε</span>:
            </p>
            <p style="margin-top: 20px;">
                <strong>(a) Truncation:</strong> The truncation order 
                <span class="symbol">p = O(log(1/ε))</span> for exponentially decaying spherical 
                functions.
            </p>
            <p style="margin-top: 15px;">
                <strong>(b) Translation:</strong> Structure maps (M2M, M2L, L2L) are computed via 
                spherical function addition theorems in <span class="symbol">O(p<sup>r</sup>)</span> 
                operations.
            </p>
            <p style="margin-top: 15px;">
                <strong>(c) Complexity:</strong> Total complexity is 
                <span class="symbol">O(N · V(log N) · p<sup>r</sup>)</span> where 
                <span class="symbol">V(R)</span> is the volume growth function.
            </p>
            <p style="margin-top: 15px;">
                <strong>(d) Euclidean recovery:</strong> When <span class="symbol">G/K = ℝ<sup>d</sup></span>, 
                this reduces to the classical <span class="symbol">O(N log N)</span> bound.
            </p>
        </div>

        <h3>The Role of Rank</h3>

        <p>
            The <em>rank</em> of a symmetric space is the dimension of a maximal flat subspace. 
            It determines how many "independent directions" the geometry has:
        </p>

        <div class="table-container">
            <table>
                <tr><th>Space</th><th>Rank</th><th>Complexity Factor</th></tr>
                <tr><td>ℝ<sup>d</sup>, S<sup>d</sup>, ℍ<sup>d</sup></td><td>1</td><td>p</td></tr>
                <tr><td>SPD(n) = GL(n)/O(n)</td><td>n</td><td>p<sup>n</sup></td></tr>
                <tr><td>Grassmannian Gr(k,n)</td><td>min(k, n-k)</td><td>p<sup>min(k,n-k)</sup></td></tr>
            </table>
        </div>

        <p>
            Higher rank means more spherical harmonics at each level, increasing the cost of 
            translation operators. But the hierarchical structure still provides acceleration.
        </p>

        <div class="figure-container">
            <div class="figure-title">Figure 4 · Complexity Bounds by Geometry</div>
            <div class="figure-canvas" id="fig4-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">N (particles):</span>
                    <div class="slider-container">
                        <input type="range" id="n-slider" min="2" max="6" value="4">
                        <span class="slider-value" id="n-val">10⁴</span>
                    </div>
                </div>
                <div class="control-group">
                    <span class="control-label">Show:</span>
                    <button class="btn active" data-show="all">All Geometries</button>
                    <button class="btn" data-show="direct">vs Direct</button>
                </div>
            </div>
        </div>

        <h2>Applications</h2>

        <h3>Hyperbolic FMM</h3>

        <p>
            On hyperbolic space <span class="symbol">ℍ<sup>d</sup></span>, the volume grows 
            exponentially: <span class="symbol">Vol(B<sub>r</sub>) ∼ e<sup>(d-1)r</sup></span>. 
            This affects the tree structure: hierarchies must be deeper to achieve the same 
            separation ratios, but each level handles exponentially more particles.
        </p>

        <p>
            Applications include gravitational N-body in hyperbolic cosmologies and 
            Poincaré embeddings for hierarchical data in machine learning.
        </p>

        <h3>SPD Matrices</h3>

        <p>
            The space <span class="symbol">SPD(n)</span> of symmetric positive-definite 
            <span class="symbol">n × n</span> matrices appears throughout statistics (covariance 
            matrices), optimization (barrier functions), and medical imaging (diffusion tensors).
        </p>

        <p>
            FMM on <span class="symbol">SPD(n)</span> enables fast kernel methods with 
            Riemannian metrics, accelerating operations like Gaussian process regression 
            on covariance data.
        </p>

        <div class="figure-container">
            <div class="figure-title">Figure 5 · FMM on Hyperbolic Plane (Poincaré Disk Model)</div>
            <div class="figure-canvas" id="fig5-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Particles:</span>
                    <button class="btn active" data-count="20">20</button>
                    <button class="btn" data-count="50">50</button>
                    <button class="btn" data-count="100">100</button>
                </div>
                <div class="control-group">
                    <button class="btn" id="show-hyperbolic-hierarchy">Show Hierarchy</button>
                    <button class="btn" id="randomize-hyperbolic">Randomize</button>
                </div>
            </div>
        </div>

        <h2>The Categorical Picture, Complete</h2>

        <p>
            We now have the complete categorical picture of FMM:
        </p>

        <div class="series-summary">
            <h3 style="color: #a78bfa;">The Unified Framework</h3>
            
            <p style="margin-top: 20px;">
                <strong style="color: #4ade80;">Essay I — Prefactorization Algebras:</strong> 
                FMM forms a prefactorization algebra <span class="symbol">ℱ<sub>FMM</sub></span> 
                on the symmetric space <span class="symbol">M</span>. Structure maps encode 
                translation operators. Descent encodes hierarchical summation.
            </p>
            
            <p style="margin-top: 20px;">
                <strong style="color: #22d3ee;">Essay II — Swiss Cheese Operad:</strong> 
                The two-color structure (multipole/local) gives an 
                <span class="symbol">SC<sub>d</sub></span>-algebra structure. The asymmetry 
                (M2L exists, L2M doesn't) reflects the operadic module structure.
            </p>
            
            <p style="margin-top: 20px;">
                <strong style="color: #4ade80;">Essay III — Tropical Convergence:</strong> 
                Convergence regions are tropical cones. The tropical Grassmannian 
                <span class="symbol">Trop(M<sub>0,n</sub>)</span> indexes valid hierarchies.
            </p>
            
            <p style="margin-top: 20px;">
                <strong style="color: #fb923c;">Essay IV — Cluster Transitions:</strong> 
                Hierarchy changes are cluster mutations. The exchange relation guarantees 
                positivity (numerical stability). The cluster algebra structure governs 
                coarsening from trees to clusters.
            </p>
            
            <p style="margin-top: 20px;">
                <strong style="color: #a78bfa;">Essay V — Symmetric Spaces:</strong> 
                Everything extends to <span class="symbol">G/K</span> via spherical functions. 
                Volume growth determines complexity. Rank determines translation cost.
            </p>
        </div>

        <div class="insight-box">
            <p>
                <strong>The meta-theorem:</strong> Fast Multipole Methods are not merely 
                computational tricks for accelerating N-body calculations. They are 
                <em>computational manifestations</em> of deep categorical structures from 
                algebraic geometry, representation theory, and mathematical physics. The 
                efficiency of FMM follows from the rich algebraic structure of multipole 
                expansions—structure that exists independently of any computational application.
            </p>
        </div>

        <h2>Future Directions</h2>

        <p>
            The categorical framework opens several directions for further development:
        </p>

        <p>
            <strong>Higher categories.</strong> The factorization algebra perspective suggests 
            connections to higher categorical structures, potentially linking FMM to topological 
            field theory and derived algebraic geometry.
        </p>

        <p>
            <strong>Perfectoid methods.</strong> Recent breakthroughs in p-adic geometry 
            (perfectoid spaces) may provide new tools for analyzing FMM in arithmetic settings.
        </p>

        <p>
            <strong>Machine learning.</strong> The cluster algebra structure suggests new 
            architectures for hierarchical neural networks, with built-in guarantees of 
            positivity and numerical stability.
        </p>

        <div class="equation-box">
            <div class="equation">
                FMM = Prefactorization ∩ Operad ∩ Tropical ∩ Cluster ∩ Symmetric
            </div>
            <div class="equation-label">
                Five perspectives, one algorithm: the categorical unity of FMM
            </div>
        </div>

        <footer>
            <p style="color: #6b7280; font-size: 16px;">
                Essay V concludes the Categorical Foundations of FMM series.
            </p>
            <div class="nav-links">
                <span class="nav-link">← Essay IV: Cluster Transitions</span>
                <span class="nav-link" style="color: #6b7280;">Series Complete</span>
            </div>
        </footer>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Figure 1: Three Geometries
        (function() {
            const container = document.getElementById('fig1-canvas');
            const width = 860, height = 360;
            const svg = d3.select(container).append('svg').attr('viewBox', `0 0 ${width} ${height}`);
            
            let geometry = 'euclidean';
            
            function draw() {
                svg.selectAll('*').remove();
                svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const cx = width / 2, cy = height / 2;
                
                if (geometry === 'euclidean') {
                    // Grid
                    for (let x = cx - 200; x <= cx + 200; x += 40) {
                        svg.append('line').attr('x1', x).attr('y1', cy - 120).attr('x2', x).attr('y2', cy + 120)
                            .attr('stroke', '#4b5563').attr('stroke-width', 1);
                    }
                    for (let y = cy - 120; y <= cy + 120; y += 40) {
                        svg.append('line').attr('x1', cx - 200).attr('y1', y).attr('x2', cx + 200).attr('y2', y)
                            .attr('stroke', '#4b5563').attr('stroke-width', 1);
                    }
                    
                    // Geodesics (straight lines)
                    svg.append('line').attr('x1', cx - 150).attr('y1', cy - 80).attr('x2', cx + 150).attr('y2', cy + 80)
                        .attr('stroke', '#a78bfa').attr('stroke-width', 3);
                    svg.append('line').attr('x1', cx - 100).attr('y1', cy + 100).attr('x2', cx + 180).attr('y2', cy - 60)
                        .attr('stroke', '#22d3ee').attr('stroke-width', 3);
                    
                    svg.append('text').attr('x', cx).attr('y', height - 30).attr('text-anchor', 'middle')
                        .attr('fill', '#e8e6e3').attr('font-family', 'JetBrains Mono').attr('font-size', 14)
                        .text('Euclidean: κ = 0, parallel lines stay parallel');
                        
                } else if (geometry === 'spherical') {
                    // Sphere
                    const r = 120;
                    svg.append('circle').attr('cx', cx).attr('cy', cy).attr('r', r)
                        .attr('fill', 'none').attr('stroke', '#4b5563').attr('stroke-width', 2);
                    
                    // Great circles (geodesics)
                    svg.append('ellipse').attr('cx', cx).attr('cy', cy).attr('rx', r).attr('ry', 30)
                        .attr('fill', 'none').attr('stroke', '#a78bfa').attr('stroke-width', 3);
                    svg.append('ellipse').attr('cx', cx).attr('cy', cy).attr('rx', 30).attr('ry', r)
                        .attr('fill', 'none').attr('stroke', '#22d3ee').attr('stroke-width', 3);
                    
                    // Meridian lines converging
                    for (let a = -60; a <= 60; a += 30) {
                        const rad = a * Math.PI / 180;
                        svg.append('path')
                            .attr('d', `M ${cx + r * Math.sin(rad)} ${cy - r * Math.cos(rad)} Q ${cx} ${cy + 40} ${cx - r * Math.sin(rad)} ${cy + r * Math.cos(rad)}`)
                            .attr('fill', 'none').attr('stroke', '#6b7280').attr('stroke-width', 1);
                    }
                    
                    svg.append('text').attr('x', cx).attr('y', height - 30).attr('text-anchor', 'middle')
                        .attr('fill', '#e8e6e3').attr('font-family', 'JetBrains Mono').attr('font-size', 14)
                        .text('Spherical: κ > 0, geodesics converge (great circles)');
                        
                } else {
                    // Poincaré disk (hyperbolic)
                    const r = 130;
                    svg.append('circle').attr('cx', cx).attr('cy', cy).attr('r', r)
                        .attr('fill', 'none').attr('stroke', '#4b5563').attr('stroke-width', 2);
                    
                    // Geodesics (circular arcs perpendicular to boundary)
                    const arcPath = (x1, y1, x2, y2, curve) => {
                        return `M ${x1} ${y1} Q ${curve} ${x2} ${y2}`;
                    };
                    
                    svg.append('line').attr('x1', cx - r).attr('y1', cy).attr('x2', cx + r).attr('y2', cy)
                        .attr('stroke', '#a78bfa').attr('stroke-width', 3);
                    
                    // Curved geodesic
                    svg.append('path')
                        .attr('d', `M ${cx - 80} ${cy - r * 0.8} Q ${cx - 150} ${cy} ${cx - 80} ${cy + r * 0.8}`)
                        .attr('fill', 'none').attr('stroke', '#22d3ee').attr('stroke-width', 3);
                    svg.append('path')
                        .attr('d', `M ${cx + 50} ${cy - r * 0.9} Q ${cx + 180} ${cy} ${cx + 50} ${cy + r * 0.9}`)
                        .attr('fill', 'none').attr('stroke', '#4ade80').attr('stroke-width', 3);
                    
                    svg.append('text').attr('x', cx).attr('y', height - 30).attr('text-anchor', 'middle')
                        .attr('fill', '#e8e6e3').attr('font-family', 'JetBrains Mono').attr('font-size', 14)
                        .text('Hyperbolic: κ < 0, geodesics diverge');
                }
            }
            
            draw();
            
            document.querySelectorAll('[data-geom]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-geom]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    geometry = btn.dataset.geom;
                    draw();
                });
            });
        })();

        // Figure 2: Spherical Functions
        (function() {
            const container = document.getElementById('fig2-canvas');
            const width = 860, height = 340;
            const svg = d3.select(container).append('svg').attr('viewBox', `0 0 ${width} ${height}`);
            
            let mode = 2;
            let space = 'sphere';
            
            function draw() {
                svg.selectAll('*').remove();
                svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const cx = width / 2, cy = height / 2;
                const plotWidth = 600, plotHeight = 200;
                const plotLeft = (width - plotWidth) / 2;
                
                // Axes
                svg.append('line').attr('x1', plotLeft).attr('y1', cy).attr('x2', plotLeft + plotWidth).attr('y2', cy)
                    .attr('stroke', '#4b5563').attr('stroke-width', 1);
                svg.append('line').attr('x1', plotLeft).attr('y1', cy - plotHeight/2).attr('x2', plotLeft).attr('y2', cy + plotHeight/2)
                    .attr('stroke', '#4b5563').attr('stroke-width', 1);
                
                // Generate spherical function data
                const points = [];
                const n = 200;
                
                for (let i = 0; i <= n; i++) {
                    let x, y;
                    if (space === 'sphere') {
                        // Legendre polynomial-like
                        x = -1 + (2 * i / n);
                        y = Math.cos(mode * Math.acos(x)); // Chebyshev approximation
                    } else {
                        // Hyperbolic: exponentially decaying
                        x = i / n * 5;
                        y = Math.exp(-mode * x) * Math.cos(mode * x);
                    }
                    points.push({ x, y });
                }
                
                // Scale
                const xScale = space === 'sphere' 
                    ? d3.scaleLinear().domain([-1, 1]).range([plotLeft + 20, plotLeft + plotWidth - 20])
                    : d3.scaleLinear().domain([0, 5]).range([plotLeft + 20, plotLeft + plotWidth - 20]);
                const yScale = d3.scaleLinear().domain([-1.2, 1.2]).range([cy + plotHeight/2 - 20, cy - plotHeight/2 + 20]);
                
                // Draw curve
                const line = d3.line().x(d => xScale(d.x)).y(d => yScale(d.y)).curve(d3.curveBasis);
                svg.append('path').attr('d', line(points))
                    .attr('fill', 'none').attr('stroke', '#a78bfa').attr('stroke-width', 3);
                
                // Labels
                svg.append('text').attr('x', cx).attr('y', 40).attr('text-anchor', 'middle')
                    .attr('fill', '#e8e6e3').attr('font-family', 'JetBrains Mono').attr('font-size', 14)
                    .text(space === 'sphere' ? `Spherical harmonic Y${mode}(θ)` : `Hyperbolic spherical function φ${mode}(r)`);
                
                svg.append('text').attr('x', plotLeft + plotWidth + 10).attr('y', cy + 5)
                    .attr('fill', '#9ca3af').attr('font-family', 'JetBrains Mono').attr('font-size', 11)
                    .text(space === 'sphere' ? 'cos θ' : 'r');
            }
            
            draw();
            
            document.getElementById('mode-slider').addEventListener('input', (e) => {
                mode = parseInt(e.target.value);
                document.getElementById('mode-val').textContent = `λ = ${mode}`;
                draw();
            });
            
            document.querySelectorAll('[data-space]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-space]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    space = btn.dataset.space;
                    draw();
                });
            });
        })();

        // Figure 3: Volume Growth
        (function() {
            const container = document.getElementById('fig3-canvas');
            const width = 860, height = 340;
            const svg = d3.select(container).append('svg').attr('viewBox', `0 0 ${width} ${height}`);
            
            let radius = 2;
            let showHierarchy = false;
            
            function draw() {
                svg.selectAll('*').remove();
                svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                // Three panels
                const panels = [
                    { x: 150, label: 'Euclidean', color: '#4ade80', vol: r => Math.pow(r, 2) },
                    { x: 430, label: 'Hyperbolic', color: '#a78bfa', vol: r => Math.exp(r) },
                    { x: 710, label: 'Spherical', color: '#22d3ee', vol: r => Math.pow(Math.sin(Math.min(r, Math.PI/2)), 2) }
                ];
                
                panels.forEach(panel => {
                    const cy = height / 2 - 20;
                    const maxR = 80;
                    const scaledR = radius / 5 * maxR;
                    
                    // Background circle (max)
                    svg.append('circle').attr('cx', panel.x).attr('cy', cy).attr('r', maxR)
                        .attr('fill', 'none').attr('stroke', '#333').attr('stroke-width', 1);
                    
                    // Volume circle
                    svg.append('circle').attr('cx', panel.x).attr('cy', cy).attr('r', scaledR)
                        .attr('fill', `${panel.color}30`).attr('stroke', panel.color).attr('stroke-width', 2);
                    
                    // Label
                    svg.append('text').attr('x', panel.x).attr('y', 40).attr('text-anchor', 'middle')
                        .attr('fill', panel.color).attr('font-family', 'JetBrains Mono').attr('font-size', 13).text(panel.label);
                    
                    // Volume value
                    const vol = panel.vol(radius).toFixed(2);
                    svg.append('text').attr('x', panel.x).attr('y', height - 40).attr('text-anchor', 'middle')
                        .attr('fill', '#e8e6e3').attr('font-family', 'JetBrains Mono').attr('font-size', 12)
                        .text(`Vol ∝ ${vol}`);
                    
                    if (showHierarchy) {
                        // Show hierarchical subdivision
                        const subdiv = Math.ceil(radius);
                        for (let i = 1; i < subdiv; i++) {
                            const subR = scaledR * i / subdiv;
                            svg.append('circle').attr('cx', panel.x).attr('cy', cy).attr('r', subR)
                                .attr('fill', 'none').attr('stroke', panel.color).attr('stroke-width', 1)
                                .attr('stroke-dasharray', '3,3');
                        }
                    }
                });
            }
            
            draw();
            
            document.getElementById('radius-slider').addEventListener('input', (e) => {
                radius = parseFloat(e.target.value);
                document.getElementById('radius-val').textContent = `r = ${radius}`;
                draw();
            });
            
            document.getElementById('show-hierarchy').addEventListener('click', () => {
                showHierarchy = !showHierarchy;
                draw();
            });
        })();

        // Figure 4: Complexity Bounds
        (function() {
            const container = document.getElementById('fig4-canvas');
            const width = 860, height = 340;
            const svg = d3.select(container).append('svg').attr('viewBox', `0 0 ${width} ${height}`);
            
            let logN = 4;
            let showMode = 'all';
            
            function draw() {
                svg.selectAll('*').remove();
                svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const N = Math.pow(10, logN);
                const plotWidth = 700, plotHeight = 220;
                const plotLeft = 100, plotTop = 60;
                
                // Complexity functions
                const complexities = [
                    { name: 'Euclidean FMM', fn: n => n * Math.log(n), color: '#4ade80' },
                    { name: 'Hyperbolic FMM', fn: n => n * Math.log(n) * Math.log(n), color: '#a78bfa' },
                    { name: 'SPD(3) FMM', fn: n => n * Math.log(n) * Math.pow(Math.log(n), 0.5), color: '#22d3ee' }
                ];
                
                if (showMode === 'direct') {
                    complexities.push({ name: 'Direct O(N²)', fn: n => n * n / 1000, color: '#ef4444' });
                }
                
                // Scales
                const xScale = d3.scaleLog().domain([100, 1e7]).range([plotLeft, plotLeft + plotWidth]);
                const maxY = showMode === 'direct' ? N * N / 1000 : N * Math.log(N) * Math.log(N) * 2;
                const yScale = d3.scaleLinear().domain([0, maxY]).range([plotTop + plotHeight, plotTop]);
                
                // Axes
                svg.append('line').attr('x1', plotLeft).attr('y1', plotTop + plotHeight)
                    .attr('x2', plotLeft + plotWidth).attr('y2', plotTop + plotHeight)
                    .attr('stroke', '#4b5563').attr('stroke-width', 1);
                svg.append('line').attr('x1', plotLeft).attr('y1', plotTop)
                    .attr('x2', plotLeft).attr('y2', plotTop + plotHeight)
                    .attr('stroke', '#4b5563').attr('stroke-width', 1);
                
                // Draw curves
                complexities.forEach(c => {
                    const points = [];
                    for (let n = 100; n <= 1e7; n *= 1.5) {
                        points.push({ x: n, y: c.fn(n) });
                    }
                    
                    const line = d3.line().x(d => xScale(d.x)).y(d => Math.max(plotTop, yScale(d.y)));
                    svg.append('path').attr('d', line(points))
                        .attr('fill', 'none').attr('stroke', c.color).attr('stroke-width', 2);
                });
                
                // Current N marker
                svg.append('line').attr('x1', xScale(N)).attr('y1', plotTop)
                    .attr('x2', xScale(N)).attr('y2', plotTop + plotHeight)
                    .attr('stroke', '#fbbf24').attr('stroke-width', 2).attr('stroke-dasharray', '5,5');
                
                // Legend
                complexities.forEach((c, i) => {
                    const ly = 30 + i * 18;
                    svg.append('line').attr('x1', plotLeft + 20).attr('y1', ly).attr('x2', plotLeft + 50).attr('y2', ly)
                        .attr('stroke', c.color).attr('stroke-width', 2);
                    svg.append('text').attr('x', plotLeft + 60).attr('y', ly + 4)
                        .attr('fill', c.color).attr('font-family', 'JetBrains Mono').attr('font-size', 10).text(c.name);
                });
                
                // Labels
                svg.append('text').attr('x', plotLeft + plotWidth / 2).attr('y', height - 15).attr('text-anchor', 'middle')
                    .attr('fill', '#9ca3af').attr('font-family', 'JetBrains Mono').attr('font-size', 11).text('N (particles)');
            }
            
            draw();
            
            document.getElementById('n-slider').addEventListener('input', (e) => {
                logN = parseInt(e.target.value);
                document.getElementById('n-val').textContent = `10^${logN}`;
                draw();
            });
            
            document.querySelectorAll('[data-show]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-show]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    showMode = btn.dataset.show;
                    draw();
                });
            });
        })();

        // Figure 5: Hyperbolic FMM
        (function() {
            const container = document.getElementById('fig5-canvas');
            const width = 860, height = 400;
            const svg = d3.select(container).append('svg').attr('viewBox', `0 0 ${width} ${height}`);
            
            let particleCount = 20;
            let showHierarchy = false;
            let particles = [];
            
            function generateParticles(n) {
                particles = [];
                for (let i = 0; i < n; i++) {
                    // Random point in Poincaré disk
                    const r = Math.sqrt(Math.random()) * 0.9; // Bias toward center
                    const theta = Math.random() * 2 * Math.PI;
                    particles.push({ x: r * Math.cos(theta), y: r * Math.sin(theta) });
                }
            }
            
            generateParticles(particleCount);
            
            function draw() {
                svg.selectAll('*').remove();
                svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const cx = width / 2, cy = height / 2;
                const diskR = 160;
                
                // Poincaré disk boundary
                svg.append('circle').attr('cx', cx).attr('cy', cy).attr('r', diskR)
                    .attr('fill', 'rgba(139, 92, 246, 0.05)').attr('stroke', '#a78bfa').attr('stroke-width', 2);
                
                // Concentric hyperbolic circles (for hierarchy visualization)
                if (showHierarchy) {
                    const hyperbolicRadii = [0.3, 0.5, 0.7, 0.85];
                    hyperbolicRadii.forEach((hr, i) => {
                        svg.append('circle').attr('cx', cx).attr('cy', cy).attr('r', hr * diskR)
                            .attr('fill', 'none').attr('stroke', '#22d3ee')
                            .attr('stroke-width', 1).attr('stroke-dasharray', '5,5').attr('opacity', 0.5);
                    });
                    
                    // Radial divisions
                    for (let a = 0; a < 2 * Math.PI; a += Math.PI / 4) {
                        svg.append('line').attr('x1', cx).attr('y1', cy)
                            .attr('x2', cx + diskR * Math.cos(a)).attr('y2', cy + diskR * Math.sin(a))
                            .attr('stroke', '#22d3ee').attr('stroke-width', 1).attr('stroke-dasharray', '3,3').attr('opacity', 0.3);
                    }
                }
                
                // Particles
                particles.forEach(p => {
                    const px = cx + p.x * diskR;
                    const py = cy + p.y * diskR;
                    
                    svg.append('circle').attr('cx', px).attr('cy', py).attr('r', 5)
                        .attr('fill', '#4ade80');
                });
                
                // Info
                svg.append('text').attr('x', cx).attr('y', height - 30).attr('text-anchor', 'middle')
                    .attr('fill', '#9ca3af').attr('font-family', 'JetBrains Mono').attr('font-size', 12)
                    .text(`${particleCount} particles in hyperbolic plane (Poincaré disk model)`);
            }
            
            draw();
            
            document.querySelectorAll('[data-count]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-count]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    particleCount = parseInt(btn.dataset.count);
                    generateParticles(particleCount);
                    draw();
                });
            });
            
            document.getElementById('show-hyperbolic-hierarchy').addEventListener('click', () => {
                showHierarchy = !showHierarchy;
                draw();
            });
            
            document.getElementById('randomize-hyperbolic').addEventListener('click', () => {
                generateParticles(particleCount);
                draw();
            });
        })();
    </script>
</body>
</html>
