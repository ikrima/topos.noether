<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tropical Convergence | Categorical Foundations of FMM</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,600;1,300;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Crimson Pro', serif;
            font-size: 19px;
            line-height: 1.7;
            color: #e8e6e3;
            background: #0a0a0f;
        }
        .container { max-width: 920px; margin: 0 auto; padding: 80px 40px; }
        header { margin-bottom: 80px; padding-bottom: 40px; border-bottom: 1px solid rgba(74, 222, 128, 0.3); }
        .series-label { font-family: 'JetBrains Mono', monospace; font-size: 11px; text-transform: uppercase; letter-spacing: 3px; color: #4ade80; margin-bottom: 20px; }
        h1 { font-size: 52px; font-weight: 300; line-height: 1.15; margin-bottom: 24px; background: linear-gradient(135deg, #4ade80, #fbbf24); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
        .subtitle { font-size: 22px; font-style: italic; color: #9ca3af; font-weight: 300; }
        h2 { font-size: 32px; font-weight: 400; margin: 70px 0 30px; color: #4ade80; }
        h3 { font-size: 24px; font-weight: 400; margin: 50px 0 20px; color: #fbbf24; }
        p { margin-bottom: 24px; text-align: justify; }
        .lead { font-size: 22px; line-height: 1.8; color: #d1d5db; margin-bottom: 40px; }
        .figure-container { margin: 50px 0; background: linear-gradient(145deg, rgba(30, 27, 46, 0.95), rgba(20, 18, 35, 0.98)); border-radius: 16px; padding: 30px; border: 1px solid rgba(74, 222, 128, 0.2); box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4); }
        .figure-title { font-family: 'JetBrains Mono', monospace; font-size: 12px; text-transform: uppercase; letter-spacing: 2px; color: #4ade80; margin-bottom: 20px; }
        .figure-canvas { background: rgba(10, 10, 20, 0.8); border-radius: 12px; margin-bottom: 20px; }
        svg { display: block; width: 100%; height: auto; }
        .controls { display: flex; flex-wrap: wrap; gap: 15px; padding-top: 15px; border-top: 1px solid rgba(74, 222, 128, 0.2); }
        .control-group { display: flex; align-items: center; gap: 10px; }
        .control-label { font-family: 'JetBrains Mono', monospace; font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #9ca3af; }
        .btn { font-family: 'JetBrains Mono', monospace; font-size: 11px; padding: 8px 16px; border: 1px solid rgba(74, 222, 128, 0.4); background: rgba(74, 222, 128, 0.1); color: #4ade80; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; }
        .btn:hover { background: rgba(74, 222, 128, 0.25); border-color: #4ade80; }
        .btn.active { background: rgba(74, 222, 128, 0.4); border-color: #4ade80; color: #fff; }
        .slider-container { display: flex; align-items: center; gap: 12px; }
        input[type="range"] { -webkit-appearance: none; width: 140px; height: 4px; background: rgba(74, 222, 128, 0.3); border-radius: 2px; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; background: #4ade80; border-radius: 50%; cursor: pointer; }
        .slider-value { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: #fbbf24; min-width: 40px; }
        .equation-box { background: linear-gradient(135deg, rgba(74, 222, 128, 0.1), rgba(251, 191, 36, 0.1)); border: 1px solid rgba(74, 222, 128, 0.3); border-radius: 12px; padding: 30px; margin: 40px 0; text-align: center; }
        .equation { font-family: 'JetBrains Mono', monospace; font-size: 18px; color: #4ade80; line-height: 2; }
        .equation-label { font-size: 14px; color: #9ca3af; margin-top: 15px; font-style: italic; }
        .definition-box { background: rgba(74, 222, 128, 0.08); border-left: 3px solid #4ade80; padding: 25px 30px; margin: 35px 0; border-radius: 0 12px 12px 0; }
        .definition-header { font-family: 'JetBrains Mono', monospace; font-size: 12px; text-transform: uppercase; letter-spacing: 2px; color: #4ade80; margin-bottom: 12px; }
        .theorem-box { background: linear-gradient(135deg, rgba(251, 191, 36, 0.08), rgba(74, 222, 128, 0.08)); border: 1px solid rgba(251, 191, 36, 0.3); padding: 25px 30px; margin: 35px 0; border-radius: 12px; }
        .theorem-header { font-family: 'JetBrains Mono', monospace; font-size: 12px; text-transform: uppercase; letter-spacing: 2px; color: #fbbf24; margin-bottom: 12px; }
        .insight-box { background: rgba(139, 92, 246, 0.08); border: 1px solid rgba(139, 92, 246, 0.3); padding: 25px 30px; margin: 35px 0; border-radius: 12px; position: relative; }
        .insight-box::before { content: "◆"; position: absolute; top: -12px; left: 25px; background: #0a0a0f; padding: 0 10px; color: #a78bfa; font-size: 18px; }
        .table-container { overflow-x: auto; margin: 30px 0; }
        table { width: 100%; border-collapse: collapse; font-family: 'JetBrains Mono', monospace; font-size: 14px; }
        th, td { padding: 12px 16px; text-align: center; border: 1px solid rgba(74, 222, 128, 0.2); }
        th { background: rgba(74, 222, 128, 0.15); color: #4ade80; }
        td { color: #d1d5db; }
        .symbol { font-family: 'JetBrains Mono', monospace; color: #fbbf24; }
        footer { margin-top: 100px; padding-top: 40px; border-top: 1px solid rgba(74, 222, 128, 0.2); text-align: center; }
        .nav-links { display: flex; justify-content: space-between; margin-top: 30px; }
        .nav-link { font-family: 'JetBrains Mono', monospace; font-size: 12px; color: #4ade80; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="series-label">Categorical Foundations of FMM — Essay III</div>
            <h1>Tropical Convergence</h1>
            <p class="subtitle">Where algebra meets geometry: the tropical variety governing FMM hierarchies</p>
        </header>

        <p class="lead">
            When does a multipole expansion converge? The answer is geometric: convergence regions 
            correspond to cones in a <em>tropical variety</em>. The combinatorics of FMM tree 
            structures is secretly the combinatorics of tropical moduli spaces.
        </p>

        <h2>From Analysis to Combinatorics</h2>

        <p>
            The classical FMM analysis asks: for a given configuration of particles, which tree 
            hierarchies yield convergent expansions? This is an analytic question about radii of 
            convergence. But it has a beautiful combinatorial answer encoded in tropical geometry.
        </p>

        <div class="definition-box">
            <div class="definition-header">Definition — Binary Tree Topology</div>
            <p>
                A <strong>binary tree topology</strong> on <span class="symbol">n</span> labeled 
                leaves is an unrooted binary tree <span class="symbol">T</span> with leaves labeled 
                <span class="symbol">1, …, n</span>. The set of such topologies is denoted
                <span class="symbol">Tree<sub>n</sub></span>, with cardinality 
                <span class="symbol">(2n-5)!!</span> (double factorial).
            </p>
        </div>

        <div class="figure-container">
            <div class="figure-title">Figure 1 · Binary Tree Topologies for n Particles</div>
            <div class="figure-canvas" id="fig1-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Particles n:</span>
                    <button class="btn" data-n="4">4</button>
                    <button class="btn active" data-n="5">5</button>
                    <button class="btn" data-n="6">6</button>
                </div>
                <div class="control-group">
                    <span class="control-label">Tree:</span>
                    <button class="btn" id="prev-tree">◀</button>
                    <span class="slider-value" id="tree-index">1 / 15</span>
                    <button class="btn" id="next-tree">▶</button>
                </div>
            </div>
        </div>

        <h3>Splits and Separations</h3>

        <p>
            Each internal edge of a tree defines a <em>split</em>: a bipartition of the particles 
            into two groups. The FMM converges when these groups are <em>well-separated</em>—the 
            distance between group centers exceeds the group diameters by a factor α.
        </p>

        <div class="definition-box">
            <div class="definition-header">Definition — Split</div>
            <p>
                A <strong>split</strong> of <span class="symbol">{1, …, n}</span> is a bipartition 
                <span class="symbol">{A, B}</span> with <span class="symbol">|A|, |B| ≥ 2</span>.
                Two splits are <strong>compatible</strong> if one of <span class="symbol">A₁∩A₂, 
                A₁∩B₂, B₁∩A₂, B₁∩B₂</span> is empty.
            </p>
        </div>

        <h2>The Tropical Semiring</h2>

        <p>
            Tropical geometry replaces ordinary arithmetic with "min-plus" operations, revealing 
            hidden combinatorial structures in algebraic geometry.
        </p>

        <div class="equation-box">
            <div class="equation">
                a ⊕ b = min(a, b) &nbsp;&nbsp;&nbsp;&nbsp; a ⊙ b = a + b
            </div>
            <div class="equation-label">
                Tropical arithmetic: addition becomes minimum, multiplication becomes addition
            </div>
        </div>

        <div class="figure-container">
            <div class="figure-title">Figure 2 · Tropical Arithmetic and Polynomials</div>
            <div class="figure-canvas" id="fig2-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">a:</span>
                    <div class="slider-container">
                        <input type="range" id="trop-a" min="0" max="10" value="3">
                        <span class="slider-value" id="trop-a-val">3</span>
                    </div>
                </div>
                <div class="control-group">
                    <span class="control-label">b:</span>
                    <div class="slider-container">
                        <input type="range" id="trop-b" min="0" max="10" value="7">
                        <span class="slider-value" id="trop-b-val">7</span>
                    </div>
                </div>
                <div class="control-group">
                    <button class="btn" id="show-poly">Show Tropical Polynomial</button>
                </div>
            </div>
        </div>

        <p>
            The key operation is <em>tropicalization</em>: taking logarithms of coordinates transforms 
            multiplicative relations into additive ones, and algebraic curves become piecewise-linear.
        </p>

        <div class="equation-box">
            <div class="equation">
                τᵢⱼ = log|zᵢ - zⱼ|
            </div>
            <div class="equation-label">
                Tropical coordinates: logarithms of pairwise distances
            </div>
        </div>

        <h2>The Tropical Grassmannian</h2>

        <div class="theorem-box">
            <div class="theorem-header">Theorem (Speyer–Sturmfels)</div>
            <p>
                The tropical Grassmannian <span class="symbol">Trop(Gr(2,n))</span> is the space of 
                <strong>phylogenetic trees</strong> with <span class="symbol">n</span> labeled leaves:
                maximal cones correspond to binary tree topologies (<span class="symbol">(2n-5)!!</span> 
                in number), lower-dimensional cones to trees with higher-valence vertices.
            </p>
        </div>

        <div class="figure-container">
            <div class="figure-title">Figure 3 · The Tropical Fan for n = 4</div>
            <div class="figure-canvas" id="fig3-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Cone:</span>
                    <button class="btn active" data-cone="all">All</button>
                    <button class="btn" data-cone="1">(12)(34)</button>
                    <button class="btn" data-cone="2">(13)(24)</button>
                    <button class="btn" data-cone="3">(14)(23)</button>
                </div>
                <div class="control-group">
                    <button class="btn" id="animate-fan">▶ Animate</button>
                </div>
            </div>
        </div>

        <h2>FMM Convergence as Tropical Condition</h2>

        <p>
            The convergence condition for a split <span class="symbol">{A, B}</span> is:
        </p>

        <div class="equation-box">
            <div class="equation">
                |c<sub>A</sub> - c<sub>B</sub>| > α · max(d<sub>A</sub>, d<sub>B</sub>)
            </div>
            <div class="equation-label">
                Well-separateness: cluster distance exceeds α times max diameter
            </div>
        </div>

        <p>
            Taking logarithms transforms this into a <em>tropical half-space condition</em>:
        </p>

        <div class="equation-box">
            <div class="equation">
                log|c<sub>A</sub> - c<sub>B</sub>| > log α + max(log d<sub>A</sub>, log d<sub>B</sub>)
            </div>
            <div class="equation-label">
                In tropical coordinates: an additive (linear) inequality
            </div>
        </div>

        <div class="theorem-box">
            <div class="theorem-header">Theorem 5.4 — Tropical–Convergence Correspondence</div>
            <p>
                <strong>(a)</strong> The set <span class="symbol">Tree<sub>n</sub></span> is in bijection 
                with maximal cones of <span class="symbol">Trop(M<sub>0,n</sub>)</span>.
            </p>
            <p style="margin-top: 10px;">
                <strong>(b)</strong> For each tree <span class="symbol">T</span>, the convergence region 
                <span class="symbol">Ω<sub>T</sub></span> equals the preimage of the corresponding cone.
            </p>
            <p style="margin-top: 10px;">
                <strong>(c)</strong> Codimension-<span class="symbol">k</span> boundaries correspond to 
                configurations with <span class="symbol">k+1</span> simultaneous valid hierarchies.
            </p>
        </div>

        <div class="figure-container">
            <div class="figure-title">Figure 4 · Convergence Regions as Tropical Cones</div>
            <div class="figure-canvas" id="fig4-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">View:</span>
                    <button class="btn active" data-view="config">Configuration</button>
                    <button class="btn" data-view="tropical">Tropical Space</button>
                    <button class="btn" data-view="both">Side by Side</button>
                </div>
                <div class="control-group">
                    <button class="btn" id="randomize">Randomize</button>
                </div>
            </div>
        </div>

        <h3>The Case n = 4</h3>

        <div class="table-container">
            <table>
                <tr><th>Tree</th><th>Split</th><th>Convergence Condition</th></tr>
                <tr><td>T₁</td><td>(12)(34)</td><td>|c₁₂ - c₃₄| > α · max(d₁₂, d₃₄)</td></tr>
                <tr><td>T₂</td><td>(13)(24)</td><td>|c₁₃ - c₂₄| > α · max(d₁₃, d₂₄)</td></tr>
                <tr><td>T₃</td><td>(14)(23)</td><td>|c₁₄ - c₂₃| > α · max(d₁₄, d₂₃)</td></tr>
            </table>
        </div>

        <div class="figure-container">
            <div class="figure-title">Figure 5 · Interactive: Drag Particles to Explore Cones</div>
            <div class="figure-canvas" id="fig5-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Preset:</span>
                    <button class="btn active" data-preset="generic">Generic</button>
                    <button class="btn" data-preset="boundary">Boundary</button>
                    <button class="btn" data-preset="degenerate">Degenerate</button>
                </div>
                <div class="control-group">
                    <button class="btn" id="enable-drag">Enable Drag</button>
                </div>
            </div>
        </div>

        <h2>The General Structure</h2>

        <div class="table-container">
            <table>
                <tr><th>n</th><th>dim Trop</th><th>Maximal Cones</th><th>Internal Edges</th></tr>
                <tr><td>4</td><td>1</td><td>3</td><td>1</td></tr>
                <tr><td>5</td><td>2</td><td>15</td><td>2</td></tr>
                <tr><td>6</td><td>3</td><td>105</td><td>3</td></tr>
                <tr><td>7</td><td>4</td><td>945</td><td>4</td></tr>
                <tr><td>n</td><td>n-3</td><td>(2n-5)!!</td><td>n-3</td></tr>
            </table>
        </div>

        <div class="insight-box">
            <p>
                <strong>Why tropical geometry?</strong> The tropical perspective reveals that FMM 
                convergence is fundamentally <em>combinatorial</em>. The question "which hierarchy 
                works?" becomes "which cone contains this point?"—a question about relative orderings 
                of distances, not their precise values.
            </p>
        </div>

        <div class="equation-box">
            <div class="equation">
                Tree<sub>n</sub> ↔ MaxCones(Trop(M<sub>0,n</sub>))
            </div>
            <div class="equation-label">
                The central correspondence: FMM hierarchies are tropical cones
            </div>
        </div>

        <footer>
            <p style="color: #6b7280; font-size: 16px;">
                Essay III of the Categorical Foundations series.
            </p>
            <div class="nav-links">
                <span class="nav-link">← Essay II: The Swiss Cheese Operad</span>
                <span class="nav-link">Essay IV: Cluster Transitions →</span>
            </div>
        </footer>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Figure 1: Tree Topologies
        (function() {
            const container = document.getElementById('fig1-canvas');
            const width = 860, height = 380;
            const svg = d3.select(container).append('svg').attr('viewBox', `0 0 ${width} ${height}`);
            
            let n = 5, treeIndex = 0;
            const treeCounts = { 4: 3, 5: 15, 6: 105 };
            
            function draw() {
                svg.selectAll('*').remove();
                svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const count = treeCounts[n];
                document.getElementById('tree-index').textContent = `${treeIndex + 1} / ${count}`;
                
                const cx = width / 2, cy = height / 2;
                const leafR = 130, leaves = [];
                
                for (let i = 0; i < n; i++) {
                    const angle = -Math.PI/2 + (2 * Math.PI * i / n);
                    leaves.push({ x: cx + leafR * Math.cos(angle), y: cy + leafR * Math.sin(angle), label: (i + 1).toString() });
                }
                
                // Draw simple tree structure based on index
                const colors = ['#4ade80', '#fbbf24', '#a78bfa', '#f472b6', '#22d3ee'];
                
                // Connect leaves to center with internal structure hint
                leaves.forEach((leaf, i) => {
                    const midX = cx + (leaf.x - cx) * 0.4;
                    const midY = cy + (leaf.y - cy) * 0.4;
                    svg.append('line').attr('x1', leaf.x).attr('y1', leaf.y).attr('x2', midX).attr('y2', midY)
                        .attr('stroke', '#4ade80').attr('stroke-width', 2);
                });
                
                svg.append('circle').attr('cx', cx).attr('cy', cy).attr('r', 8).attr('fill', '#fbbf24');
                
                leaves.forEach((leaf, i) => {
                    svg.append('circle').attr('cx', leaf.x).attr('cy', leaf.y).attr('r', 20)
                        .attr('fill', 'rgba(74, 222, 128, 0.2)').attr('stroke', colors[i % colors.length]).attr('stroke-width', 2);
                    svg.append('text').attr('x', leaf.x).attr('y', leaf.y + 5).attr('text-anchor', 'middle')
                        .attr('fill', colors[i % colors.length]).attr('font-family', 'JetBrains Mono').attr('font-size', 14).text(leaf.label);
                });
                
                svg.append('text').attr('x', width / 2).attr('y', height - 20).attr('text-anchor', 'middle')
                    .attr('fill', '#9ca3af').attr('font-family', 'JetBrains Mono').attr('font-size', 12)
                    .text(`n = ${n}: (2×${n}-5)!! = ${count} tree topologies`);
            }
            
            draw();
            
            document.querySelectorAll('[data-n]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-n]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    n = parseInt(btn.dataset.n);
                    treeIndex = 0;
                    draw();
                });
            });
            
            document.getElementById('prev-tree').addEventListener('click', () => { treeIndex = (treeIndex - 1 + treeCounts[n]) % treeCounts[n]; draw(); });
            document.getElementById('next-tree').addEventListener('click', () => { treeIndex = (treeIndex + 1) % treeCounts[n]; draw(); });
        })();

        // Figure 2: Tropical Arithmetic
        (function() {
            const container = document.getElementById('fig2-canvas');
            const width = 860, height = 320;
            const svg = d3.select(container).append('svg').attr('viewBox', `0 0 ${width} ${height}`);
            
            let a = 3, b = 7, showPoly = false;
            
            function draw() {
                svg.selectAll('*').remove();
                svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const cy = showPoly ? 90 : height / 2;
                
                svg.append('text').attr('x', 200).attr('y', cy - 40).attr('text-anchor', 'middle')
                    .attr('fill', '#4ade80').attr('font-family', 'JetBrains Mono').attr('font-size', 16).text('Tropical Addition');
                svg.append('text').attr('x', 200).attr('y', cy).attr('text-anchor', 'middle')
                    .attr('fill', '#e8e6e3').attr('font-family', 'JetBrains Mono').attr('font-size', 18)
                    .text(`${a} ⊕ ${b} = min(${a}, ${b}) = ${Math.min(a, b)}`);
                
                svg.append('text').attr('x', 660).attr('y', cy - 40).attr('text-anchor', 'middle')
                    .attr('fill', '#fbbf24').attr('font-family', 'JetBrains Mono').attr('font-size', 16).text('Tropical Multiplication');
                svg.append('text').attr('x', 660).attr('y', cy).attr('text-anchor', 'middle')
                    .attr('fill', '#e8e6e3').attr('font-family', 'JetBrains Mono').attr('font-size', 18)
                    .text(`${a} ⊙ ${b} = ${a} + ${b} = ${a + b}`);
                
                if (showPoly) {
                    const polyY = 220, polyW = 500, polyL = (width - polyW) / 2;
                    svg.append('text').attr('x', width / 2).attr('y', polyY - 60).attr('text-anchor', 'middle')
                        .attr('fill', '#a78bfa').attr('font-family', 'JetBrains Mono').attr('font-size', 13)
                        .text('Tropical polynomial: f(x) = a ⊕ (b ⊙ x) = min(a, b + x)');
                    
                    const xScale = d3.scaleLinear().domain([-4, 8]).range([polyL, polyL + polyW]);
                    const yScale = d3.scaleLinear().domain([12, -2]).range([polyY - 30, polyY + 70]);
                    const kink = a - b;
                    
                    svg.append('line').attr('x1', polyL).attr('y1', yScale(0)).attr('x2', polyL + polyW).attr('y2', yScale(0))
                        .attr('stroke', '#4b5563').attr('stroke-width', 1);
                    svg.append('line').attr('x1', xScale(-4)).attr('y1', yScale(a)).attr('x2', xScale(kink)).attr('y2', yScale(a))
                        .attr('stroke', '#4ade80').attr('stroke-width', 3);
                    svg.append('line').attr('x1', xScale(kink)).attr('y1', yScale(a)).attr('x2', xScale(8)).attr('y2', yScale(b + 8))
                        .attr('stroke', '#fbbf24').attr('stroke-width', 3);
                    svg.append('circle').attr('cx', xScale(kink)).attr('cy', yScale(a)).attr('r', 6).attr('fill', '#a78bfa');
                    svg.append('text').attr('x', xScale(kink)).attr('y', yScale(a) - 12).attr('text-anchor', 'middle')
                        .attr('fill', '#a78bfa').attr('font-family', 'JetBrains Mono').attr('font-size', 10).text(`kink at x=${kink}`);
                }
            }
            
            draw();
            
            document.getElementById('trop-a').addEventListener('input', (e) => { a = parseInt(e.target.value); document.getElementById('trop-a-val').textContent = a; draw(); });
            document.getElementById('trop-b').addEventListener('input', (e) => { b = parseInt(e.target.value); document.getElementById('trop-b-val').textContent = b; draw(); });
            document.getElementById('show-poly').addEventListener('click', () => { showPoly = !showPoly; draw(); });
        })();

        // Figure 3: Tropical Fan
        (function() {
            const container = document.getElementById('fig3-canvas');
            const width = 860, height = 380;
            const svg = d3.select(container).append('svg').attr('viewBox', `0 0 ${width} ${height}`);
            
            let activeCone = 'all';
            
            function draw() {
                svg.selectAll('*').remove();
                svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const cx = width / 2, cy = height / 2 + 10, rayLen = 140;
                const angles = [-Math.PI/2, Math.PI/6, 5*Math.PI/6];
                const labels = ['(12)(34)', '(13)(24)', '(14)(23)'];
                const coneIds = ['1', '2', '3'];
                const colors = ['#4ade80', '#fbbf24', '#a78bfa'];
                
                angles.forEach((angle, i) => {
                    const nextAngle = angles[(i + 1) % 3];
                    const isActive = activeCone === 'all' || activeCone === coneIds[i];
                    
                    const arcPath = d3.arc().innerRadius(0).outerRadius(rayLen + 20)
                        .startAngle(angle + Math.PI/2).endAngle(nextAngle + Math.PI/2);
                    svg.append('path').attr('d', arcPath).attr('transform', `translate(${cx}, ${cy})`)
                        .attr('fill', isActive ? `${colors[i]}18` : 'transparent');
                    
                    const x2 = cx + rayLen * Math.cos(angle), y2 = cy + rayLen * Math.sin(angle);
                    svg.append('line').attr('x1', cx).attr('y1', cy).attr('x2', x2).attr('y2', y2)
                        .attr('stroke', isActive ? colors[i] : '#4b5563').attr('stroke-width', isActive ? 3 : 1);
                    
                    const lx = cx + (rayLen + 35) * Math.cos(angle), ly = cy + (rayLen + 35) * Math.sin(angle);
                    svg.append('text').attr('x', lx).attr('y', ly).attr('text-anchor', 'middle')
                        .attr('fill', isActive ? colors[i] : '#6b7280').attr('font-family', 'JetBrains Mono').attr('font-size', 11).text(labels[i]);
                });
                
                svg.append('circle').attr('cx', cx).attr('cy', cy).attr('r', 8).attr('fill', '#e8e6e3');
                svg.append('text').attr('x', width / 2).attr('y', 30).attr('text-anchor', 'middle')
                    .attr('fill', '#e8e6e3').attr('font-family', 'JetBrains Mono').attr('font-size', 14).text('Trop(M₀,₄): Three cones meeting at origin');
            }
            
            draw();
            
            document.querySelectorAll('[data-cone]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-cone]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    activeCone = btn.dataset.cone;
                    draw();
                });
            });
            
            document.getElementById('animate-fan').addEventListener('click', () => {
                const seq = ['1', '2', '3', 'all'];
                let i = 0;
                const interval = setInterval(() => {
                    activeCone = seq[i % 4];
                    document.querySelectorAll('[data-cone]').forEach(b => b.classList.toggle('active', b.dataset.cone === activeCone));
                    draw();
                    if (++i >= 8) clearInterval(interval);
                }, 500);
            });
        })();

        // Figure 4: Configuration and Tropical
        (function() {
            const container = document.getElementById('fig4-canvas');
            const width = 860, height = 400;
            const svg = d3.select(container).append('svg').attr('viewBox', `0 0 ${width} ${height}`);
            
            let view = 'config';
            let particles = [{ x: 150, y: 140 }, { x: 230, y: 180 }, { x: 520, y: 160 }, { x: 620, y: 220 }];
            
            function draw() {
                svg.selectAll('*').remove();
                svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                if (view === 'config' || view === 'both') {
                    const scale = view === 'both' ? 0.55 : 1, ox = view === 'both' ? 30 : 100;
                    
                    particles.forEach((p, i) => {
                        const px = p.x * scale + ox, py = p.y * scale + 60;
                        svg.append('circle').attr('cx', px).attr('cy', py).attr('r', 14).attr('fill', ['#4ade80', '#fbbf24', '#a78bfa', '#f472b6'][i]);
                        svg.append('text').attr('x', px).attr('y', py + 4).attr('text-anchor', 'middle')
                            .attr('fill', '#0a0a0f').attr('font-family', 'JetBrains Mono').attr('font-size', 12).text(i + 1);
                    });
                    
                    const d12 = Math.hypot(particles[0].x - particles[1].x, particles[0].y - particles[1].y);
                    const d34 = Math.hypot(particles[2].x - particles[3].x, particles[2].y - particles[3].y);
                    const c12 = { x: (particles[0].x + particles[1].x) / 2, y: (particles[0].y + particles[1].y) / 2 };
                    const c34 = { x: (particles[2].x + particles[3].x) / 2, y: (particles[2].y + particles[3].y) / 2 };
                    const sep = Math.hypot(c12.x - c34.x, c12.y - c34.y);
                    const valid = sep > 2 * Math.max(d12, d34);
                    
                    svg.append('text').attr('x', view === 'both' ? 200 : width / 2).attr('y', height - 30).attr('text-anchor', 'middle')
                        .attr('fill', valid ? '#4ade80' : '#ef4444').attr('font-family', 'JetBrains Mono').attr('font-size', 12)
                        .text(valid ? '(12)(34) valid ✓' : 'No clear hierarchy');
                }
                
                if (view === 'tropical' || view === 'both') {
                    const cx = view === 'both' ? 650 : width / 2, cy = height / 2;
                    const rayLen = 100;
                    const angles = [-Math.PI/2, Math.PI/6, 5*Math.PI/6];
                    const colors = ['#4ade80', '#fbbf24', '#a78bfa'];
                    
                    angles.forEach((angle, i) => {
                        const x2 = cx + rayLen * Math.cos(angle), y2 = cy + rayLen * Math.sin(angle);
                        svg.append('line').attr('x1', cx).attr('y1', cy).attr('x2', x2).attr('y2', y2)
                            .attr('stroke', colors[i]).attr('stroke-width', 2);
                    });
                    svg.append('circle').attr('cx', cx).attr('cy', cy).attr('r', 5).attr('fill', '#e8e6e3');
                    
                    // Point in tropical space
                    const d12 = Math.hypot(particles[0].x - particles[1].x, particles[0].y - particles[1].y);
                    const d34 = Math.hypot(particles[2].x - particles[3].x, particles[2].y - particles[3].y);
                    const sep = Math.hypot((particles[0].x + particles[1].x)/2 - (particles[2].x + particles[3].x)/2,
                                          (particles[0].y + particles[1].y)/2 - (particles[2].y + particles[3].y)/2);
                    const tx = cx + Math.min(80, Math.max(-80, (Math.log(sep) - Math.log(d12)) * 20));
                    const ty = cy - Math.min(80, Math.max(-80, (Math.log(sep) - Math.log(d34)) * 20));
                    
                    svg.append('circle').attr('cx', tx).attr('cy', ty).attr('r', 8).attr('fill', '#22d3ee');
                }
                
                if (view === 'both') {
                    svg.append('line').attr('x1', 430).attr('y1', 20).attr('x2', 430).attr('y2', height - 20)
                        .attr('stroke', '#4b5563').attr('stroke-dasharray', '5,5');
                }
            }
            
            draw();
            
            document.querySelectorAll('[data-view]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-view]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    view = btn.dataset.view;
                    draw();
                });
            });
            
            document.getElementById('randomize').addEventListener('click', () => {
                particles = particles.map(() => ({ x: 100 + Math.random() * 600, y: 100 + Math.random() * 200 }));
                draw();
            });
        })();

        // Figure 5: Drag particles
        (function() {
            const container = document.getElementById('fig5-canvas');
            const width = 860, height = 380;
            const svg = d3.select(container).append('svg').attr('viewBox', `0 0 ${width} ${height}`);
            
            let dragEnabled = false;
            let particles = [{ x: 150, y: 150 }, { x: 230, y: 200 }, { x: 530, y: 170 }, { x: 640, y: 230 }];
            
            function setPreset(type) {
                if (type === 'generic') particles = [{ x: 150, y: 150 }, { x: 230, y: 200 }, { x: 530, y: 170 }, { x: 640, y: 230 }];
                else if (type === 'boundary') particles = [{ x: 200, y: 180 }, { x: 350, y: 180 }, { x: 510, y: 180 }, { x: 660, y: 180 }];
                else particles = [{ x: 350, y: 150 }, { x: 410, y: 200 }, { x: 460, y: 175 }, { x: 520, y: 220 }];
            }
            
            function draw() {
                svg.selectAll('*').remove();
                svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const colors = ['#4ade80', '#fbbf24', '#a78bfa', '#f472b6'];
                const pairs = [
                    { a: [0, 1], b: [2, 3], label: '(12)(34)' },
                    { a: [0, 2], b: [1, 3], label: '(13)(24)' },
                    { a: [0, 3], b: [1, 2], label: '(14)(23)' }
                ];
                
                const results = pairs.map(pair => {
                    const cA = { x: (particles[pair.a[0]].x + particles[pair.a[1]].x) / 2, y: (particles[pair.a[0]].y + particles[pair.a[1]].y) / 2 };
                    const cB = { x: (particles[pair.b[0]].x + particles[pair.b[1]].x) / 2, y: (particles[pair.b[0]].y + particles[pair.b[1]].y) / 2 };
                    const dA = Math.hypot(particles[pair.a[0]].x - particles[pair.a[1]].x, particles[pair.a[0]].y - particles[pair.a[1]].y);
                    const dB = Math.hypot(particles[pair.b[0]].x - particles[pair.b[1]].x, particles[pair.b[0]].y - particles[pair.b[1]].y);
                    const sep = Math.hypot(cA.x - cB.x, cA.y - cB.y);
                    return { label: pair.label, ratio: sep / Math.max(dA, dB), valid: sep > 2 * Math.max(dA, dB) };
                });
                
                particles.forEach((p, i) => {
                    const g = svg.append('g').attr('cursor', dragEnabled ? 'move' : 'default');
                    g.append('circle').attr('cx', p.x).attr('cy', p.y).attr('r', 20).attr('fill', colors[i]);
                    g.append('text').attr('x', p.x).attr('y', p.y + 6).attr('text-anchor', 'middle')
                        .attr('fill', '#0a0a0f').attr('font-family', 'JetBrains Mono').attr('font-size', 14).attr('font-weight', 'bold').text(i + 1);
                    
                    if (dragEnabled) {
                        g.call(d3.drag().on('drag', (event) => {
                            particles[i].x = Math.max(30, Math.min(width - 30, event.x));
                            particles[i].y = Math.max(30, Math.min(height - 60, event.y));
                            draw();
                        }));
                    }
                });
                
                results.forEach((r, i) => {
                    svg.append('text').attr('x', 60).attr('y', height - 70 + i * 20)
                        .attr('fill', r.valid ? '#4ade80' : '#6b7280').attr('font-family', 'JetBrains Mono').attr('font-size', 11)
                        .text(`${r.label}: ${r.ratio.toFixed(2)} ${r.valid ? '✓' : '✗'}`);
                });
                
                const validCount = results.filter(r => r.valid).length;
                const info = validCount === 1 ? `In cone ${results.find(r => r.valid).label}` : 
                             validCount === 0 ? 'Near origin (degenerate)' : `Boundary: ${validCount} valid`;
                svg.append('text').attr('x', width - 60).attr('y', height - 30).attr('text-anchor', 'end')
                    .attr('fill', '#22d3ee').attr('font-family', 'JetBrains Mono').attr('font-size', 12).text(info);
            }
            
            draw();
            
            document.querySelectorAll('[data-preset]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-preset]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    setPreset(btn.dataset.preset);
                    draw();
                });
            });
            
            document.getElementById('enable-drag').addEventListener('click', () => {
                dragEnabled = !dragEnabled;
                document.getElementById('enable-drag').textContent = dragEnabled ? 'Disable Drag' : 'Enable Drag';
                draw();
            });
        })();
    </script>
</body>
</html>
