<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Prefactorization Algebra | Categorical Foundations of FMM</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,600;1,300;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Pro', serif;
            font-size: 19px;
            line-height: 1.7;
            color: #e8e6e3;
            background: #0a0a0f;
            padding: 0;
            min-height: 100vh;
        }

        .container {
            max-width: 920px;
            margin: 0 auto;
            padding: 80px 40px;
        }

        header {
            margin-bottom: 80px;
            padding-bottom: 40px;
            border-bottom: 1px solid rgba(139, 92, 246, 0.3);
        }

        .series-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #8b5cf6;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 52px;
            font-weight: 300;
            line-height: 1.15;
            margin-bottom: 24px;
            background: linear-gradient(135deg, #a78bfa, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 22px;
            font-style: italic;
            color: #9ca3af;
            font-weight: 300;
        }

        h2 {
            font-size: 32px;
            font-weight: 400;
            margin: 70px 0 30px;
            color: #a78bfa;
        }

        h3 {
            font-size: 24px;
            font-weight: 400;
            margin: 50px 0 20px;
            color: #22d3ee;
        }

        p {
            margin-bottom: 24px;
            text-align: justify;
        }

        .lead {
            font-size: 22px;
            line-height: 1.8;
            color: #d1d5db;
            margin-bottom: 40px;
        }

        .figure-container {
            margin: 50px 0;
            background: linear-gradient(145deg, rgba(30, 27, 46, 0.95), rgba(20, 18, 35, 0.98));
            border-radius: 16px;
            padding: 30px;
            border: 1px solid rgba(139, 92, 246, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .figure-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #8b5cf6;
            margin-bottom: 20px;
        }

        .figure-canvas {
            background: rgba(10, 10, 20, 0.8);
            border-radius: 12px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        svg {
            display: block;
            width: 100%;
            height: auto;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(139, 92, 246, 0.2);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #9ca3af;
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            padding: 8px 16px;
            border: 1px solid rgba(139, 92, 246, 0.4);
            background: rgba(139, 92, 246, 0.1);
            color: #a78bfa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: rgba(139, 92, 246, 0.25);
            border-color: #8b5cf6;
        }

        .btn.active {
            background: rgba(139, 92, 246, 0.4);
            border-color: #a78bfa;
            color: #fff;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 140px;
            height: 4px;
            background: rgba(139, 92, 246, 0.3);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #8b5cf6;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #22d3ee;
            min-width: 40px;
        }

        .equation-box {
            background: linear-gradient(135deg, rgba(6, 182, 212, 0.1), rgba(139, 92, 246, 0.1));
            border: 1px solid rgba(6, 182, 212, 0.3);
            border-radius: 12px;
            padding: 30px;
            margin: 40px 0;
            text-align: center;
        }

        .equation {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            color: #22d3ee;
            line-height: 2;
        }

        .equation-label {
            font-size: 14px;
            color: #9ca3af;
            margin-top: 15px;
            font-style: italic;
        }

        .definition-box {
            background: rgba(139, 92, 246, 0.08);
            border-left: 3px solid #8b5cf6;
            padding: 25px 30px;
            margin: 35px 0;
            border-radius: 0 12px 12px 0;
        }

        .definition-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #8b5cf6;
            margin-bottom: 12px;
        }

        .theorem-box {
            background: linear-gradient(135deg, rgba(34, 211, 238, 0.08), rgba(139, 92, 246, 0.08));
            border: 1px solid rgba(34, 211, 238, 0.3);
            padding: 25px 30px;
            margin: 35px 0;
            border-radius: 12px;
        }

        .theorem-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #22d3ee;
            margin-bottom: 12px;
        }

        .insight-box {
            background: rgba(251, 191, 36, 0.08);
            border: 1px solid rgba(251, 191, 36, 0.3);
            padding: 25px 30px;
            margin: 35px 0;
            border-radius: 12px;
            position: relative;
        }

        .insight-box::before {
            content: "✦";
            position: absolute;
            top: -12px;
            left: 25px;
            background: #0a0a0f;
            padding: 0 10px;
            color: #fbbf24;
            font-size: 18px;
        }

        code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            background: rgba(139, 92, 246, 0.15);
            padding: 2px 8px;
            border-radius: 4px;
            color: #a78bfa;
        }

        .symbol {
            font-family: 'JetBrains Mono', monospace;
            color: #22d3ee;
        }

        .highlight {
            color: #fbbf24;
        }

        a {
            color: #8b5cf6;
            text-decoration: none;
            border-bottom: 1px solid rgba(139, 92, 246, 0.3);
            transition: all 0.2s ease;
        }

        a:hover {
            color: #a78bfa;
            border-bottom-color: #a78bfa;
        }

        footer {
            margin-top: 100px;
            padding-top: 40px;
            border-top: 1px solid rgba(139, 92, 246, 0.2);
            text-align: center;
        }

        .nav-links {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }

        .nav-link {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #8b5cf6;
        }

        /* Interactive diagram styles */
        .node-circle {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .node-circle:hover {
            filter: brightness(1.3);
        }

        .arrow-path {
            fill: none;
            stroke-width: 2;
        }

        .label-text {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            fill: #e8e6e3;
        }

        .math-text {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="series-label">Categorical Foundations of FMM — Essay I</div>
            <h1>The Prefactorization Algebra</h1>
            <p class="subtitle">From local observables to global structure: how FMM emerges from algebraic topology</p>
        </header>

        <p class="lead">
            At the heart of quantum field theory lies a profound principle: physics is local. 
            Observables measured in disjoint regions of space should combine independently. 
            This principle, formalized through <em>factorization algebras</em>, turns out to 
            encode exactly the structure of the Fast Multipole Method.
        </p>

        <h2>The Architecture of Locality</h2>

        <p>
            Consider a manifold <span class="symbol">M</span>—for concreteness, think of three-dimensional 
            Euclidean space ℝ³. On this space, we want to organize "observables"—mathematical objects 
            that capture some aspect of a physical system. The key insight is that these observables 
            should be assigned to <em>open regions</em> of space, and they should combine when regions 
            combine.
        </p>

        <div class="definition-box">
            <div class="definition-header">Definition 2.1 — Prefactorization Algebra</div>
            <p>
                A <strong>prefactorization algebra</strong> <span class="symbol">ℱ</span> on a manifold 
                <span class="symbol">M</span> assigns to each open set <span class="symbol">U ⊆ M</span> 
                a vector space <span class="symbol">ℱ(U)</span>, together with <em>structure maps</em>
            </p>
            <p style="text-align: center; margin: 20px 0;">
                <span class="symbol">μ : ℱ(U₁) ⊗ ℱ(U₂) ⊗ ⋯ ⊗ ℱ(Uₖ) → ℱ(V)</span>
            </p>
            <p>
                whenever <span class="symbol">U₁, …, Uₖ</span> are pairwise disjoint open sets 
                contained in <span class="symbol">V</span>. These maps satisfy associativity, 
                unitality, and equivariance axioms.
            </p>
        </div>

        <p>
            The structure maps <span class="symbol">μ</span> are the algebraic incarnation of locality: 
            they tell us how to combine information from disjoint regions into information about a 
            larger region. In the FMM, these maps are precisely the <em>translation operators</em>.
        </p>

        <!-- Interactive Figure 1: Prefactorization Structure -->
        <div class="figure-container">
            <div class="figure-title">Figure 1 · The Prefactorization Structure</div>
            <div class="figure-canvas" id="fig1-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">View:</span>
                    <button class="btn active" data-view="regions">Regions</button>
                    <button class="btn" data-view="structure-map">Structure Map</button>
                    <button class="btn" data-view="composition">Composition</button>
                </div>
                <div class="control-group">
                    <span class="control-label">Regions:</span>
                    <button class="btn" data-regions="2">2</button>
                    <button class="btn active" data-regions="3">3</button>
                    <button class="btn" data-regions="4">4</button>
                </div>
            </div>
        </div>

        <h3>The Three Axioms</h3>

        <p>
            The structure maps must satisfy three fundamental axioms that ensure mathematical consistency 
            and reflect the physical intuition of locality:
        </p>

        <p>
            <strong>Associativity.</strong> If we have nested inclusions of open sets—smaller regions 
            inside medium regions inside larger regions—then composing structure maps in either order 
            gives the same result. Symbolically, the following diagram commutes:
        </p>

        <!-- Interactive Figure 2: Associativity Diagram -->
        <div class="figure-container">
            <div class="figure-title">Figure 2 · The Associativity Axiom</div>
            <div class="figure-canvas" id="fig2-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Path:</span>
                    <button class="btn active" data-path="both">Both Paths</button>
                    <button class="btn" data-path="upper">Upper Path</button>
                    <button class="btn" data-path="lower">Lower Path</button>
                </div>
                <div class="control-group">
                    <button class="btn" id="animate-assoc">▶ Animate</button>
                </div>
            </div>
        </div>

        <p>
            <strong>Unitality.</strong> The empty collection of regions contributes the identity. 
            Including "nothing" into a region <span class="symbol">V</span> gives the unit element 
            of <span class="symbol">ℱ(V)</span>.
        </p>

        <p>
            <strong>Equivariance.</strong> The structure maps are symmetric in their inputs—permuting 
            the order of regions <span class="symbol">U₁, …, Uₖ</span> gives the corresponding 
            permutation of the tensor factors.
        </p>

        <div class="insight-box">
            <p>
                <strong>The FMM Connection:</strong> In the Fast Multipole Method, the structure map 
                <span class="symbol">μ</span> is the <em>M2M (multipole-to-multipole) translation operator</em>. 
                Combining multipole expansions from child boxes into a parent box is exactly the 
                operation of a prefactorization algebra.
            </p>
        </div>

        <h2>The FMM Factorization Algebra</h2>

        <p>
            We now construct the central object of our theory: the prefactorization algebra 
            <span class="symbol">ℱ<sub>FMM</sub></span> that encodes the Fast Multipole Method.
        </p>

        <div class="definition-box">
            <div class="definition-header">Construction 4.1 — The FMM Prefactorization Algebra</div>
            <p>
                Let <span class="symbol">M</span> be a Riemannian symmetric space. Define 
                <span class="symbol">ℱ<sub>FMM</sub></span> as follows:
            </p>
            <p style="margin: 15px 0;">
                <strong>Objects:</strong> For each geodesic ball <span class="symbol">B ⊆ M</span>, 
                the fiber is the space of formal harmonic expansions:
            </p>
            <p style="text-align: center; margin: 15px 0;">
                <span class="symbol">ℱ<sub>FMM</sub>(B) = ∏<sub>λ∈K̂</sub> V<sub>λ</sub></span>
            </p>
            <p style="margin: 15px 0;">
                <strong>Structure maps:</strong> For disjoint balls <span class="symbol">B₁, …, Bₖ ⊆ B</span>, 
                the structure map is:
            </p>
            <p style="text-align: center; margin: 15px 0;">
                <span class="symbol">μ(M₁, …, Mₖ) = Σᵢ T<sub>cᵢ→c</sub>(Mᵢ)</span>
            </p>
            <p>
                where <span class="symbol">T<sub>cᵢ→c</sub></span> is the M2M translation from center 
                <span class="symbol">cᵢ</span> to center <span class="symbol">c</span>.
            </p>
        </div>

        <!-- Interactive Figure 3: FMM Structure Map -->
        <div class="figure-container">
            <div class="figure-title">Figure 3 · FMM Translation as Structure Map</div>
            <div class="figure-canvas" id="fig3-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Truncation p:</span>
                    <div class="slider-container">
                        <input type="range" id="truncation-slider" min="2" max="8" value="4">
                        <span class="slider-value" id="truncation-value">4</span>
                    </div>
                </div>
                <div class="control-group">
                    <button class="btn" id="show-coefficients">Show Coefficients</button>
                    <button class="btn" id="animate-translation">▶ Translate</button>
                </div>
            </div>
        </div>

        <p>
            The key property that makes this work is the <em>addition theorem</em> for spherical 
            harmonics, which gives explicit formulas for the translation coefficients. In ℝ³:
        </p>

        <div class="equation-box">
            <div class="equation">
                M<sub>ℓ</sub><sup>m</sup>(c₂) = Σ<sub>j,k</sub> A<sub>ℓ,m;j,k</sub>(c₂ - c₁) · M<sub>j</sub><sup>k</sup>(c₁)
            </div>
            <div class="equation-label">
                The M2M translation formula — multipole coefficients transform linearly
            </div>
        </div>

        <h2>The Factorization Axiom</h2>

        <p>
            A prefactorization algebra becomes a full <em>factorization algebra</em> when it satisfies 
            an additional "descent" condition: local information can be assembled to recover global 
            information. This is a form of the sheaf condition, adapted to the multiplicative 
            (rather than additive) structure.
        </p>

        <div class="definition-box">
            <div class="definition-header">Definition 2.2 — Factorization Algebra</div>
            <p>
                A prefactorization algebra <span class="symbol">ℱ</span> is a <strong>factorization algebra</strong> 
                if for any open set <span class="symbol">U</span> and any <em>factorizing cover</em> 
                <span class="symbol">{Uᵢ}</span>, the natural map from the Čech complex
            </p>
            <p style="text-align: center; margin: 20px 0;">
                <span class="symbol">lim→ (∏ᵢ ℱ(Uᵢ) ⇉ ∏ᵢⱼ ℱ(Uᵢ ∩ Uⱼ) ⋯) → ℱ(U)</span>
            </p>
            <p>
                is an equivalence. A cover is <em>factorizing</em> if any finite intersection is 
                either empty or a disjoint union of opens in the cover.
            </p>
        </div>

        <p>
            The factorization axiom is the algebraic statement that <em>locality holds exactly</em>: 
            knowing the observables on a cover completely determines the observable on the whole. 
            For the FMM, this corresponds to the fact that multipole expansions from well-separated 
            regions can be perfectly combined.
        </p>

        <!-- Interactive Figure 4: Čech Complex and Descent -->
        <div class="figure-container">
            <div class="figure-title">Figure 4 · The Factorization Axiom: Descent via Čech Complex</div>
            <div class="figure-canvas" id="fig4-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Cover depth:</span>
                    <button class="btn active" data-depth="1">Level 0</button>
                    <button class="btn" data-depth="2">Level 1</button>
                    <button class="btn" data-depth="3">Level 2</button>
                </div>
                <div class="control-group">
                    <button class="btn" id="show-nerve">Show Nerve</button>
                    <button class="btn" id="animate-descent">▶ Descend</button>
                </div>
            </div>
        </div>

        <h3>The Well-Separateness Condition</h3>

        <p>
            The factorization axiom holds for <span class="symbol">ℱ<sub>FMM</sub></span> precisely 
            when the balls satisfy a <em>well-separateness condition</em>—the same condition that 
            guarantees convergence of multipole expansions in the FMM algorithm.
        </p>

        <div class="theorem-box">
            <div class="theorem-header">Theorem 4.4 — Factorization Under Well-Separateness</div>
            <p>
                Let <span class="symbol">B₁, …, Bₖ ⊆ B</span> be <span class="symbol">α</span>-well-separated 
                balls for some <span class="symbol">α > 1</span>. Then the structure map
            </p>
            <p style="text-align: center; margin: 20px 0;">
                <span class="symbol">μ : ℱ<sub>FMM</sub>(B₁) ⊗̂ ⋯ ⊗̂ ℱ<sub>FMM</sub>(Bₖ) → ℱ<sub>FMM</sub>(B)</span>
            </p>
            <p>
                is a quasi-isomorphism (topological isomorphism) onto its image. The error is 
                <span class="symbol">O(1/α)</span>.
            </p>
        </div>

        <!-- Interactive Figure 5: Well-Separateness Visualization -->
        <div class="figure-container">
            <div class="figure-title">Figure 5 · Well-Separateness and Convergence</div>
            <div class="figure-canvas" id="fig5-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Separation α:</span>
                    <div class="slider-container">
                        <input type="range" id="separation-slider" min="0.5" max="4" step="0.1" value="2">
                        <span class="slider-value" id="separation-value">2.0</span>
                    </div>
                </div>
                <div class="control-group">
                    <button class="btn" id="show-error">Show Error Bound</button>
                    <button class="btn" id="toggle-convergence">Toggle Regions</button>
                </div>
            </div>
        </div>

        <h2>Locally Constant Factorization Algebras</h2>

        <p>
            A special class of factorization algebras are <em>locally constant</em>: their value 
            on a region depends only on the homotopy type, not the precise shape. These are 
            intimately connected to operads.
        </p>

        <div class="theorem-box">
            <div class="theorem-header">Theorem 2.3 (Lurie)</div>
            <p>
                Locally constant factorization algebras on <span class="symbol">ℝ<sup>d</sup></span> 
                are equivalent to <span class="symbol">E<sub>d</sub></span>-algebras (algebras over 
                the little <span class="symbol">d</span>-disks operad).
            </p>
        </div>

        <p>
            The FMM factorization algebra is <em>not</em> locally constant—it depends on the geometry 
            of balls, not just their topology. This reflects the fact that convergence depends on 
            precise distances. However, it does carry additional structure: it is an algebra over 
            the <em>Swiss cheese operad</em>.
        </p>

        <div class="insight-box">
            <p>
                <strong>Preview of the Swiss Cheese:</strong> The Swiss cheese operad captures 
                the interaction between "bulk" operations (interior) and "boundary" operations 
                (surface). In FMM terms: multipole expansions (interior sources) versus local 
                expansions (exterior effects). This is the subject of Essay II.
            </p>
        </div>

        <h2>The Categorical Perspective</h2>

        <p>
            Prefactorization algebras form a category, where morphisms are natural transformations 
            respecting the structure maps. This categorical viewpoint reveals deep structure.
        </p>

        <p>
            Consider the assignment <span class="symbol">U ↦ ℱ(U)</span> as a functor from the 
            category of open sets (with inclusions) to vector spaces. The structure maps make 
            this a <em>lax monoidal functor</em> from the symmetric monoidal category 
            <span class="symbol">(Open(M), ⊔)</span> to <span class="symbol">(Vect, ⊗)</span>.
        </p>

        <div class="equation-box">
            <div class="equation">
                ℱ<sub>FMM</sub> : Open(ℝ³)<sup>⊗</sup> → Vect
            </div>
            <div class="equation-label">
                The FMM as a symmetric monoidal functor
            </div>
        </div>

        <p>
            The functor <span class="symbol">ℱ<sub>FMM</sub></span> encodes the entire FMM algorithm: 
            its domain records the hierarchical decomposition of space, its codomain records the 
            algebraic operations, and the functor itself records the translation between them.
        </p>

        <footer>
            <p style="color: #6b7280; font-size: 16px;">
                Essay I of the Categorical Foundations series. Continue to Essay II for the 
                Swiss cheese operad structure.
            </p>
            <div class="nav-links">
                <span class="nav-link">← Introduction</span>
                <span class="nav-link">Essay II: The Swiss Cheese Operad →</span>
            </div>
        </footer>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Figure 1: Prefactorization Structure
        (function() {
            const container = document.getElementById('fig1-canvas');
            const width = 860;
            const height = 420;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`);
            
            let currentView = 'regions';
            let numRegions = 3;
            
            function drawRegions() {
                svg.selectAll('*').remove();
                
                // Background
                svg.append('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                // Outer region V
                const cx = width / 2;
                const cy = height / 2;
                const outerR = 160;
                
                // Gradient for outer region
                const gradient = svg.append('defs')
                    .append('radialGradient')
                    .attr('id', 'outer-gradient');
                gradient.append('stop').attr('offset', '0%').attr('stop-color', 'rgba(139, 92, 246, 0.15)');
                gradient.append('stop').attr('offset', '100%').attr('stop-color', 'rgba(139, 92, 246, 0.02)');
                
                svg.append('circle')
                    .attr('cx', cx)
                    .attr('cy', cy)
                    .attr('r', outerR)
                    .attr('fill', 'url(#outer-gradient)')
                    .attr('stroke', '#8b5cf6')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '8,4');
                
                // Label V
                svg.append('text')
                    .attr('x', cx)
                    .attr('y', cy - outerR - 20)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#a78bfa')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 16)
                    .text('V');
                
                // Inner regions
                const innerR = numRegions === 2 ? 50 : (numRegions === 3 ? 42 : 35);
                const angleOffset = -Math.PI / 2;
                const spreadR = numRegions === 2 ? 70 : (numRegions === 3 ? 75 : 80);
                
                const colors = ['#22d3ee', '#f472b6', '#4ade80', '#fbbf24'];
                
                for (let i = 0; i < numRegions; i++) {
                    const angle = angleOffset + (2 * Math.PI * i / numRegions);
                    const ux = cx + spreadR * Math.cos(angle);
                    const uy = cy + spreadR * Math.sin(angle);
                    
                    svg.append('circle')
                        .attr('cx', ux)
                        .attr('cy', uy)
                        .attr('r', innerR)
                        .attr('fill', `${colors[i]}15`)
                        .attr('stroke', colors[i])
                        .attr('stroke-width', 2)
                        .attr('class', 'node-circle');
                    
                    svg.append('text')
                        .attr('x', ux)
                        .attr('y', uy + 4)
                        .attr('text-anchor', 'middle')
                        .attr('fill', colors[i])
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 14)
                        .text(`U${i + 1}`);
                }
                
                if (currentView === 'structure-map') {
                    drawStructureMap(svg, cx, cy, outerR, numRegions, colors, innerR, spreadR);
                } else if (currentView === 'composition') {
                    drawComposition(svg, cx, cy, outerR, numRegions, colors, innerR, spreadR);
                }
            }
            
            function drawStructureMap(svg, cx, cy, outerR, n, colors, innerR, spreadR) {
                // Draw tensor product and arrow
                const rightSide = cx + 280;
                
                // Arrow
                svg.append('path')
                    .attr('d', `M ${cx + outerR + 30} ${cy} L ${rightSide - 130} ${cy}`)
                    .attr('stroke', '#8b5cf6')
                    .attr('stroke-width', 2)
                    .attr('marker-end', 'url(#arrowhead)');
                
                // Arrowhead
                svg.append('defs').append('marker')
                    .attr('id', 'arrowhead')
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 7)
                    .attr('refX', 10)
                    .attr('refY', 3.5)
                    .attr('orient', 'auto')
                    .append('polygon')
                    .attr('points', '0 0, 10 3.5, 0 7')
                    .attr('fill', '#8b5cf6');
                
                // Structure map label
                svg.append('text')
                    .attr('x', cx + outerR + 90)
                    .attr('y', cy - 15)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#fbbf24')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 14)
                    .text('μ');
                
                // Result: ℱ(V)
                svg.append('circle')
                    .attr('cx', rightSide)
                    .attr('cy', cy)
                    .attr('r', 60)
                    .attr('fill', 'rgba(139, 92, 246, 0.2)')
                    .attr('stroke', '#8b5cf6')
                    .attr('stroke-width', 2);
                
                svg.append('text')
                    .attr('x', rightSide)
                    .attr('y', cy + 5)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#a78bfa')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 16)
                    .text('ℱ(V)');
                
                // Tensor product symbol
                const tensorX = cx - outerR - 80;
                let tensorText = 'ℱ(U₁)';
                for (let i = 1; i < n; i++) {
                    tensorText += ` ⊗ ℱ(U${i + 1})`;
                }
                
                svg.append('text')
                    .attr('x', 50)
                    .attr('y', cy)
                    .attr('fill', '#22d3ee')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 12)
                    .text(tensorText);
            }
            
            function drawComposition(svg, cx, cy, outerR, n, colors, innerR, spreadR) {
                // Show nested structure
                svg.append('text')
                    .attr('x', cx)
                    .attr('y', 30)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#9ca3af')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 12)
                    .text('Associativity: μ ∘ (μ ⊗ id) = μ ∘ (id ⊗ μ)');
                
                // Draw sub-regions in first region
                const angle0 = -Math.PI / 2;
                const u1x = cx + spreadR * Math.cos(angle0);
                const u1y = cy + spreadR * Math.sin(angle0);
                
                const subR = innerR * 0.4;
                const subSpread = innerR * 0.45;
                
                for (let j = 0; j < 2; j++) {
                    const subAngle = -Math.PI / 2 + Math.PI * j;
                    const sx = u1x + subSpread * Math.cos(subAngle);
                    const sy = u1y + subSpread * Math.sin(subAngle);
                    
                    svg.append('circle')
                        .attr('cx', sx)
                        .attr('cy', sy)
                        .attr('r', subR)
                        .attr('fill', 'rgba(251, 191, 36, 0.2)')
                        .attr('stroke', '#fbbf24')
                        .attr('stroke-width', 1.5);
                }
            }
            
            drawRegions();
            
            // Event handlers
            document.querySelectorAll('[data-view]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-view]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentView = btn.dataset.view;
                    drawRegions();
                });
            });
            
            document.querySelectorAll('[data-regions]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-regions]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    numRegions = parseInt(btn.dataset.regions);
                    drawRegions();
                });
            });
        })();

        // Figure 2: Associativity Diagram
        (function() {
            const container = document.getElementById('fig2-canvas');
            const width = 860;
            const height = 380;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`);
            
            let currentPath = 'both';
            let animating = false;
            
            function draw() {
                svg.selectAll('*').remove();
                
                svg.append('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                // Commutative diagram positions
                const nodes = [
                    { x: 150, y: 80, label: '⊗ᵢⱼ ℱ(Uᵢⱼ)', color: '#22d3ee' },
                    { x: 710, y: 80, label: '⊗ᵢ ℱ(Vᵢ)', color: '#f472b6' },
                    { x: 150, y: 300, label: 'ℱ(W)', color: '#a78bfa' },
                    { x: 710, y: 300, label: 'ℱ(W)', color: '#a78bfa' }
                ];
                
                // Arrows
                const arrows = [
                    { from: 0, to: 1, label: '⊗ᵢ μᵢ', color: currentPath !== 'lower' ? '#22d3ee' : '#444', pos: 'top' },
                    { from: 1, to: 3, label: 'μ', color: currentPath !== 'lower' ? '#f472b6' : '#444', pos: 'right' },
                    { from: 0, to: 2, label: 'μ', color: currentPath !== 'upper' ? '#4ade80' : '#444', pos: 'left' },
                    { from: 2, to: 3, label: '=', color: '#fbbf24', pos: 'bottom' }
                ];
                
                // Arrowhead marker
                svg.append('defs').append('marker')
                    .attr('id', 'arrow2')
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 7)
                    .attr('refX', 10)
                    .attr('refY', 3.5)
                    .attr('orient', 'auto')
                    .append('polygon')
                    .attr('points', '0 0, 10 3.5, 0 7')
                    .attr('fill', '#8b5cf6');
                
                // Draw arrows
                arrows.forEach(arr => {
                    const from = nodes[arr.from];
                    const to = nodes[arr.to];
                    
                    const dx = to.x - from.x;
                    const dy = to.y - from.y;
                    const len = Math.sqrt(dx*dx + dy*dy);
                    const offset = 50;
                    
                    const x1 = from.x + (dx/len) * offset;
                    const y1 = from.y + (dy/len) * offset;
                    const x2 = to.x - (dx/len) * offset;
                    const y2 = to.y - (dy/len) * offset;
                    
                    svg.append('line')
                        .attr('x1', x1)
                        .attr('y1', y1)
                        .attr('x2', x2)
                        .attr('y2', y2)
                        .attr('stroke', arr.color)
                        .attr('stroke-width', 2)
                        .attr('marker-end', arr.label !== '=' ? 'url(#arrow2)' : null);
                    
                    // Label
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    let labelOffset = { x: 0, y: 0 };
                    if (arr.pos === 'top') labelOffset = { x: 0, y: -15 };
                    if (arr.pos === 'bottom') labelOffset = { x: 0, y: 20 };
                    if (arr.pos === 'left') labelOffset = { x: -25, y: 0 };
                    if (arr.pos === 'right') labelOffset = { x: 25, y: 0 };
                    
                    svg.append('text')
                        .attr('x', midX + labelOffset.x)
                        .attr('y', midY + labelOffset.y)
                        .attr('text-anchor', 'middle')
                        .attr('fill', arr.color)
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 14)
                        .text(arr.label);
                });
                
                // Draw nodes
                nodes.forEach(node => {
                    svg.append('rect')
                        .attr('x', node.x - 70)
                        .attr('y', node.y - 20)
                        .attr('width', 140)
                        .attr('height', 40)
                        .attr('rx', 8)
                        .attr('fill', `${node.color}15`)
                        .attr('stroke', node.color)
                        .attr('stroke-width', 1.5);
                    
                    svg.append('text')
                        .attr('x', node.x)
                        .attr('y', node.y + 5)
                        .attr('text-anchor', 'middle')
                        .attr('fill', node.color)
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 13)
                        .text(node.label);
                });
            }
            
            draw();
            
            document.querySelectorAll('[data-path]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-path]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentPath = btn.dataset.path;
                    draw();
                });
            });
            
            document.getElementById('animate-assoc').addEventListener('click', () => {
                if (animating) return;
                animating = true;
                
                const paths = ['upper', 'lower', 'both'];
                let i = 0;
                
                const interval = setInterval(() => {
                    currentPath = paths[i % 3];
                    document.querySelectorAll('[data-path]').forEach(b => {
                        b.classList.toggle('active', b.dataset.path === currentPath);
                    });
                    draw();
                    i++;
                    if (i >= 6) {
                        clearInterval(interval);
                        animating = false;
                    }
                }, 600);
            });
        })();

        // Figure 3: FMM Translation
        (function() {
            const container = document.getElementById('fig3-canvas');
            const width = 860;
            const height = 420;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`);
            
            let truncation = 4;
            let showCoeffs = false;
            
            function draw() {
                svg.selectAll('*').remove();
                
                svg.append('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                // Source region (child)
                const childX = 200;
                const childY = height / 2;
                const childR = 60;
                
                // Target region (parent)
                const parentX = 660;
                const parentY = height / 2;
                const parentR = 100;
                
                // Draw child
                svg.append('circle')
                    .attr('cx', childX)
                    .attr('cy', childY)
                    .attr('r', childR)
                    .attr('fill', 'rgba(34, 211, 238, 0.15)')
                    .attr('stroke', '#22d3ee')
                    .attr('stroke-width', 2);
                
                svg.append('text')
                    .attr('x', childX)
                    .attr('y', childY - childR - 15)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#22d3ee')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 14)
                    .text('Child: ℱ(B₁)');
                
                // Draw parent
                svg.append('circle')
                    .attr('cx', parentX)
                    .attr('cy', parentY)
                    .attr('r', parentR)
                    .attr('fill', 'rgba(139, 92, 246, 0.15)')
                    .attr('stroke', '#8b5cf6')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '8,4');
                
                svg.append('text')
                    .attr('x', parentX)
                    .attr('y', parentY - parentR - 15)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#a78bfa')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 14)
                    .text('Parent: ℱ(B)');
                
                // Draw centers
                svg.append('circle')
                    .attr('cx', childX)
                    .attr('cy', childY)
                    .attr('r', 5)
                    .attr('fill', '#22d3ee');
                
                svg.append('circle')
                    .attr('cx', parentX)
                    .attr('cy', parentY)
                    .attr('r', 5)
                    .attr('fill', '#8b5cf6');
                
                // Arrow
                svg.append('defs').append('marker')
                    .attr('id', 'arrow3')
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 7)
                    .attr('refX', 10)
                    .attr('refY', 3.5)
                    .attr('orient', 'auto')
                    .append('polygon')
                    .attr('points', '0 0, 10 3.5, 0 7')
                    .attr('fill', '#fbbf24');
                
                svg.append('path')
                    .attr('d', `M ${childX + childR + 20} ${childY} L ${parentX - parentR - 20} ${childY}`)
                    .attr('stroke', '#fbbf24')
                    .attr('stroke-width', 3)
                    .attr('marker-end', 'url(#arrow3)');
                
                svg.append('text')
                    .attr('x', (childX + parentX) / 2)
                    .attr('y', childY - 20)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#fbbf24')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 16)
                    .text('M2M Translation');
                
                // Coefficients visualization
                if (showCoeffs) {
                    // Child coefficients
                    for (let l = 0; l < truncation; l++) {
                        const y = childY - 30 + l * 18;
                        const alpha = 0.8 - l * 0.15;
                        
                        svg.append('text')
                            .attr('x', childX - childR - 20)
                            .attr('y', y)
                            .attr('text-anchor', 'end')
                            .attr('fill', `rgba(34, 211, 238, ${alpha})`)
                            .attr('font-family', 'JetBrains Mono')
                            .attr('font-size', 11)
                            .text(`M${l}ᵐ`);
                    }
                    
                    // Parent coefficients
                    for (let l = 0; l < truncation; l++) {
                        const y = parentY - 30 + l * 18;
                        const alpha = 0.8 - l * 0.15;
                        
                        svg.append('text')
                            .attr('x', parentX + parentR + 20)
                            .attr('y', y)
                            .attr('text-anchor', 'start')
                            .attr('fill', `rgba(139, 92, 246, ${alpha})`)
                            .attr('font-family', 'JetBrains Mono')
                            .attr('font-size', 11)
                            .text(`M'${l}ᵐ`);
                    }
                    
                    // Translation matrix hint
                    svg.append('text')
                        .attr('x', (childX + parentX) / 2)
                        .attr('y', childY + 30)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#9ca3af')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 11)
                        .text(`p = ${truncation}: O(p²) coefficients`);
                }
                
                // Draw sources in child
                const numSources = 5;
                for (let i = 0; i < numSources; i++) {
                    const angle = (2 * Math.PI * i / numSources) + Math.PI / 6;
                    const r = childR * 0.6 * (0.5 + 0.5 * Math.random());
                    const sx = childX + r * Math.cos(angle);
                    const sy = childY + r * Math.sin(angle);
                    
                    svg.append('circle')
                        .attr('cx', sx)
                        .attr('cy', sy)
                        .attr('r', 4)
                        .attr('fill', '#4ade80');
                }
            }
            
            draw();
            
            document.getElementById('truncation-slider').addEventListener('input', (e) => {
                truncation = parseInt(e.target.value);
                document.getElementById('truncation-value').textContent = truncation;
                draw();
            });
            
            document.getElementById('show-coefficients').addEventListener('click', () => {
                showCoeffs = !showCoeffs;
                draw();
            });
            
            document.getElementById('animate-translation').addEventListener('click', () => {
                // Simple animation indication
                const arrow = svg.select('path[marker-end]');
                arrow.attr('stroke-dasharray', '10,5')
                    .attr('stroke-dashoffset', 100);
                
                arrow.transition()
                    .duration(1000)
                    .attr('stroke-dashoffset', 0)
                    .on('end', () => {
                        arrow.attr('stroke-dasharray', null);
                    });
            });
        })();

        // Figure 4: Čech Complex and Descent
        (function() {
            const container = document.getElementById('fig4-canvas');
            const width = 860;
            const height = 400;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`);
            
            let depth = 1;
            let showNerve = false;
            
            function draw() {
                svg.selectAll('*').remove();
                
                svg.append('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const cx = width / 2;
                const cy = height / 2;
                
                // The cover
                const regions = [
                    { x: cx - 80, y: cy, r: 80, label: 'U₁', color: '#22d3ee' },
                    { x: cx + 80, y: cy, r: 80, label: 'U₂', color: '#f472b6' },
                    { x: cx, y: cy - 60, r: 70, label: 'U₃', color: '#4ade80' }
                ];
                
                // Draw regions
                regions.forEach((reg, i) => {
                    svg.append('circle')
                        .attr('cx', reg.x)
                        .attr('cy', reg.y)
                        .attr('r', reg.r)
                        .attr('fill', `${reg.color}10`)
                        .attr('stroke', reg.color)
                        .attr('stroke-width', 2);
                    
                    svg.append('text')
                        .attr('x', reg.x)
                        .attr('y', reg.y + reg.r + 20)
                        .attr('text-anchor', 'middle')
                        .attr('fill', reg.color)
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 12)
                        .text(reg.label);
                });
                
                // Show intersections based on depth
                if (depth >= 2) {
                    // Pairwise intersections
                    svg.append('text')
                        .attr('x', cx)
                        .attr('y', cy + 10)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#fbbf24')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 10)
                        .text('U₁∩U₂');
                    
                    svg.append('text')
                        .attr('x', cx - 50)
                        .attr('y', cy - 40)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#fbbf24')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 10)
                        .text('U₁∩U₃');
                    
                    svg.append('text')
                        .attr('x', cx + 50)
                        .attr('y', cy - 40)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#fbbf24')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 10)
                        .text('U₂∩U₃');
                }
                
                if (depth >= 3) {
                    // Triple intersection
                    svg.append('circle')
                        .attr('cx', cx)
                        .attr('cy', cy - 20)
                        .attr('r', 15)
                        .attr('fill', 'rgba(251, 191, 36, 0.3)')
                        .attr('stroke', '#fbbf24')
                        .attr('stroke-width', 2);
                    
                    svg.append('text')
                        .attr('x', cx)
                        .attr('y', cy - 17)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#fbbf24')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 8)
                        .text('∩');
                }
                
                // Nerve diagram
                if (showNerve) {
                    const nerveX = 700;
                    const nerveY = cy;
                    const nerveR = 60;
                    
                    // Triangle (2-simplex)
                    const pts = [
                        { x: nerveX, y: nerveY - nerveR },
                        { x: nerveX - nerveR * 0.866, y: nerveY + nerveR * 0.5 },
                        { x: nerveX + nerveR * 0.866, y: nerveY + nerveR * 0.5 }
                    ];
                    
                    // Fill if depth >= 3
                    if (depth >= 3) {
                        svg.append('polygon')
                            .attr('points', pts.map(p => `${p.x},${p.y}`).join(' '))
                            .attr('fill', 'rgba(251, 191, 36, 0.2)')
                            .attr('stroke', '#fbbf24')
                            .attr('stroke-width', 1);
                    }
                    
                    // Edges if depth >= 2
                    if (depth >= 2) {
                        for (let i = 0; i < 3; i++) {
                            svg.append('line')
                                .attr('x1', pts[i].x)
                                .attr('y1', pts[i].y)
                                .attr('x2', pts[(i + 1) % 3].x)
                                .attr('y2', pts[(i + 1) % 3].y)
                                .attr('stroke', '#8b5cf6')
                                .attr('stroke-width', 2);
                        }
                    }
                    
                    // Vertices
                    const vColors = ['#22d3ee', '#f472b6', '#4ade80'];
                    pts.forEach((p, i) => {
                        svg.append('circle')
                            .attr('cx', p.x)
                            .attr('cy', p.y)
                            .attr('r', 8)
                            .attr('fill', vColors[i]);
                    });
                    
                    svg.append('text')
                        .attr('x', nerveX)
                        .attr('y', nerveY + nerveR + 40)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#9ca3af')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 11)
                        .text('Nerve of cover');
                }
                
                // Čech complex formula
                svg.append('text')
                    .attr('x', 100)
                    .attr('y', 30)
                    .attr('fill', '#9ca3af')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 11)
                    .text('Čech complex: ∏ᵢℱ(Uᵢ) → ∏ᵢⱼℱ(Uᵢ∩Uⱼ) → ∏ᵢⱼₖℱ(Uᵢ∩Uⱼ∩Uₖ) → ⋯');
            }
            
            draw();
            
            document.querySelectorAll('[data-depth]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-depth]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    depth = parseInt(btn.dataset.depth);
                    draw();
                });
            });
            
            document.getElementById('show-nerve').addEventListener('click', () => {
                showNerve = !showNerve;
                draw();
            });
            
            document.getElementById('animate-descent').addEventListener('click', () => {
                let d = 1;
                const interval = setInterval(() => {
                    depth = d;
                    document.querySelectorAll('[data-depth]').forEach(b => {
                        b.classList.toggle('active', parseInt(b.dataset.depth) === d);
                    });
                    draw();
                    d++;
                    if (d > 3) {
                        clearInterval(interval);
                    }
                }, 800);
            });
        })();

        // Figure 5: Well-Separateness
        (function() {
            const container = document.getElementById('fig5-canvas');
            const width = 860;
            const height = 400;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`);
            
            let separation = 2.0;
            let showError = false;
            let showConvergence = true;
            
            function draw() {
                svg.selectAll('*').remove();
                
                svg.append('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const cx = width / 2;
                const cy = height / 2;
                
                const r1 = 50;
                const r2 = 50;
                const distance = r1 * separation + r2;
                
                const x1 = cx - distance / 2;
                const x2 = cx + distance / 2;
                
                const isWellSeparated = separation > 1;
                
                // Convergence region visualization
                if (showConvergence) {
                    // Valid expansion region (exterior of both)
                    const regionColor = isWellSeparated ? 'rgba(74, 222, 128, 0.1)' : 'rgba(239, 68, 68, 0.1)';
                    const regionStroke = isWellSeparated ? '#4ade80' : '#ef4444';
                    
                    svg.append('rect')
                        .attr('x', 50)
                        .attr('y', 50)
                        .attr('width', width - 100)
                        .attr('height', height - 100)
                        .attr('fill', regionColor)
                        .attr('stroke', regionStroke)
                        .attr('stroke-width', 1)
                        .attr('stroke-dasharray', '5,5');
                    
                    svg.append('text')
                        .attr('x', 80)
                        .attr('y', 80)
                        .attr('fill', regionStroke)
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 11)
                        .text(isWellSeparated ? 'Expansion converges' : 'Expansion diverges');
                }
                
                // Ball 1
                svg.append('circle')
                    .attr('cx', x1)
                    .attr('cy', cy)
                    .attr('r', r1)
                    .attr('fill', 'rgba(34, 211, 238, 0.2)')
                    .attr('stroke', '#22d3ee')
                    .attr('stroke-width', 2);
                
                svg.append('text')
                    .attr('x', x1)
                    .attr('y', cy + 5)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#22d3ee')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 14)
                    .text('B₁');
                
                // Ball 2
                svg.append('circle')
                    .attr('cx', x2)
                    .attr('cy', cy)
                    .attr('r', r2)
                    .attr('fill', 'rgba(244, 114, 182, 0.2)')
                    .attr('stroke', '#f472b6')
                    .attr('stroke-width', 2);
                
                svg.append('text')
                    .attr('x', x2)
                    .attr('y', cy + 5)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#f472b6')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 14)
                    .text('B₂');
                
                // Distance annotation
                svg.append('line')
                    .attr('x1', x1)
                    .attr('y1', cy + r1 + 30)
                    .attr('x2', x2)
                    .attr('y2', cy + r2 + 30)
                    .attr('stroke', '#fbbf24')
                    .attr('stroke-width', 2);
                
                svg.append('text')
                    .attr('x', cx)
                    .attr('y', cy + r1 + 50)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#fbbf24')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 12)
                    .text(`d = ${separation.toFixed(1)} × r`);
                
                // Well-separateness indicator
                const statusColor = isWellSeparated ? '#4ade80' : '#ef4444';
                const statusText = isWellSeparated ? 'α > 1: Well-separated ✓' : 'α ≤ 1: Not well-separated ✗';
                
                svg.append('text')
                    .attr('x', cx)
                    .attr('y', 30)
                    .attr('text-anchor', 'middle')
                    .attr('fill', statusColor)
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 14)
                    .text(statusText);
                
                // Error bound
                if (showError && isWellSeparated) {
                    const error = 1 / separation;
                    
                    svg.append('text')
                        .attr('x', cx)
                        .attr('y', height - 30)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#9ca3af')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 12)
                        .text(`Error bound: O(1/α) = O(${error.toFixed(2)})`);
                    
                    // Error bar
                    const barWidth = 200;
                    const errorWidth = barWidth * Math.min(error, 1);
                    
                    svg.append('rect')
                        .attr('x', cx - barWidth / 2)
                        .attr('y', height - 60)
                        .attr('width', barWidth)
                        .attr('height', 10)
                        .attr('fill', 'rgba(139, 92, 246, 0.2)')
                        .attr('stroke', '#8b5cf6')
                        .attr('stroke-width', 1);
                    
                    svg.append('rect')
                        .attr('x', cx - barWidth / 2)
                        .attr('y', height - 60)
                        .attr('width', errorWidth)
                        .attr('height', 10)
                        .attr('fill', error < 0.5 ? '#4ade80' : (error < 0.8 ? '#fbbf24' : '#ef4444'));
                }
            }
            
            draw();
            
            document.getElementById('separation-slider').addEventListener('input', (e) => {
                separation = parseFloat(e.target.value);
                document.getElementById('separation-value').textContent = separation.toFixed(1);
                draw();
            });
            
            document.getElementById('show-error').addEventListener('click', () => {
                showError = !showError;
                draw();
            });
            
            document.getElementById('toggle-convergence').addEventListener('click', () => {
                showConvergence = !showConvergence;
                draw();
            });
        })();
    </script>
</body>
</html>
