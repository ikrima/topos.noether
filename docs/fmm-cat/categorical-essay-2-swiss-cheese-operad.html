<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Swiss Cheese Operad | Categorical Foundations of FMM</title>
    <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:ital,wght@0,300;0,400;0,600;1,300;1,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Crimson Pro', serif;
            font-size: 19px;
            line-height: 1.7;
            color: #e8e6e3;
            background: #0a0a0f;
        }

        .container {
            max-width: 920px;
            margin: 0 auto;
            padding: 80px 40px;
        }

        header {
            margin-bottom: 80px;
            padding-bottom: 40px;
            border-bottom: 1px solid rgba(6, 182, 212, 0.3);
        }

        .series-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #06b6d4;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 52px;
            font-weight: 300;
            line-height: 1.15;
            margin-bottom: 24px;
            background: linear-gradient(135deg, #22d3ee, #f472b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 22px;
            font-style: italic;
            color: #9ca3af;
            font-weight: 300;
        }

        h2 {
            font-size: 32px;
            font-weight: 400;
            margin: 70px 0 30px;
            color: #22d3ee;
        }

        h3 {
            font-size: 24px;
            font-weight: 400;
            margin: 50px 0 20px;
            color: #f472b6;
        }

        p {
            margin-bottom: 24px;
            text-align: justify;
        }

        .lead {
            font-size: 22px;
            line-height: 1.8;
            color: #d1d5db;
            margin-bottom: 40px;
        }

        .figure-container {
            margin: 50px 0;
            background: linear-gradient(145deg, rgba(30, 27, 46, 0.95), rgba(20, 18, 35, 0.98));
            border-radius: 16px;
            padding: 30px;
            border: 1px solid rgba(6, 182, 212, 0.2);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
        }

        .figure-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #06b6d4;
            margin-bottom: 20px;
        }

        .figure-canvas {
            background: rgba(10, 10, 20, 0.8);
            border-radius: 12px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        svg {
            display: block;
            width: 100%;
            height: auto;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(6, 182, 212, 0.2);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .control-label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #9ca3af;
        }

        .btn {
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
            padding: 8px 16px;
            border: 1px solid rgba(6, 182, 212, 0.4);
            background: rgba(6, 182, 212, 0.1);
            color: #22d3ee;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn:hover {
            background: rgba(6, 182, 212, 0.25);
            border-color: #06b6d4;
        }

        .btn.active {
            background: rgba(6, 182, 212, 0.4);
            border-color: #22d3ee;
            color: #fff;
        }

        .btn.open-color {
            border-color: rgba(34, 211, 238, 0.4);
            color: #22d3ee;
        }

        .btn.open-color.active {
            background: rgba(34, 211, 238, 0.4);
        }

        .btn.closed-color {
            border-color: rgba(244, 114, 182, 0.4);
            color: #f472b6;
        }

        .btn.closed-color.active {
            background: rgba(244, 114, 182, 0.4);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 140px;
            height: 4px;
            background: rgba(6, 182, 212, 0.3);
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #06b6d4;
            border-radius: 50%;
            cursor: pointer;
        }

        .slider-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #f472b6;
            min-width: 40px;
        }

        .equation-box {
            background: linear-gradient(135deg, rgba(244, 114, 182, 0.1), rgba(34, 211, 238, 0.1));
            border: 1px solid rgba(244, 114, 182, 0.3);
            border-radius: 12px;
            padding: 30px;
            margin: 40px 0;
            text-align: center;
        }

        .equation {
            font-family: 'JetBrains Mono', monospace;
            font-size: 18px;
            color: #f472b6;
            line-height: 2;
        }

        .equation-label {
            font-size: 14px;
            color: #9ca3af;
            margin-top: 15px;
            font-style: italic;
        }

        .definition-box {
            background: rgba(6, 182, 212, 0.08);
            border-left: 3px solid #06b6d4;
            padding: 25px 30px;
            margin: 35px 0;
            border-radius: 0 12px 12px 0;
        }

        .definition-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #06b6d4;
            margin-bottom: 12px;
        }

        .theorem-box {
            background: linear-gradient(135deg, rgba(244, 114, 182, 0.08), rgba(34, 211, 238, 0.08));
            border: 1px solid rgba(244, 114, 182, 0.3);
            padding: 25px 30px;
            margin: 35px 0;
            border-radius: 12px;
        }

        .theorem-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #f472b6;
            margin-bottom: 12px;
        }

        .insight-box {
            background: rgba(251, 191, 36, 0.08);
            border: 1px solid rgba(251, 191, 36, 0.3);
            padding: 25px 30px;
            margin: 35px 0;
            border-radius: 12px;
            position: relative;
        }

        .insight-box::before {
            content: "‚óà";
            position: absolute;
            top: -12px;
            left: 25px;
            background: #0a0a0f;
            padding: 0 10px;
            color: #fbbf24;
            font-size: 18px;
        }

        .two-column {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 40px 0;
        }

        .column-box {
            padding: 25px;
            border-radius: 12px;
        }

        .column-box.open {
            background: rgba(34, 211, 238, 0.08);
            border: 1px solid rgba(34, 211, 238, 0.3);
        }

        .column-box.closed {
            background: rgba(244, 114, 182, 0.08);
            border: 1px solid rgba(244, 114, 182, 0.3);
        }

        .column-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 15px;
        }

        .column-title.open { color: #22d3ee; }
        .column-title.closed { color: #f472b6; }

        code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9em;
            background: rgba(6, 182, 212, 0.15);
            padding: 2px 8px;
            border-radius: 4px;
            color: #22d3ee;
        }

        .symbol {
            font-family: 'JetBrains Mono', monospace;
            color: #f472b6;
        }

        a {
            color: #06b6d4;
            text-decoration: none;
            border-bottom: 1px solid rgba(6, 182, 212, 0.3);
            transition: all 0.2s ease;
        }

        a:hover {
            color: #22d3ee;
            border-bottom-color: #22d3ee;
        }

        footer {
            margin-top: 100px;
            padding-top: 40px;
            border-top: 1px solid rgba(6, 182, 212, 0.2);
            text-align: center;
        }

        .nav-links {
            display: flex;
            justify-content: space-between;
            margin-top: 30px;
        }

        .nav-link {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #06b6d4;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="series-label">Categorical Foundations of FMM ‚Äî Essay II</div>
            <h1>The Swiss Cheese Operad</h1>
            <p class="subtitle">Two colors, one structure: how bulk and boundary interact in hierarchical computation</p>
        </header>

        <p class="lead">
            The Fast Multipole Method has two faces. <em>Multipole expansions</em> describe sources 
            inside a region‚Äîthey radiate outward. <em>Local expansions</em> describe effects from 
            outside‚Äîthey act inward. This duality is not accidental: it reflects the structure of 
            the <em>Swiss cheese operad</em>.
        </p>

        <h2>The Duality of Expansions</h2>

        <p>
            Recall from Essay I that the FMM prefactorization algebra assigns to each ball 
            <span class="symbol">B</span> a vector space <span class="symbol">‚Ñ±(B)</span> of 
            formal harmonic expansions. But what precisely are these expansions describing?
        </p>

        <p>
            There are two fundamentally different perspectives:
        </p>

        <div class="two-column">
            <div class="column-box open">
                <div class="column-title open">Multipole (Interior Sources)</div>
                <p style="margin-bottom: 0;">
                    Describes the potential generated by charges <em>inside</em> the ball. 
                    Valid for evaluation points <em>outside</em>. Represented by coefficients 
                    <span class="symbol">M<sub>‚Ñì</sub><sup>m</sup></span>.
                </p>
            </div>
            <div class="column-box closed">
                <div class="column-title closed">Local (Exterior Effects)</div>
                <p style="margin-bottom: 0;">
                    Describes the potential felt from charges <em>outside</em> the ball. 
                    Valid for evaluation points <em>inside</em>. Represented by coefficients 
                    <span class="symbol">L<sub>‚Ñì</sub><sup>m</sup></span>.
                </p>
            </div>
        </div>

        <p>
            This duality‚Äîinside/outside, source/effect‚Äîis captured by a mathematical structure 
            called a <em>two-colored operad</em>. The Swiss cheese operad, introduced by Voronov 
            in 1999, is precisely the operad that governs operations with both "open" (interior) 
            and "closed" (boundary) components.
        </p>

        <!-- Figure 1: Two Colors Visualization -->
        <div class="figure-container">
            <div class="figure-title">Figure 1 ¬∑ The Two Colors of FMM</div>
            <div class="figure-canvas" id="fig1-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">View:</span>
                    <button class="btn open-color active" data-color="multipole">Multipole</button>
                    <button class="btn closed-color" data-color="local">Local</button>
                    <button class="btn" data-color="both">Both</button>
                </div>
                <div class="control-group">
                    <button class="btn" id="animate-colors">‚ñ∂ Animate Flow</button>
                </div>
            </div>
        </div>

        <h2>What is an Operad?</h2>

        <p>
            Before introducing the Swiss cheese operad, we need the general notion of an operad. 
            An operad is a structure that encodes "operations with multiple inputs and one output" 
            together with rules for how these operations compose.
        </p>

        <div class="definition-box">
            <div class="definition-header">Definition ‚Äî Operad (Informal)</div>
            <p>
                An <strong>operad</strong> <span class="symbol">ùí™</span> consists of:
            </p>
            <p style="margin: 15px 0;">
                ‚Ä¢ Spaces of operations <span class="symbol">ùí™(n)</span> for each 
                <span class="symbol">n ‚â• 0</span>, where elements of 
                <span class="symbol">ùí™(n)</span> are "operations with n inputs"
            </p>
            <p style="margin: 15px 0;">
                ‚Ä¢ Composition maps: given operations <span class="symbol">f ‚àà ùí™(k)</span> and 
                <span class="symbol">g·µ¢ ‚àà ùí™(n·µ¢)</span>, we can compose to get 
                <span class="symbol">f ‚àò (g‚ÇÅ, ‚Ä¶, g‚Çñ) ‚àà ùí™(n‚ÇÅ + ‚ãØ + n‚Çñ)</span>
            </p>
            <p style="margin: 15px 0;">
                ‚Ä¢ Associativity and unit axioms ensuring composition behaves sensibly
            </p>
        </div>

        <p>
            The archetypal example is the <em>little disks operad</em> <span class="symbol">E<sub>d</sub></span>: 
            the space <span class="symbol">E<sub>d</sub>(n)</span> consists of configurations of 
            <span class="symbol">n</span> disjoint disks inside a larger disk, and composition is 
            given by inserting configurations into the smaller disks.
        </p>

        <!-- Figure 2: Little Disks Operad -->
        <div class="figure-container">
            <div class="figure-title">Figure 2 ¬∑ The Little Disks Operad E<sub>d</sub></div>
            <div class="figure-canvas" id="fig2-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Inputs:</span>
                    <button class="btn active" data-inputs="2">2</button>
                    <button class="btn" data-inputs="3">3</button>
                    <button class="btn" data-inputs="4">4</button>
                </div>
                <div class="control-group">
                    <button class="btn" id="show-composition">Show Composition</button>
                </div>
            </div>
        </div>

        <h2>The Swiss Cheese Operad</h2>

        <p>
            The Swiss cheese operad <span class="symbol">SC<sub>d</sub></span> extends the little 
            disks operad by introducing a second color. Now we have both "open" operations 
            (configurations of open disks) and "closed" operations (configurations of closed disks), 
            with the closed disks allowed to touch the boundary.
        </p>

        <div class="definition-box">
            <div class="definition-header">Definition 2.5 ‚Äî Swiss Cheese Operad</div>
            <p>
                The <strong>Swiss cheese operad</strong> <span class="symbol">SC<sub>d</sub></span> 
                is a two-colored operad with:
            </p>
            <p style="margin: 15px 0;">
                <span style="color: #22d3ee;">‚ñ† Open color:</span> Operations parametrized by 
                configurations of disjoint open <span class="symbol">d</span>-disks inside a 
                larger open disk (this is just <span class="symbol">E<sub>d</sub></span>)
            </p>
            <p style="margin: 15px 0;">
                <span style="color: #f472b6;">‚ñ† Closed color:</span> Operations parametrized by 
                configurations of disjoint closed <span class="symbol">d</span>-disks inside an 
                open disk
            </p>
            <p style="margin: 15px 0;">
                <span style="color: #fbbf24;">‚ñ† Mixed operations:</span> Configurations with both 
                open and closed disks, where closed disks may touch the boundary
            </p>
        </div>

        <!-- Figure 3: Swiss Cheese Operations -->
        <div class="figure-container">
            <div class="figure-title">Figure 3 ¬∑ Swiss Cheese Operations: Bulk and Boundary</div>
            <div class="figure-canvas" id="fig3-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Operation type:</span>
                    <button class="btn open-color active" data-op="open">Open Only</button>
                    <button class="btn closed-color" data-op="closed">Closed Only</button>
                    <button class="btn" data-op="mixed">Mixed</button>
                </div>
                <div class="control-group">
                    <button class="btn" id="add-disk">+ Add Disk</button>
                    <button class="btn" id="reset-disks">Reset</button>
                </div>
            </div>
        </div>

        <h3>Algebras over the Swiss Cheese</h3>

        <p>
            An <em>algebra</em> over an operad is a concrete realization: we assign actual 
            vector spaces to each color, and the operad operations become actual linear maps. 
            For the Swiss cheese operad:
        </p>

        <div class="theorem-box">
            <div class="theorem-header">SC<sub>d</sub>-Algebra Structure</div>
            <p>
                An algebra over <span class="symbol">SC<sub>d</sub></span> consists of:
            </p>
            <p style="margin: 15px 0;">
                ‚Ä¢ A vector space <span class="symbol">A</span> (open color) that is an 
                <span class="symbol">E<sub>d</sub></span>-algebra
            </p>
            <p style="margin: 15px 0;">
                ‚Ä¢ A vector space <span class="symbol">B</span> (closed color) that is a 
                module over <span class="symbol">A</span>
            </p>
            <p style="margin: 15px 0;">
                ‚Ä¢ Operations mixing <span class="symbol">A</span> and <span class="symbol">B</span> 
                compatible with the operad structure
            </p>
        </div>

        <div class="insight-box">
            <p>
                <strong>The FMM Interpretation:</strong> In the Fast Multipole Method:
            </p>
            <p style="margin: 15px 0;">
                <span style="color: #22d3ee;">A = Multipole expansions</span> ‚Äî the open color 
                represents sources inside a region, encoding the "bulk" physics
            </p>
            <p style="margin: 15px 0;">
                <span style="color: #f472b6;">B = Local expansions</span> ‚Äî the closed color 
                represents effects felt inside, encoding "boundary" information
            </p>
            <p style="margin: 15px 0;">
                <span style="color: #fbbf24;">Mixed operation = M2L translation</span> ‚Äî converting 
                multipole (source) to local (effect) across well-separated regions
            </p>
        </div>

        <h2>FMM as an SC<sub>d</sub>-Algebra</h2>

        <p>
            We now make precise how the FMM translation operators define an algebra over the 
            Swiss cheese operad. The key insight is that the three translation operators‚ÄîM2M, 
            L2L, and M2L‚Äîcorrespond to the three types of operadic operations.
        </p>

        <div class="equation-box">
            <div class="equation">
                M2M : A ‚äó A ‚Üí A &nbsp;&nbsp;&nbsp; (open ‚àò open ‚Üí open)<br>
                L2L : B ‚Üí B &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (closed ‚Üí closed)<br>
                M2L : A ‚Üí B &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (open ‚Üí closed)
            </div>
            <div class="equation-label">
                FMM translation operators as operadic operations
            </div>
        </div>

        <!-- Figure 4: Translation Operators as Operadic Operations -->
        <div class="figure-container">
            <div class="figure-title">Figure 4 ¬∑ Translation Operators in the Swiss Cheese Framework</div>
            <div class="figure-canvas" id="fig4-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Operator:</span>
                    <button class="btn open-color active" data-trans="m2m">M2M</button>
                    <button class="btn closed-color" data-trans="l2l">L2L</button>
                    <button class="btn" data-trans="m2l">M2L</button>
                </div>
                <div class="control-group">
                    <button class="btn" id="animate-operator">‚ñ∂ Animate</button>
                </div>
            </div>
        </div>

        <h3>The M2M Operation (Open ‚Üí Open)</h3>

        <p>
            The multipole-to-multipole translation combines multipole expansions from child 
            regions into a parent region. Geometrically, this corresponds to inserting smaller 
            open disks into a larger open disk‚Äîexactly an <span class="symbol">E<sub>d</sub></span> 
            operation.
        </p>

        <p>
            If <span class="symbol">B‚ÇÅ, B‚ÇÇ, ‚Ä¶, B‚Çñ</span> are disjoint balls inside 
            <span class="symbol">B</span>, and <span class="symbol">M‚ÇÅ, ‚Ä¶, M‚Çñ</span> are their 
            multipole expansions, the combined expansion at the center of <span class="symbol">B</span> is:
        </p>

        <div class="equation-box">
            <div class="equation">
                M<sub>‚Ñì</sub><sup>m</sup>(c) = Œ£·µ¢ Œ£‚±º‚Çñ A<sub>‚Ñìm;jk</sub>(c - c·µ¢) ¬∑ M<sub>j</sub><sup>k</sup>(c·µ¢)
            </div>
            <div class="equation-label">
                M2M: combining multipole expansions (open ‚àò open ‚Üí open)
            </div>
        </div>

        <h3>The L2L Operation (Closed ‚Üí Closed)</h3>

        <p>
            The local-to-local translation restricts a local expansion from a larger region 
            to a smaller region inside it. This corresponds to "shrinking" a closed disk 
            while remaining inside the ambient open disk.
        </p>

        <div class="equation-box">
            <div class="equation">
                L<sub>‚Ñì</sub><sup>m</sup>(c') = Œ£‚±º‚Çñ C<sub>‚Ñìm;jk</sub>(c' - c) ¬∑ L<sub>j</sub><sup>k</sup>(c)
            </div>
            <div class="equation-label">
                L2L: restricting local expansions (closed ‚Üí closed)
            </div>
        </div>

        <h3>The M2L Operation (Open ‚Üí Closed)</h3>

        <p>
            The most interesting operation is multipole-to-local: converting the description 
            of sources in one region into the description of their effect in a distant region. 
            This is the <em>mixed operation</em> that connects the two colors.
        </p>

        <div class="equation-box">
            <div class="equation">
                L<sub>‚Ñì</sub><sup>m</sup>(c‚ÇÇ) = Œ£‚±º‚Çñ B<sub>‚Ñìm;jk</sub>(c‚ÇÇ - c‚ÇÅ) ¬∑ M<sub>j</sub><sup>k</sup>(c‚ÇÅ)
            </div>
            <div class="equation-label">
                M2L: converting multipole to local (open ‚Üí closed)
            </div>
        </div>

        <p>
            The M2L operator is valid precisely when the source region and target region are 
            <em>well-separated</em>‚Äîgeometrically, when the closed disk doesn't overlap with 
            the open disk. This separation condition is built into the Swiss cheese operad: 
            closed disks in mixed operations must be separated from open disks.
        </p>

        <!-- Figure 5: The Complete SC Structure -->
        <div class="figure-container">
            <div class="figure-title">Figure 5 ¬∑ The Complete Operadic Structure of FMM</div>
            <div class="figure-canvas" id="fig5-canvas"></div>
            <div class="controls">
                <div class="control-group">
                    <span class="control-label">Phase:</span>
                    <button class="btn active" data-phase="upward">Upward Pass</button>
                    <button class="btn" data-phase="m2l">M2L Phase</button>
                    <button class="btn" data-phase="downward">Downward Pass</button>
                    <button class="btn" data-phase="all">Full Algorithm</button>
                </div>
            </div>
        </div>

        <h2>Operadic Identities</h2>

        <p>
            The Swiss cheese operad structure implies specific identities that the FMM operators 
            must satisfy. These are not merely abstract requirements‚Äîthey correspond to 
            fundamental properties of the algorithm.
        </p>

        <div class="theorem-box">
            <div class="theorem-header">Theorem 4.7 ‚Äî FMM Operadic Identities</div>
            <p>
                The FMM translation operators satisfy:
            </p>
            <p style="margin: 15px 0;">
                <strong>M2M Associativity:</strong> 
                <span class="symbol">T<sub>c‚ÇÅ‚Üíc‚ÇÉ</sub> = T<sub>c‚ÇÇ‚Üíc‚ÇÉ</sub> ‚àò T<sub>c‚ÇÅ‚Üíc‚ÇÇ</sub></span>
            </p>
            <p style="margin: 15px 0;">
                <strong>L2L Associativity:</strong> 
                <span class="symbol">T<sub>c‚ÇÅ‚Üíc‚ÇÉ</sub> = T<sub>c‚ÇÇ‚Üíc‚ÇÉ</sub> ‚àò T<sub>c‚ÇÅ‚Üíc‚ÇÇ</sub></span>
            </p>
            <p style="margin: 15px 0;">
                <strong>M2L-L2L Compatibility:</strong> 
                <span class="symbol">M2L<sub>B‚ÇÅ‚ÜíB‚ÇÉ</sub> = L2L<sub>B‚ÇÇ‚ÜíB‚ÇÉ</sub> ‚àò M2L<sub>B‚ÇÅ‚ÜíB‚ÇÇ</sub></span>
            </p>
            <p>
                for appropriate nested balls <span class="symbol">B‚ÇÅ ‚äÇ B‚ÇÇ ‚äÇ B‚ÇÉ</span>.
            </p>
        </div>

        <p>
            These identities express path-independence: the result of a sequence of translations 
            depends only on the endpoints, not the intermediate steps. This is why the FMM 
            algorithm is well-defined‚Äîdifferent tree structures for the same configuration 
            give the same answer (up to truncation error).
        </p>

        <h2>Physical Interpretation: Bulk and Boundary</h2>

        <p>
            The Swiss cheese structure has a beautiful physical interpretation. In quantum field 
            theory, the distinction between "bulk" and "boundary" is fundamental:
        </p>

        <p>
            <strong>Bulk degrees of freedom</strong> describe physics in the interior of a 
            region‚Äîparticle states, field configurations, interactions. These are the "open" 
            operations.
        </p>

        <p>
            <strong>Boundary degrees of freedom</strong> describe physics on the boundary‚Äî
            boundary conditions, asymptotic states, external couplings. These are the "closed" 
            operations.
        </p>

        <p>
            The FMM implements exactly this structure in the classical limit: multipole expansions 
            encode the "bulk" information about sources, while local expansions encode the 
            "boundary" information about external effects.
        </p>

        <div class="insight-box">
            <p>
                <strong>Holographic hint:</strong> The relationship between bulk and boundary 
                in the Swiss cheese structure anticipates the AdS/CFT correspondence. In 
                holography, bulk physics (gravity in AdS) is equivalent to boundary physics 
                (CFT on the boundary). The FMM is a classical prototype of holographic 
                computation.
            </p>
        </div>

        <h2>Why Two Colors?</h2>

        <p>
            One might ask: why is the two-colored structure necessary? Why not just use the 
            little disks operad <span class="symbol">E<sub>d</sub></span>?
        </p>

        <p>
            The answer lies in the <em>directionality</em> of FMM operations. Multipole expansions 
            naturally "flow outward" (valid outside the source region), while local expansions 
            naturally "flow inward" (valid inside the target region). This asymmetry cannot be 
            captured by a single-colored operad.
        </p>

        <p>
            More precisely, the M2L operation has no inverse: you cannot convert a local expansion 
            back into a multipole expansion (at least not without losing information). This 
            irreversibility is encoded in the Swiss cheese structure: there are operations from 
            open to closed, but no operations from closed to open.
        </p>

        <div class="equation-box">
            <div class="equation">
                Hom<sub>SC</sub>(open, closed) ‚â† ‚àÖ<br>
                Hom<sub>SC</sub>(closed, open) = ‚àÖ
            </div>
            <div class="equation-label">
                The asymmetry of the Swiss cheese operad
            </div>
        </div>

        <footer>
            <p style="color: #6b7280; font-size: 16px;">
                Essay II of the Categorical Foundations series. Continue to Essay III for the 
                tropical geometry of convergence regions.
            </p>
            <div class="nav-links">
                <span class="nav-link">‚Üê Essay I: The Prefactorization Algebra</span>
                <span class="nav-link">Essay III: Tropical Convergence ‚Üí</span>
            </div>
        </footer>
    </div>

    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // Figure 1: Two Colors
        (function() {
            const container = document.getElementById('fig1-canvas');
            const width = 860;
            const height = 420;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`);
            
            let colorMode = 'multipole';
            let animating = false;
            
            function draw() {
                svg.selectAll('*').remove();
                
                svg.append('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const cx = width / 2;
                const cy = height / 2;
                const r = 120;
                
                // Main region
                svg.append('circle')
                    .attr('cx', cx)
                    .attr('cy', cy)
                    .attr('r', r)
                    .attr('fill', 'rgba(100, 100, 120, 0.1)')
                    .attr('stroke', '#6b7280')
                    .attr('stroke-width', 2);
                
                if (colorMode === 'multipole' || colorMode === 'both') {
                    // Sources inside
                    const sources = [
                        { x: cx - 30, y: cy - 20 },
                        { x: cx + 20, y: cy + 10 },
                        { x: cx - 10, y: cy + 30 },
                        { x: cx + 35, y: cy - 25 }
                    ];
                    
                    sources.forEach(s => {
                        svg.append('circle')
                            .attr('cx', s.x)
                            .attr('cy', s.y)
                            .attr('r', 8)
                            .attr('fill', '#22d3ee');
                    });
                    
                    // Outward arrows
                    const angles = [0, Math.PI/3, 2*Math.PI/3, Math.PI, 4*Math.PI/3, 5*Math.PI/3];
                    angles.forEach(angle => {
                        const x1 = cx + (r + 20) * Math.cos(angle);
                        const y1 = cy + (r + 20) * Math.sin(angle);
                        const x2 = cx + (r + 60) * Math.cos(angle);
                        const y2 = cy + (r + 60) * Math.sin(angle);
                        
                        svg.append('line')
                            .attr('x1', x1)
                            .attr('y1', y1)
                            .attr('x2', x2)
                            .attr('y2', y2)
                            .attr('stroke', '#22d3ee')
                            .attr('stroke-width', 2)
                            .attr('marker-end', 'url(#arrow-open)');
                    });
                    
                    svg.append('text')
                        .attr('x', 60)
                        .attr('y', 50)
                        .attr('fill', '#22d3ee')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 14)
                        .text('Multipole: Sources ‚Üí Outward');
                }
                
                if (colorMode === 'local' || colorMode === 'both') {
                    // External sources
                    const external = [
                        { x: 100, y: 100 },
                        { x: 760, y: 150 },
                        { x: 150, y: 350 },
                        { x: 700, y: 320 }
                    ];
                    
                    external.forEach(s => {
                        svg.append('circle')
                            .attr('cx', s.x)
                            .attr('cy', s.y)
                            .attr('r', 10)
                            .attr('fill', '#f472b6');
                        
                        // Arrow toward center
                        const dx = cx - s.x;
                        const dy = cy - s.y;
                        const len = Math.sqrt(dx*dx + dy*dy);
                        const x2 = s.x + (dx/len) * (len - r - 30);
                        const y2 = s.y + (dy/len) * (len - r - 30);
                        
                        svg.append('line')
                            .attr('x1', s.x + (dx/len) * 20)
                            .attr('y1', s.y + (dy/len) * 20)
                            .attr('x2', x2)
                            .attr('y2', y2)
                            .attr('stroke', '#f472b6')
                            .attr('stroke-width', 2)
                            .attr('marker-end', 'url(#arrow-closed)');
                    });
                    
                    svg.append('text')
                        .attr('x', 60)
                        .attr('y', colorMode === 'both' ? 80 : 50)
                        .attr('fill', '#f472b6')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 14)
                        .text('Local: External ‚Üí Inward');
                }
                
                // Arrow markers
                const defs = svg.append('defs');
                
                defs.append('marker')
                    .attr('id', 'arrow-open')
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 7)
                    .attr('refX', 10)
                    .attr('refY', 3.5)
                    .attr('orient', 'auto')
                    .append('polygon')
                    .attr('points', '0 0, 10 3.5, 0 7')
                    .attr('fill', '#22d3ee');
                
                defs.append('marker')
                    .attr('id', 'arrow-closed')
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 7)
                    .attr('refX', 10)
                    .attr('refY', 3.5)
                    .attr('orient', 'auto')
                    .append('polygon')
                    .attr('points', '0 0, 10 3.5, 0 7')
                    .attr('fill', '#f472b6');
                
                // Labels
                svg.append('text')
                    .attr('x', cx)
                    .attr('y', cy + r + 40)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#9ca3af')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 12)
                    .text('Region B');
            }
            
            draw();
            
            document.querySelectorAll('[data-color]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-color]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    colorMode = btn.dataset.color;
                    draw();
                });
            });
            
            document.getElementById('animate-colors').addEventListener('click', () => {
                if (animating) return;
                animating = true;
                
                const modes = ['multipole', 'local', 'both'];
                let i = 0;
                
                const interval = setInterval(() => {
                    colorMode = modes[i % 3];
                    document.querySelectorAll('[data-color]').forEach(b => {
                        b.classList.toggle('active', b.dataset.color === colorMode);
                    });
                    draw();
                    i++;
                    if (i >= 6) {
                        clearInterval(interval);
                        animating = false;
                    }
                }, 800);
            });
        })();

        // Figure 2: Little Disks Operad
        (function() {
            const container = document.getElementById('fig2-canvas');
            const width = 860;
            const height = 380;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`);
            
            let numInputs = 2;
            let showComposition = false;
            
            function draw() {
                svg.selectAll('*').remove();
                
                svg.append('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                if (!showComposition) {
                    // Single operation
                    const cx = width / 2;
                    const cy = height / 2;
                    const outerR = 130;
                    
                    // Outer disk
                    svg.append('circle')
                        .attr('cx', cx)
                        .attr('cy', cy)
                        .attr('r', outerR)
                        .attr('fill', 'rgba(34, 211, 238, 0.1)')
                        .attr('stroke', '#22d3ee')
                        .attr('stroke-width', 2);
                    
                    // Inner disks
                    const innerR = numInputs === 2 ? 40 : (numInputs === 3 ? 35 : 30);
                    const spread = numInputs === 2 ? 55 : (numInputs === 3 ? 60 : 65);
                    
                    for (let i = 0; i < numInputs; i++) {
                        const angle = -Math.PI/2 + (2 * Math.PI * i / numInputs);
                        const x = cx + spread * Math.cos(angle);
                        const y = cy + spread * Math.sin(angle);
                        
                        svg.append('circle')
                            .attr('cx', x)
                            .attr('cy', y)
                            .attr('r', innerR)
                            .attr('fill', 'rgba(139, 92, 246, 0.2)')
                            .attr('stroke', '#a78bfa')
                            .attr('stroke-width', 2);
                        
                        svg.append('text')
                            .attr('x', x)
                            .attr('y', y + 5)
                            .attr('text-anchor', 'middle')
                            .attr('fill', '#a78bfa')
                            .attr('font-family', 'JetBrains Mono')
                            .attr('font-size', 14)
                            .text(i + 1);
                    }
                    
                    svg.append('text')
                        .attr('x', cx)
                        .attr('y', cy + outerR + 30)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#9ca3af')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 12)
                        .text(`E‚ÇÇ(${numInputs}) : Operation with ${numInputs} inputs`);
                } else {
                    // Show composition
                    const leftX = 200;
                    const rightX = 550;
                    const cy = height / 2;
                    
                    // First operation
                    svg.append('circle')
                        .attr('cx', leftX)
                        .attr('cy', cy)
                        .attr('r', 80)
                        .attr('fill', 'rgba(34, 211, 238, 0.1)')
                        .attr('stroke', '#22d3ee')
                        .attr('stroke-width', 2);
                    
                    // Inner disks in first
                    svg.append('circle')
                        .attr('cx', leftX - 25)
                        .attr('cy', cy)
                        .attr('r', 25)
                        .attr('fill', 'rgba(139, 92, 246, 0.2)')
                        .attr('stroke', '#a78bfa')
                        .attr('stroke-width', 2);
                    
                    svg.append('circle')
                        .attr('cx', leftX + 25)
                        .attr('cy', cy)
                        .attr('r', 25)
                        .attr('fill', 'rgba(244, 114, 182, 0.2)')
                        .attr('stroke', '#f472b6')
                        .attr('stroke-width', 2);
                    
                    // Arrow
                    svg.append('path')
                        .attr('d', `M ${leftX + 100} ${cy} L ${rightX - 110} ${cy}`)
                        .attr('stroke', '#fbbf24')
                        .attr('stroke-width', 2)
                        .attr('marker-end', 'url(#arrow-comp)');
                    
                    svg.append('text')
                        .attr('x', (leftX + rightX) / 2)
                        .attr('y', cy - 15)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#fbbf24')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 12)
                        .text('compose');
                    
                    // Result
                    svg.append('circle')
                        .attr('cx', rightX)
                        .attr('cy', cy)
                        .attr('r', 100)
                        .attr('fill', 'rgba(34, 211, 238, 0.1)')
                        .attr('stroke', '#22d3ee')
                        .attr('stroke-width', 2);
                    
                    // Composed inner structure
                    svg.append('circle')
                        .attr('cx', rightX - 30)
                        .attr('cy', cy)
                        .attr('r', 35)
                        .attr('fill', 'rgba(139, 92, 246, 0.1)')
                        .attr('stroke', '#a78bfa')
                        .attr('stroke-width', 1.5);
                    
                    svg.append('circle')
                        .attr('cx', rightX - 40)
                        .attr('cy', cy - 8)
                        .attr('r', 12)
                        .attr('fill', 'rgba(74, 222, 128, 0.3)')
                        .attr('stroke', '#4ade80')
                        .attr('stroke-width', 1.5);
                    
                    svg.append('circle')
                        .attr('cx', rightX - 20)
                        .attr('cy', cy + 8)
                        .attr('r', 12)
                        .attr('fill', 'rgba(74, 222, 128, 0.3)')
                        .attr('stroke', '#4ade80')
                        .attr('stroke-width', 1.5);
                    
                    svg.append('circle')
                        .attr('cx', rightX + 30)
                        .attr('cy', cy)
                        .attr('r', 25)
                        .attr('fill', 'rgba(244, 114, 182, 0.2)')
                        .attr('stroke', '#f472b6')
                        .attr('stroke-width', 2);
                    
                    // Arrow marker
                    svg.append('defs').append('marker')
                        .attr('id', 'arrow-comp')
                        .attr('markerWidth', 10)
                        .attr('markerHeight', 7)
                        .attr('refX', 10)
                        .attr('refY', 3.5)
                        .attr('orient', 'auto')
                        .append('polygon')
                        .attr('points', '0 0, 10 3.5, 0 7')
                        .attr('fill', '#fbbf24');
                }
            }
            
            draw();
            
            document.querySelectorAll('[data-inputs]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-inputs]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    numInputs = parseInt(btn.dataset.inputs);
                    showComposition = false;
                    draw();
                });
            });
            
            document.getElementById('show-composition').addEventListener('click', () => {
                showComposition = !showComposition;
                draw();
            });
        })();

        // Figure 3: Swiss Cheese Operations
        (function() {
            const container = document.getElementById('fig3-canvas');
            const width = 860;
            const height = 420;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`);
            
            let opType = 'open';
            let disks = [];
            
            function draw() {
                svg.selectAll('*').remove();
                
                svg.append('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const cx = width / 2;
                const cy = height / 2;
                const outerR = 150;
                
                // Outer boundary disk
                svg.append('circle')
                    .attr('cx', cx)
                    .attr('cy', cy)
                    .attr('r', outerR)
                    .attr('fill', 'rgba(100, 100, 120, 0.1)')
                    .attr('stroke', '#6b7280')
                    .attr('stroke-width', 2);
                
                // Default disks based on operation type
                if (disks.length === 0) {
                    if (opType === 'open') {
                        disks = [
                            { x: cx - 50, y: cy, r: 35, type: 'open' },
                            { x: cx + 50, y: cy - 20, r: 30, type: 'open' }
                        ];
                    } else if (opType === 'closed') {
                        disks = [
                            { x: cx - 40, y: cy + 30, r: 35, type: 'closed' },
                            { x: cx + 60, y: cy - 10, r: 40, type: 'closed' }
                        ];
                    } else {
                        disks = [
                            { x: cx - 60, y: cy - 20, r: 30, type: 'open' },
                            { x: cx + 40, y: cy + 40, r: 35, type: 'closed' },
                            { x: cx + 80, y: cy - 60, r: 25, type: 'closed' }
                        ];
                    }
                }
                
                // Draw disks
                disks.forEach((d, i) => {
                    const color = d.type === 'open' ? '#22d3ee' : '#f472b6';
                    const fillOpacity = d.type === 'open' ? 0.15 : 0.2;
                    
                    svg.append('circle')
                        .attr('cx', d.x)
                        .attr('cy', d.y)
                        .attr('r', d.r)
                        .attr('fill', `${color}${Math.round(fillOpacity * 255).toString(16).padStart(2, '0')}`)
                        .attr('stroke', color)
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', d.type === 'closed' ? '5,3' : null);
                    
                    svg.append('text')
                        .attr('x', d.x)
                        .attr('y', d.y + 5)
                        .attr('text-anchor', 'middle')
                        .attr('fill', color)
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 11)
                        .text(d.type === 'open' ? 'M' : 'L');
                });
                
                // Legend
                svg.append('text')
                    .attr('x', 60)
                    .attr('y', 40)
                    .attr('fill', '#22d3ee')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 11)
                    .text('‚óã Open (Multipole)');
                
                svg.append('text')
                    .attr('x', 60)
                    .attr('y', 60)
                    .attr('fill', '#f472b6')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 11)
                    .text('‚óå Closed (Local)');
                
                // Operation type label
                const typeLabel = opType === 'open' ? 'Open-only operations (E_d)' :
                                  opType === 'closed' ? 'Closed-only operations' :
                                  'Mixed operations (Swiss Cheese)';
                
                svg.append('text')
                    .attr('x', cx)
                    .attr('y', height - 30)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#9ca3af')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 12)
                    .text(typeLabel);
            }
            
            draw();
            
            document.querySelectorAll('[data-op]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-op]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    opType = btn.dataset.op;
                    disks = [];
                    draw();
                });
            });
            
            document.getElementById('add-disk').addEventListener('click', () => {
                const cx = width / 2;
                const cy = height / 2;
                const type = opType === 'closed' ? 'closed' : (opType === 'open' ? 'open' : (Math.random() > 0.5 ? 'open' : 'closed'));
                const newDisk = {
                    x: cx + (Math.random() - 0.5) * 200,
                    y: cy + (Math.random() - 0.5) * 200,
                    r: 20 + Math.random() * 25,
                    type: type
                };
                disks.push(newDisk);
                draw();
            });
            
            document.getElementById('reset-disks').addEventListener('click', () => {
                disks = [];
                draw();
            });
        })();

        // Figure 4: Translation Operators
        (function() {
            const container = document.getElementById('fig4-canvas');
            const width = 860;
            const height = 400;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`);
            
            let transType = 'm2m';
            
            function draw() {
                svg.selectAll('*').remove();
                
                svg.append('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                const cy = height / 2;
                
                // Arrow marker
                svg.append('defs').append('marker')
                    .attr('id', 'arrow-trans')
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 7)
                    .attr('refX', 10)
                    .attr('refY', 3.5)
                    .attr('orient', 'auto')
                    .append('polygon')
                    .attr('points', '0 0, 10 3.5, 0 7')
                    .attr('fill', '#fbbf24');
                
                if (transType === 'm2m') {
                    // M2M: Two children to parent
                    const child1X = 150;
                    const child2X = 300;
                    const parentX = 550;
                    
                    // Child 1
                    svg.append('circle')
                        .attr('cx', child1X)
                        .attr('cy', cy)
                        .attr('r', 50)
                        .attr('fill', 'rgba(34, 211, 238, 0.15)')
                        .attr('stroke', '#22d3ee')
                        .attr('stroke-width', 2);
                    svg.append('text')
                        .attr('x', child1X)
                        .attr('y', cy + 5)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#22d3ee')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 14)
                        .text('M‚ÇÅ');
                    
                    // Child 2
                    svg.append('circle')
                        .attr('cx', child2X)
                        .attr('cy', cy)
                        .attr('r', 50)
                        .attr('fill', 'rgba(34, 211, 238, 0.15)')
                        .attr('stroke', '#22d3ee')
                        .attr('stroke-width', 2);
                    svg.append('text')
                        .attr('x', child2X)
                        .attr('y', cy + 5)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#22d3ee')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 14)
                        .text('M‚ÇÇ');
                    
                    // Arrow
                    svg.append('path')
                        .attr('d', `M 370 ${cy} L 470 ${cy}`)
                        .attr('stroke', '#fbbf24')
                        .attr('stroke-width', 3)
                        .attr('marker-end', 'url(#arrow-trans)');
                    
                    svg.append('text')
                        .attr('x', 420)
                        .attr('y', cy - 20)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#fbbf24')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 14)
                        .text('M2M');
                    
                    // Parent
                    svg.append('circle')
                        .attr('cx', parentX)
                        .attr('cy', cy)
                        .attr('r', 80)
                        .attr('fill', 'rgba(34, 211, 238, 0.1)')
                        .attr('stroke', '#22d3ee')
                        .attr('stroke-width', 2);
                    svg.append('text')
                        .attr('x', parentX)
                        .attr('y', cy + 5)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#22d3ee')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 16)
                        .text('M');
                    
                    svg.append('text')
                        .attr('x', width / 2)
                        .attr('y', height - 30)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#9ca3af')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 12)
                        .text('Open ‚äó Open ‚Üí Open');
                    
                } else if (transType === 'l2l') {
                    // L2L: Parent to child
                    const parentX = 250;
                    const childX = 550;
                    
                    // Parent local
                    svg.append('circle')
                        .attr('cx', parentX)
                        .attr('cy', cy)
                        .attr('r', 80)
                        .attr('fill', 'rgba(244, 114, 182, 0.1)')
                        .attr('stroke', '#f472b6')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '5,3');
                    svg.append('text')
                        .attr('x', parentX)
                        .attr('y', cy + 5)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#f472b6')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 16)
                        .text('L');
                    
                    // Arrow
                    svg.append('path')
                        .attr('d', `M 350 ${cy} L 470 ${cy}`)
                        .attr('stroke', '#fbbf24')
                        .attr('stroke-width', 3)
                        .attr('marker-end', 'url(#arrow-trans)');
                    
                    svg.append('text')
                        .attr('x', 410)
                        .attr('y', cy - 20)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#fbbf24')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 14)
                        .text('L2L');
                    
                    // Child local
                    svg.append('circle')
                        .attr('cx', childX)
                        .attr('cy', cy)
                        .attr('r', 50)
                        .attr('fill', 'rgba(244, 114, 182, 0.15)')
                        .attr('stroke', '#f472b6')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '5,3');
                    svg.append('text')
                        .attr('x', childX)
                        .attr('y', cy + 5)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#f472b6')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 14)
                        .text("L'");
                    
                    svg.append('text')
                        .attr('x', width / 2)
                        .attr('y', height - 30)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#9ca3af')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 12)
                        .text('Closed ‚Üí Closed');
                    
                } else {
                    // M2L: Multipole to Local
                    const sourceX = 200;
                    const targetX = 600;
                    
                    // Source (multipole)
                    svg.append('circle')
                        .attr('cx', sourceX)
                        .attr('cy', cy)
                        .attr('r', 60)
                        .attr('fill', 'rgba(34, 211, 238, 0.15)')
                        .attr('stroke', '#22d3ee')
                        .attr('stroke-width', 2);
                    svg.append('text')
                        .attr('x', sourceX)
                        .attr('y', cy + 5)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#22d3ee')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 16)
                        .text('M');
                    svg.append('text')
                        .attr('x', sourceX)
                        .attr('y', cy + 90)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#22d3ee')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 11)
                        .text('(sources)');
                    
                    // Well-separation gap
                    svg.append('text')
                        .attr('x', 400)
                        .attr('y', cy + 60)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#6b7280')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 10)
                        .text('well-separated');
                    
                    // Arrow
                    svg.append('path')
                        .attr('d', `M 280 ${cy} L 520 ${cy}`)
                        .attr('stroke', '#fbbf24')
                        .attr('stroke-width', 3)
                        .attr('marker-end', 'url(#arrow-trans)');
                    
                    svg.append('text')
                        .attr('x', 400)
                        .attr('y', cy - 20)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#fbbf24')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 14)
                        .text('M2L');
                    
                    // Target (local)
                    svg.append('circle')
                        .attr('cx', targetX)
                        .attr('cy', cy)
                        .attr('r', 60)
                        .attr('fill', 'rgba(244, 114, 182, 0.15)')
                        .attr('stroke', '#f472b6')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '5,3');
                    svg.append('text')
                        .attr('x', targetX)
                        .attr('y', cy + 5)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#f472b6')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 16)
                        .text('L');
                    svg.append('text')
                        .attr('x', targetX)
                        .attr('y', cy + 90)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#f472b6')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 11)
                        .text('(effects)');
                    
                    svg.append('text')
                        .attr('x', width / 2)
                        .attr('y', height - 30)
                        .attr('text-anchor', 'middle')
                        .attr('fill', '#9ca3af')
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', 12)
                        .text('Open ‚Üí Closed (Mixed Operation)');
                }
            }
            
            draw();
            
            document.querySelectorAll('[data-trans]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-trans]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    transType = btn.dataset.trans;
                    draw();
                });
            });
            
            document.getElementById('animate-operator').addEventListener('click', () => {
                const types = ['m2m', 'l2l', 'm2l'];
                let i = 0;
                
                const interval = setInterval(() => {
                    transType = types[i % 3];
                    document.querySelectorAll('[data-trans]').forEach(b => {
                        b.classList.toggle('active', b.dataset.trans === transType);
                    });
                    draw();
                    i++;
                    if (i >= 6) clearInterval(interval);
                }, 1000);
            });
        })();

        // Figure 5: Complete Operadic Structure
        (function() {
            const container = document.getElementById('fig5-canvas');
            const width = 860;
            const height = 450;
            
            const svg = d3.select(container)
                .append('svg')
                .attr('viewBox', `0 0 ${width} ${height}`);
            
            let phase = 'upward';
            
            function draw() {
                svg.selectAll('*').remove();
                
                svg.append('rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'rgba(10, 10, 20, 0.8)');
                
                // Tree structure
                const treeNodes = [
                    { x: 430, y: 70, r: 60, level: 0, label: 'Root' },
                    { x: 230, y: 180, r: 45, level: 1, label: '' },
                    { x: 630, y: 180, r: 45, level: 1, label: '' },
                    { x: 130, y: 310, r: 35, level: 2, label: '' },
                    { x: 280, y: 310, r: 35, level: 2, label: '' },
                    { x: 530, y: 310, r: 35, level: 2, label: '' },
                    { x: 730, y: 310, r: 35, level: 2, label: '' }
                ];
                
                // Edges
                const edges = [
                    [0, 1], [0, 2],
                    [1, 3], [1, 4],
                    [2, 5], [2, 6]
                ];
                
                edges.forEach(([i, j]) => {
                    svg.append('line')
                        .attr('x1', treeNodes[i].x)
                        .attr('y1', treeNodes[i].y + treeNodes[i].r)
                        .attr('x2', treeNodes[j].x)
                        .attr('y2', treeNodes[j].y - treeNodes[j].r)
                        .attr('stroke', '#4b5563')
                        .attr('stroke-width', 2);
                });
                
                // Draw nodes with appropriate coloring based on phase
                treeNodes.forEach((node, i) => {
                    let fillColor, strokeColor, label;
                    
                    if (phase === 'upward') {
                        // Upward: all multipole (cyan)
                        fillColor = 'rgba(34, 211, 238, 0.15)';
                        strokeColor = '#22d3ee';
                        label = 'M';
                    } else if (phase === 'm2l') {
                        // M2L phase: show conversion
                        if (i === 0) {
                            fillColor = 'rgba(244, 114, 182, 0.15)';
                            strokeColor = '#f472b6';
                            label = 'L';
                        } else {
                            fillColor = 'rgba(34, 211, 238, 0.15)';
                            strokeColor = '#22d3ee';
                            label = 'M';
                        }
                    } else if (phase === 'downward') {
                        // Downward: all local (pink)
                        fillColor = 'rgba(244, 114, 182, 0.15)';
                        strokeColor = '#f472b6';
                        label = 'L';
                    } else {
                        // Full algorithm: mixed
                        if (node.level === 0) {
                            fillColor = 'rgba(139, 92, 246, 0.2)';
                            strokeColor = '#a78bfa';
                            label = 'M+L';
                        } else if (node.level === 1) {
                            fillColor = 'rgba(251, 191, 36, 0.2)';
                            strokeColor = '#fbbf24';
                            label = 'M‚ÜîL';
                        } else {
                            fillColor = 'rgba(74, 222, 128, 0.15)';
                            strokeColor = '#4ade80';
                            label = '‚äï';
                        }
                    }
                    
                    svg.append('circle')
                        .attr('cx', node.x)
                        .attr('cy', node.y)
                        .attr('r', node.r)
                        .attr('fill', fillColor)
                        .attr('stroke', strokeColor)
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', (phase === 'downward' || (phase === 'm2l' && i === 0)) ? '5,3' : null);
                    
                    svg.append('text')
                        .attr('x', node.x)
                        .attr('y', node.y + 5)
                        .attr('text-anchor', 'middle')
                        .attr('fill', strokeColor)
                        .attr('font-family', 'JetBrains Mono')
                        .attr('font-size', node.level === 2 ? 12 : 14)
                        .text(label);
                });
                
                // Phase description
                const descriptions = {
                    upward: 'Upward Pass: M2M combines multipole expansions (leaf ‚Üí root)',
                    m2l: 'M2L Phase: Convert far-field multipoles to near-field locals',
                    downward: 'Downward Pass: L2L distributes local expansions (root ‚Üí leaf)',
                    all: 'Complete FMM: Swiss cheese structure orchestrates all operations'
                };
                
                svg.append('text')
                    .attr('x', width / 2)
                    .attr('y', height - 20)
                    .attr('text-anchor', 'middle')
                    .attr('fill', '#9ca3af')
                    .attr('font-family', 'JetBrains Mono')
                    .attr('font-size', 12)
                    .text(descriptions[phase]);
                
                // Arrows for upward/downward
                if (phase === 'upward') {
                    svg.append('path')
                        .attr('d', 'M 100 350 L 100 100')
                        .attr('stroke', '#22d3ee')
                        .attr('stroke-width', 2)
                        .attr('marker-end', 'url(#arrow-up)')
                        .attr('opacity', 0.5);
                } else if (phase === 'downward') {
                    svg.append('path')
                        .attr('d', 'M 760 100 L 760 350')
                        .attr('stroke', '#f472b6')
                        .attr('stroke-width', 2)
                        .attr('marker-end', 'url(#arrow-down)')
                        .attr('opacity', 0.5);
                }
                
                // Arrow markers
                const defs = svg.append('defs');
                defs.append('marker')
                    .attr('id', 'arrow-up')
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 7)
                    .attr('refX', 5)
                    .attr('refY', 3.5)
                    .attr('orient', 'auto')
                    .append('polygon')
                    .attr('points', '0 7, 5 0, 10 7')
                    .attr('fill', '#22d3ee');
                
                defs.append('marker')
                    .attr('id', 'arrow-down')
                    .attr('markerWidth', 10)
                    .attr('markerHeight', 7)
                    .attr('refX', 5)
                    .attr('refY', 3.5)
                    .attr('orient', 'auto')
                    .append('polygon')
                    .attr('points', '0 0, 5 7, 10 0')
                    .attr('fill', '#f472b6');
            }
            
            draw();
            
            document.querySelectorAll('[data-phase]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('[data-phase]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    phase = btn.dataset.phase;
                    draw();
                });
            });
        })();
    </script>
</body>
</html>
